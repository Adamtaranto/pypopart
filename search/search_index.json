{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"PyPopART Documentation","text":"<p>Welcome to PyPopART - a pure Python implementation of PopART (Population Analysis with Reticulate Trees) for constructing and visualizing haplotype networks from DNA sequence data.</p>"},{"location":"#overview","title":"Overview","text":"<p>PyPopART provides a complete toolkit for:</p> <ul> <li>Network Construction: Six algorithms (MST, MSN, TCS, MJN, PN, TSW)</li> <li>Distance Calculation: Multiple evolutionary models</li> <li>Network Analysis: Comprehensive statistics and topology analysis</li> <li>Visualization: Static, interactive, and web-based network plots</li> <li>Population Genetics: Diversity measures, FST, Tajima's D, and more</li> <li>Dual Interface: Command-line tools and web-based GUI</li> </ul>"},{"location":"#key-features","title":"Key Features","text":""},{"location":"#multiple-algorithms","title":"\ud83c\udf33 Multiple Algorithms","text":"<ul> <li>MST (Minimum Spanning Tree): Simplest tree-based network</li> <li>MSN (Minimum Spanning Network): Shows alternative connections</li> <li>TCS (Statistical Parsimony): Statistically justified connections</li> <li>MJN (Median-Joining): Infers ancestral haplotypes</li> <li>PN (Parsimony Network): Consensus from multiple trees</li> <li>TSW (Tight Span Walker): Metric-preserving network construction</li> </ul>"},{"location":"#distance-metrics","title":"\ud83d\udccf Distance Metrics","text":"<ul> <li>Hamming distance</li> <li>Jukes-Cantor correction</li> <li>Kimura 2-parameter</li> <li>Tamura-Nei model</li> </ul>"},{"location":"#comprehensive-analysis","title":"\ud83d\udcca Comprehensive Analysis","text":"<ul> <li>Network statistics (diameter, clustering, centrality)</li> <li>Topology analysis (star patterns, hubs, bridges)</li> <li>Population genetics measures (Tajima's D, Fu's Fs, FST)</li> <li>Diversity metrics (nucleotide, haplotype, Shannon)</li> </ul>"},{"location":"#rich-visualization","title":"\ud83c\udfa8 Rich Visualization","text":"<ul> <li>Static plots with matplotlib (PNG, PDF, SVG)</li> <li>Interactive plots with Plotly (HTML)</li> <li>Multiple layout algorithms</li> <li>Customizable colors, sizes, and labels</li> </ul>"},{"location":"#flexible-io","title":"\ud83d\udcc1 Flexible I/O","text":"<ul> <li>Input: FASTA, NEXUS, PHYLIP, GenBank</li> <li>Output: GraphML, GML, JSON, NEXUS</li> <li>Metadata support (populations, traits, locations)</li> </ul>"},{"location":"#entry-points","title":"Entry Points","text":"<p>PyPopART offers two interfaces for different workflows:</p>"},{"location":"#command-line-interface-cli","title":"Command-Line Interface (CLI)","text":"<p>For automation, scripting, and batch processing:</p> <pre><code># Get help\npypopart --help\n\n# List available algorithms\npypopart info --list-algorithms\n\n# Construct a median-joining network\npypopart network sequences.fasta -o network.graphml\n\n# Visualize the network\npypopart visualize network.graphml -o network.png\n</code></pre>"},{"location":"#web-based-gui","title":"Web-based GUI","text":"<p>For interactive analysis and exploration:</p> <pre><code># Start the GUI application\npypopart-gui\n\n# Opens web interface at http://localhost:8050\n# or specify custom port:\npypopart-gui --port 8080\n</code></pre> <p>The GUI provides: - Drag-and-drop file upload - Interactive network visualization (zoom, pan, drag nodes) - Real-time algorithm parameter adjustment - Population-based coloring with pie charts - Multiple layout algorithms - Network statistics and haplotype summaries - Export to various formats</p>"},{"location":"#quick-examples","title":"Quick Examples","text":""},{"location":"#command-line-workflow","title":"Command Line Workflow","text":"<pre><code># Load and validate sequences\npypopart load sequences.fasta\n\n# Construct network with TCS algorithm\npypopart network sequences.fasta -a tcs -o network.graphml\n\n# Analyze network statistics\npypopart analyze network.graphml --stats\n\n# Create visualization\npypopart visualize network.graphml -o network.png\n</code></pre>"},{"location":"#python-api","title":"Python API","text":"<pre><code>from pypopart.io import load_alignment\nfrom pypopart.algorithms import MJNAlgorithm\nfrom pypopart.core.distance import DistanceCalculator\nfrom pypopart.core.condensation import condense_alignment\nfrom pypopart.visualization import StaticVisualizer\n\n# Load data\nalignment = load_alignment('sequences.fasta')\n\n# Calculate distances\ncalc = DistanceCalculator(method='k2p')\ndistances = calc.calculate_matrix(alignment)\n\n# Build network\nhaplotypes, _ = condense_alignment(alignment)\nmjn = MJNAlgorithm(epsilon=0)\nnetwork = mjn.construct_network(haplotypes, distances)\n\n# Visualize\nviz = StaticVisualizer(network)\nviz.plot(output_file='network.png')\n</code></pre>"},{"location":"#getting-started","title":"Getting Started","text":"<ul> <li>Installation: Install PyPopART</li> <li>Quick Start: Your first haplotype network</li> <li>Basic Concepts: Understanding haplotype networks</li> </ul>"},{"location":"#user-guide","title":"User Guide","text":"<ul> <li>CLI Guide: Command-line interface</li> <li>Python API: Programmatic usage</li> <li>Algorithms: Choosing the right algorithm</li> <li>Visualization: Creating beautiful plots</li> </ul>"},{"location":"#tutorials","title":"Tutorials","text":"<ul> <li>Basic Workflow: Complete example</li> <li>Algorithm Comparison: Compare all algorithms</li> <li>Visualization Options: Customize your plots</li> <li>Population Genetics: Genetic diversity analysis</li> </ul>"},{"location":"#api-reference","title":"API Reference","text":"<p>Detailed documentation for all classes and functions:</p> <ul> <li>Core Classes: Sequence, Alignment, Haplotype</li> <li>Algorithms: Network construction</li> <li>Visualization: Plotting functions</li> <li>Statistics: Analysis tools</li> </ul>"},{"location":"#about","title":"About","text":"<p>PyPopART is developed and maintained by Adam Taranto. It is inspired by the original PopART software by Jessica Leigh and David Bryant.</p> <p>License: GNU General Public License v3.0 or later</p> <p>Citation: If you use PyPopART in your research, please cite:</p> <pre><code>Taranto, A. (2024). PyPopART: Pure Python implementation of haplotype network analysis.\nGitHub repository: https://github.com/adamtaranto/pypopart\n</code></pre>"},{"location":"#need-help","title":"Need Help?","text":"<ul> <li>FAQ: Frequently asked questions</li> <li>GitHub Issues: Report bugs or request features</li> <li>Contributing: Contribute to PyPopART</li> </ul>"},{"location":"CYTOSCAPE_MIGRATION/","title":"Cytoscape Network Visualization Migration","text":""},{"location":"CYTOSCAPE_MIGRATION/#overview","title":"Overview","text":"<p>The PyPopART Dash application now uses Dash Cytoscape for network visualization, replacing the previous Plotly-based graphs. This migration provides improved interactivity, manual node repositioning, and better support for complex network features.</p>"},{"location":"CYTOSCAPE_MIGRATION/#key-features","title":"Key Features","text":""},{"location":"CYTOSCAPE_MIGRATION/#1-manual-node-repositioning","title":"1. Manual Node Repositioning","text":"<p>What it does: Nodes can be dragged and repositioned manually using the mouse.</p> <p>How to use: - Click and hold on any node in the network - Drag it to a new position - Release to place the node - The new position is automatically saved</p> <p>Snap to Grid: Enable the \"Snap to Grid\" option in the Layout Options panel to align nodes to a grid when released.</p>"},{"location":"CYTOSCAPE_MIGRATION/#2-population-visualization","title":"2. Population Visualization","text":""},{"location":"CYTOSCAPE_MIGRATION/#single-population-nodes","title":"Single Population Nodes","text":"<p>Nodes containing samples from a single population are displayed with the population's assigned color.</p>"},{"location":"CYTOSCAPE_MIGRATION/#mixed-population-nodes","title":"Mixed Population Nodes","text":"<p>Nodes containing samples from multiple populations are displayed as pie charts: - Each segment represents a population, sized by its proportion - Segment colors match the population colors from the legend - Pie charts are generated as SVG and embedded as node backgrounds - Hover over the node to see the exact population breakdown</p>"},{"location":"CYTOSCAPE_MIGRATION/#3-legend-display","title":"3. Legend Display","text":"<p>The legend (top right corner) shows: - Population colors: Circle markers with population names - Mixed populations indicator: Pie icon (\u25d5) indicating nodes with pie chart visualization - Median vectors: Gray square (\u25a0) for inferred median vector nodes</p>"},{"location":"CYTOSCAPE_MIGRATION/#4-edge-labels","title":"4. Edge Labels","text":"<p>Edges display the number of mutations between connected haplotypes as numeric labels.</p>"},{"location":"CYTOSCAPE_MIGRATION/#5-interactive-controls","title":"5. Interactive Controls","text":"<p>Zoom: Use mouse wheel or pinch gesture to zoom in/out</p> <p>Pan: Click and drag on the background to move the entire network</p> <p>Select: Click on nodes to select them (highlighted with red border)</p> <p>Hover: Mouse over nodes or edges to see detailed information</p>"},{"location":"CYTOSCAPE_MIGRATION/#technical-details","title":"Technical Details","text":""},{"location":"CYTOSCAPE_MIGRATION/#cytoscape-elements-structure","title":"Cytoscape Elements Structure","text":"<p>Each node element contains: - <code>id</code>: Unique haplotype identifier (e.g., \"H1\", \"H2\") - <code>label</code>: Display label - <code>size</code>: Visual size based on frequency - <code>color</code>: Node color (population-based, transparent for pie charts, or default) - <code>is_median</code>: Boolean indicating if this is a median vector - <code>has_pie</code>: Boolean indicating mixed population composition - <code>pie_data</code>: Array of population frequency data (for mixed nodes) - <code>pie_svg</code>: SVG Data URI containing the pie chart visualization (for mixed nodes)</p> <p>Each edge element contains: - <code>id</code>: Unique edge identifier - <code>source</code>: Source node ID - <code>target</code>: Target node ID - <code>weight</code>: Genetic distance (mutation count) - <code>label</code>: Distance label for display</p>"},{"location":"CYTOSCAPE_MIGRATION/#layout-algorithms","title":"Layout Algorithms","text":"<p>Available layout algorithms: - Spring (Force-directed): Physically-simulated layout - Circular: Nodes arranged in a circle - Radial: Radial tree layout - Hierarchical: Hierarchical tree structure - Kamada-Kawai: Force-directed with minimum energy - Spring/KK Proportional: Edge lengths proportional to mutation distances</p>"},{"location":"CYTOSCAPE_MIGRATION/#color-generation","title":"Color Generation","text":"<p>When population colors are not specified in metadata: - Colors are automatically generated using HSV color space - Evenly distributed hues for maximum distinction - High saturation and value for vivid colors</p>"},{"location":"CYTOSCAPE_MIGRATION/#migration-from-plotly","title":"Migration from Plotly","text":""},{"location":"CYTOSCAPE_MIGRATION/#what-changed","title":"What Changed","text":"<ol> <li>Component Type: <code>dcc.Graph</code> \u2192 <code>cyto.Cytoscape</code></li> <li>Data Format: Plotly figure traces \u2192 Cytoscape elements</li> <li>Callbacks: Updated to handle Cytoscape events</li> <li>Node Positioning: Now directly editable by users</li> </ol>"},{"location":"CYTOSCAPE_MIGRATION/#what-stayed-the-same","title":"What Stayed the Same","text":"<ul> <li>All network algorithms (MST, MSN, TCS, MJN)</li> <li>Layout computation methods</li> <li>Metadata support</li> <li>Export functionality</li> <li>Statistics calculations</li> <li>Haplotype summary</li> </ul>"},{"location":"CYTOSCAPE_MIGRATION/#api-changes","title":"API Changes","text":""},{"location":"CYTOSCAPE_MIGRATION/#interactivecytoscapeplotter","title":"InteractiveCytoscapePlotter","text":"<p>New class for creating Cytoscape visualizations:</p> <pre><code>from pypopart.visualization.cytoscape_plot import (\n    InteractiveCytoscapePlotter,\n    create_cytoscape_network\n)\n\n# Create plotter\nplotter = InteractiveCytoscapePlotter(network)\n\n# Generate elements and stylesheet\nelements = plotter.create_elements(\n    layout=positions,\n    population_colors={'PopA': '#FF0000', 'PopB': '#0000FF'},\n    show_labels=True,\n    show_edge_labels=True,\n)\n\nstylesheet = plotter.create_stylesheet(\n    population_colors=population_colors,\n)\n\n# Or use convenience function\nelements, stylesheet = create_cytoscape_network(\n    network,\n    layout=positions,\n    population_colors=population_colors,\n)\n</code></pre>"},{"location":"CYTOSCAPE_MIGRATION/#convenience-functions","title":"Convenience Functions","text":"<pre><code># Auto-generate population colors\ncolors = plotter.generate_population_colors(['PopA', 'PopB', 'PopC'])\n\n# Create pie chart styles\npie_styles = plotter.create_pie_stylesheet(population_colors)\n</code></pre>"},{"location":"CYTOSCAPE_MIGRATION/#backward-compatibility","title":"Backward Compatibility","text":"<p>The original Plotly-based <code>InteractiveNetworkPlotter</code> is still available and unchanged:</p> <pre><code>from pypopart.visualization.interactive_plot import InteractiveNetworkPlotter\n\n# Still works as before\nplotter = InteractiveNetworkPlotter(network)\nfig = plotter.plot(layout=positions)\n</code></pre>"},{"location":"CYTOSCAPE_MIGRATION/#testing","title":"Testing","text":"<p>Comprehensive test suite in <code>tests/unit/test_cytoscape_plot.py</code>: - Element creation and structure - Node sizing and coloring - Population data handling - Edge labels - Stylesheet generation - Empty and edge cases</p> <p>Run tests: <pre><code>pytest tests/unit/test_cytoscape_plot.py -v\n</code></pre></p>"},{"location":"CYTOSCAPE_MIGRATION/#future-enhancements","title":"Future Enhancements","text":"<p>Potential improvements for future versions: - True pie chart rendering using custom Cytoscape.js extensions - Animation support for layout transitions - Advanced selection and filtering tools - Export to Cytoscape.js format - Custom node shapes for different haplotype types</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to PyPopART will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"Unreleased","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Comprehensive documentation site with MkDocs</li> <li>Interactive web-based GUI with Dash and Cytoscape</li> <li>TSW (Tight Span Walker) algorithm implementation</li> <li>Layout algorithms for network visualization</li> <li>Population genetics statistics (Tajima's D, Fu's Fs, FST)</li> <li>Network topology analysis tools</li> <li>Multiple export formats for networks</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Improved CLI interface with better error handling</li> <li>Enhanced visualization options</li> </ul>"},{"location":"changelog/#010-initial-release","title":"0.1.0 - Initial Release","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Core haplotype network algorithms (MST, MSN, TCS, MJN, PN)</li> <li>Distance calculation with multiple evolutionary models</li> <li>FASTA, NEXUS, PHYLIP, and GenBank file format support</li> <li>Static and interactive visualization</li> <li>Command-line interface</li> <li>Python API for programmatic access</li> <li>Network statistics and analysis tools</li> </ul>"},{"location":"concepts/","title":"Basic Concepts","text":"<p>Understanding the fundamental concepts behind PyPopART will help you make the most of the software.</p>"},{"location":"concepts/#what-are-haplotype-networks","title":"What are Haplotype Networks?","text":"<p>A haplotype network is a graphical representation showing the evolutionary relationships between different DNA sequences (haplotypes) in a population. Unlike phylogenetic trees, networks can show:</p> <ul> <li>Multiple evolutionary paths between sequences</li> <li>Reticulation events like recombination or homoplasy</li> <li>Ancestral sequences that may still exist in the population</li> <li>Mutation steps between related sequences</li> </ul>"},{"location":"concepts/#key-components","title":"Key Components","text":"<ul> <li>Nodes: Represent observed haplotypes (unique DNA sequences)</li> <li>Edges: Connect haplotypes differing by mutations</li> <li>Edge length: Number of mutations between haplotypes</li> <li>Node size: Often proportional to haplotype frequency</li> <li>Median vectors: Inferred ancestral or unobserved haplotypes (in some algorithms)</li> </ul>"},{"location":"concepts/#haplotypes","title":"Haplotypes","text":"<p>A haplotype is a unique DNA sequence variant in your dataset. PyPopART:</p> <ol> <li>Reads your sequence alignment</li> <li>Identifies unique sequences</li> <li>Counts how many times each appears</li> <li>Uses this information to build the network</li> </ol>"},{"location":"concepts/#important-properties","title":"Important Properties","text":"<ul> <li>Frequency: How many individuals share this haplotype</li> <li>Sequences: The actual DNA/protein sequence</li> <li>Metadata: Associated information (location, population, traits)</li> </ul>"},{"location":"concepts/#distance-metrics","title":"Distance Metrics","text":"<p>PyPopART calculates genetic distances using various evolutionary models:</p>"},{"location":"concepts/#hamming-distance","title":"Hamming Distance","text":"<p>Simple count of differing positions. Best for closely related sequences.</p>"},{"location":"concepts/#jukes-cantor","title":"Jukes-Cantor","text":"<p>Corrects for multiple mutations at the same site. Assumes equal substitution rates.</p>"},{"location":"concepts/#kimura-2-parameter-k2p","title":"Kimura 2-Parameter (K2P)","text":"<p>Distinguishes between transitions and transversions. More realistic for DNA evolution.</p>"},{"location":"concepts/#tamura-nei","title":"Tamura-Nei","text":"<p>Most sophisticated, accounts for different base frequencies and transition/transversion ratios.</p>"},{"location":"concepts/#network-algorithms","title":"Network Algorithms","text":"<p>Different algorithms make different assumptions and are suited for different data types:</p>"},{"location":"concepts/#mst-minimum-spanning-tree","title":"MST (Minimum Spanning Tree)","text":"<ul> <li>Simplest algorithm</li> <li>Always produces a tree (no reticulation)</li> <li>Connects all haplotypes with minimum total distance</li> <li>Best for: Initial exploration, small datasets</li> </ul>"},{"location":"concepts/#msn-minimum-spanning-network","title":"MSN (Minimum Spanning Network)","text":"<ul> <li>Extends MST by adding alternative connections</li> <li>Shows equally parsimonious paths</li> <li>More informative than MST</li> <li>Best for: Showing alternative evolutionary paths</li> </ul>"},{"location":"concepts/#tcs-statistical-parsimony","title":"TCS (Statistical Parsimony)","text":"<ul> <li>Based on statistical limits of parsimony</li> <li>Uses 95% confidence limit for connections</li> <li>May produce disconnected networks</li> <li>Best for: Within-species variation, recent divergence</li> </ul>"},{"location":"concepts/#mjn-median-joining-network","title":"MJN (Median-Joining Network)","text":"<ul> <li>Infers ancestral/unobserved haplotypes (median vectors)</li> <li>Most comprehensive but complex</li> <li>Can show reticulation events</li> <li>Best for: Complex evolutionary scenarios, larger datasets</li> </ul>"},{"location":"concepts/#pn-parsimony-network","title":"PN (Parsimony Network)","text":"<ul> <li>Consensus approach using multiple MSTs</li> <li>Balances between MST simplicity and MJN complexity</li> <li>Best for: General purpose analysis</li> </ul>"},{"location":"concepts/#tsw-tight-span-walker","title":"TSW (Tight Span Walker)","text":"<ul> <li>Metric-preserving network construction</li> <li>Preserves distance relationships</li> <li>Best for: When distance accuracy is critical</li> </ul>"},{"location":"concepts/#metadata-and-traits","title":"Metadata and Traits","text":"<p>PyPopART supports associating metadata with sequences:</p> <ul> <li>Populations: Geographic or demographic groups</li> <li>Sampling dates: Temporal information</li> <li>Phenotypes: Traits or characteristics</li> <li>Custom attributes: Any categorical or numerical data</li> </ul> <p>Metadata can be used for: - Coloring nodes in visualizations - Population genetics analyses - Statistical comparisons - Pattern identification</p>"},{"location":"concepts/#network-statistics","title":"Network Statistics","text":"<p>PyPopART calculates various network properties:</p>"},{"location":"concepts/#topology-metrics","title":"Topology Metrics","text":"<ul> <li>Diameter: Longest shortest path</li> <li>Clustering coefficient: Network interconnectedness</li> <li>Centrality: Important nodes in the network</li> </ul>"},{"location":"concepts/#population-genetics","title":"Population Genetics","text":"<ul> <li>Diversity indices: Nucleotide and haplotype diversity</li> <li>Tajima's D: Test for neutral evolution</li> <li>Fu's Fs: Another neutrality test</li> <li>FST: Population differentiation</li> </ul>"},{"location":"concepts/#visualization","title":"Visualization","text":"<p>Networks can be visualized in multiple ways:</p>"},{"location":"concepts/#static-plots","title":"Static Plots","text":"<ul> <li>Publication-quality figures</li> <li>PNG, PDF, SVG formats</li> <li>Customizable colors, sizes, labels</li> </ul>"},{"location":"concepts/#interactive-plots","title":"Interactive Plots","text":"<ul> <li>HTML-based exploration</li> <li>Zoom, pan, hover for details</li> <li>Export functionality</li> </ul>"},{"location":"concepts/#gui-dashboard","title":"GUI Dashboard","text":"<ul> <li>Real-time parameter adjustment</li> <li>Multiple layout algorithms</li> <li>Integrated analysis tools</li> </ul>"},{"location":"concepts/#workflow-overview","title":"Workflow Overview","text":"<p>A typical PyPopART analysis:</p> <ol> <li>Load Data: Import sequence alignment</li> <li>Calculate Distances: Choose appropriate metric</li> <li>Build Network: Select algorithm</li> <li>Analyze: Compute statistics</li> <li>Visualize: Create plots</li> <li>Export: Save results</li> </ol>"},{"location":"concepts/#next-steps","title":"Next Steps","text":"<ul> <li>Installation: Get PyPopART set up</li> <li>Quick Start: Try your first analysis</li> <li>Tutorials: Detailed walkthroughs</li> <li>User Guide: Complete documentation</li> </ul>"},{"location":"contributing/","title":"Contributing to PyPopART","text":"<p>Thank you for your interest in contributing to PyPopART! This document provides guidelines for contributing to the project.</p>"},{"location":"contributing/#ways-to-contribute","title":"Ways to Contribute","text":"<ul> <li>Report bugs and issues</li> <li>Suggest new features or enhancements</li> <li>Improve documentation</li> <li>Submit bug fixes</li> <li>Add new algorithms or features</li> <li>Write tests</li> </ul>"},{"location":"contributing/#getting-started","title":"Getting Started","text":""},{"location":"contributing/#development-setup","title":"Development Setup","text":"<ol> <li>Fork the repository on GitHub</li> <li> <p>Clone your fork locally:    <pre><code>git clone https://github.com/YOUR_USERNAME/pypopart.git\ncd pypopart\n</code></pre></p> </li> <li> <p>Create a virtual environment:    <pre><code>python -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\n</code></pre></p> </li> <li> <p>Install in development mode with all dependencies:    <pre><code>pip install -e \".[dev,test,docs]\"\n</code></pre></p> </li> <li> <p>Install pre-commit hooks:    <pre><code>pre-commit install\n</code></pre></p> </li> </ol>"},{"location":"contributing/#making-changes","title":"Making Changes","text":"<ol> <li> <p>Create a new branch for your changes:    <pre><code>git checkout -b feature/your-feature-name\n</code></pre></p> </li> <li> <p>Make your changes and write tests</p> </li> <li> <p>Run tests to ensure everything works:    <pre><code>pytest\n</code></pre></p> </li> <li> <p>Run linters and formatters:    <pre><code>black src tests\nruff check src tests\nmypy src\n</code></pre></p> </li> <li> <p>Commit your changes with clear messages:    <pre><code>git commit -m \"Add feature: your feature description\"\n</code></pre></p> </li> <li> <p>Push to your fork and submit a pull request</p> </li> </ol>"},{"location":"contributing/#code-style","title":"Code Style","text":"<ul> <li>Follow PEP 8 style guidelines</li> <li>Use Black for code formatting</li> <li>Use Ruff for linting</li> <li>Add type hints where appropriate</li> <li>Write docstrings in NumPy style</li> </ul>"},{"location":"contributing/#testing","title":"Testing","text":"<ul> <li>Write tests for all new features</li> <li>Ensure existing tests pass</li> <li>Aim for good test coverage</li> <li>Use pytest for testing</li> </ul>"},{"location":"contributing/#documentation","title":"Documentation","text":"<ul> <li>Update documentation for new features</li> <li>Add docstrings to all public functions and classes</li> <li>Include examples in docstrings</li> <li>Update the changelog</li> </ul>"},{"location":"contributing/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Ensure all tests pass</li> <li>Update documentation as needed</li> <li>Add entry to CHANGELOG.md</li> <li>Submit pull request with clear description</li> <li>Address any review feedback</li> </ol>"},{"location":"contributing/#reporting-issues","title":"Reporting Issues","text":"<p>When reporting issues, please include:</p> <ul> <li>PyPopART version</li> <li>Python version</li> <li>Operating system</li> <li>Minimal example to reproduce the issue</li> <li>Expected vs. actual behavior</li> <li>Error messages and stack traces</li> </ul>"},{"location":"contributing/#code-of-conduct","title":"Code of Conduct","text":"<ul> <li>Be respectful and inclusive</li> <li>Welcome newcomers</li> <li>Focus on constructive feedback</li> <li>Help create a positive community</li> </ul>"},{"location":"contributing/#questions","title":"Questions?","text":"<p>If you have questions, feel free to:</p> <ul> <li>Open an issue on GitHub</li> <li>Start a discussion in GitHub Discussions</li> <li>Contact the maintainers</li> </ul> <p>Thank you for contributing to PyPopART!</p>"},{"location":"faq/","title":"Frequently Asked Questions","text":""},{"location":"faq/#general","title":"General","text":""},{"location":"faq/#what-is-pypopart","title":"What is PyPopART?","text":"<p>PyPopART is a pure Python implementation of PopART (Population Analysis with Reticulate Trees), a tool for constructing and visualizing haplotype networks from DNA sequence alignments.</p>"},{"location":"faq/#how-is-pypopart-different-from-the-original-popart","title":"How is PyPopART different from the original PopART?","text":"<ul> <li>Pure Python: No Java dependency, easier to install</li> <li>CLI and API: Both command-line and programmatic access</li> <li>Modern stack: Uses current Python libraries (NetworkX, Plotly)</li> <li>Open development: Active development on GitHub</li> <li>Additional features: More analysis options and statistics</li> </ul>"},{"location":"faq/#is-pypopart-compatible-with-popart-files","title":"Is PyPopART compatible with PopART files?","text":"<p>Yes! PyPopART can read NEXUS files with traits/metadata in PopART format, and can export networks in formats compatible with PopART.</p>"},{"location":"faq/#installation","title":"Installation","text":""},{"location":"faq/#which-python-version-do-i-need","title":"Which Python version do I need?","text":"<p>Python 3.9 or higher. We recommend Python 3.11 or 3.12 for best performance.</p>"},{"location":"faq/#can-i-use-pypopart-on-windows","title":"Can I use PyPopART on Windows?","text":"<p>Yes! PyPopART works on Windows, macOS, and Linux.</p>"},{"location":"faq/#installation-fails-with-numpyscipy-errors","title":"Installation fails with NumPy/SciPy errors","text":"<p>Try installing NumPy and SciPy first:</p> <pre><code>pip install numpy scipy\npip install pypopart\n</code></pre> <p>On some systems, you may need system dependencies for NumPy/SciPy. See your OS package manager docs.</p>"},{"location":"faq/#usage","title":"Usage","text":""},{"location":"faq/#which-algorithm-should-i-use","title":"Which algorithm should I use?","text":"<ul> <li>MST: Simplest, always gives a tree</li> <li>MSN: Shows alternative connections, slightly more complex</li> <li>TCS: Statistically justified, may give disconnected networks</li> <li>MJN: Most comprehensive, infers ancestral haplotypes</li> </ul> <p>See the Algorithm Guide for detailed comparison.</p>"},{"location":"faq/#which-distance-metric-should-i-use","title":"Which distance metric should I use?","text":"<ul> <li>Hamming: Simple differences, fast, good for closely related sequences</li> <li>Jukes-Cantor: Corrects for multiple substitutions</li> <li>K2P: Accounts for transition/transversion differences</li> <li>Tamura-Nei: Most complex, accounts for GC content and rate variation</li> </ul> <p>For most cases, Hamming or K2P is sufficient.</p>"},{"location":"faq/#my-network-is-too-complex-how-can-i-simplify-it","title":"My network is too complex, how can I simplify it?","text":"<p>For MJN networks:</p> <pre><code>pypopart network sequences.fasta -a mjn -e 10 -o network.graphml\n</code></pre> <p>Increase epsilon (e.g., 5, 10, 20) to reduce complexity.</p> <p>For TCS networks, increase the parsimony limit:</p> <pre><code>pypopart network sequences.fasta -a tcs -p 0.99 -o network.graphml\n</code></pre> <p>Or use a simpler algorithm (MST or MSN).</p>"},{"location":"faq/#my-tcs-network-is-disconnected-is-this-a-bug","title":"My TCS network is disconnected, is this a bug?","text":"<p>No, this is expected behavior! TCS only connects haplotypes within the parsimony limit. Disconnected components may represent distinct lineages or insufficient data.</p>"},{"location":"faq/#how-do-i-add-populationmetadata-information","title":"How do I add population/metadata information?","text":"<p>Create a CSV file with columns including 'id' and any metadata:</p> <pre><code>id,population,location\nSeq1,PopA,Site1\nSeq2,PopA,Site1\nSeq3,PopB,Site2\n</code></pre> <p>Then:</p> <pre><code>pypopart load sequences.fasta -m metadata.csv\npypopart visualize network.graphml --color-by population -o network.png\n</code></pre>"},{"location":"faq/#can-i-visualize-networks-from-other-software","title":"Can I visualize networks from other software?","text":"<p>If the network is in GraphML, GML, or JSON format, yes! Load it:</p> <pre><code>pypopart visualize external_network.graphml -o plot.png\n</code></pre>"},{"location":"faq/#visualization","title":"Visualization","text":""},{"location":"faq/#how-do-i-make-publication-quality-figures","title":"How do I make publication-quality figures?","text":"<p>Use PDF output for vector graphics:</p> <pre><code>pypopart visualize network.graphml -o network.pdf --width 1200 --height 1200\n</code></pre> <p>For highest quality:</p> <ul> <li>Use larger dimensions (1200+ pixels)</li> <li>Use vector formats (PDF, SVG)</li> <li>Show labels only if needed</li> <li>Use spring layout for complex networks</li> </ul>"},{"location":"faq/#node-sizes-dont-reflect-my-sample-sizes","title":"Node sizes don't reflect my sample sizes","text":"<p>Node sizes are based on haplotype frequency. Make sure frequency information is preserved in your network file. When constructing from alignment, frequencies are automatically calculated.</p>"},{"location":"faq/#how-do-i-customize-colors","title":"How do I customize colors?","text":"<p>Currently, colors are assigned automatically. For custom coloring:</p> <pre><code>from pypopart.visualization import StaticVisualizer\n\nviz = StaticVisualizer(network)\ncustom_colors = {'Hap1': 'red', 'Hap2': 'blue', ...}\nviz.plot(node_colors=custom_colors, output_file='network.png')\n</code></pre>"},{"location":"faq/#can-i-export-interactive-plots","title":"Can I export interactive plots?","text":"<p>Yes! Use HTML format:</p> <pre><code>pypopart visualize network.graphml -o network.html --interactive\n</code></pre> <p>Open the HTML file in any web browser for interactive exploration.</p>"},{"location":"faq/#performance","title":"Performance","text":""},{"location":"faq/#pypopart-is-slow-with-my-large-dataset","title":"PyPopART is slow with my large dataset","text":"<p>For datasets &gt;1000 sequences:</p> <ol> <li>Use simpler algorithms (MST, MSN instead of MJN)</li> <li>Use Hamming distance instead of complex models</li> <li>For MJN, increase epsilon to reduce complexity</li> <li>Consider subsampling if haplotype diversity is low</li> </ol>"},{"location":"faq/#can-i-parallelize-the-analysis","title":"Can I parallelize the analysis?","text":"<p>Currently, PyPopART runs single-threaded for most operations. Parallel processing may be added in future releases.</p>"},{"location":"faq/#analysis","title":"Analysis","text":""},{"location":"faq/#what-statistics-should-i-report","title":"What statistics should I report?","text":"<p>Common statistics include:</p> <ul> <li>Number of haplotypes</li> <li>Haplotype diversity</li> <li>Nucleotide diversity</li> <li>Network diameter</li> <li>Number of reticulations</li> </ul> <p>Use:</p> <pre><code>pypopart analyze network.graphml --stats --topology\n</code></pre>"},{"location":"faq/#how-do-i-calculate-fst-between-populations","title":"How do I calculate FST between populations?","text":"<pre><code>from pypopart.stats import PopulationGeneticsAnalysis\nfrom pypopart.io import load_alignment\n\nalignment = load_alignment('sequences.fasta')\npopgen = PopulationGeneticsAnalysis(alignment)\n\n# Define populations\npopulations = {\n    'PopA': ['Seq1', 'Seq2'],\n    'PopB': ['Seq3', 'Seq4']\n}\n\n# Calculate FST\nfst = popgen.calculate_pairwise_fst(populations)\nprint(f\"FST = {fst:.4f}\")\n</code></pre>"},{"location":"faq/#what-does-reticulation-index-mean","title":"What does reticulation index mean?","text":"<p>Reticulation index measures network complexity:</p> <ul> <li>0 = tree (no cycles)</li> <li>Higher values = more reticulate (more cycles)</li> </ul> <p>It's calculated as: (edges - nodes + 1) / nodes</p>"},{"location":"faq/#errors","title":"Errors","text":""},{"location":"faq/#sequence-length-doesnt-match-alignment-length","title":"\"Sequence length doesn't match alignment length\"","text":"<p>All sequences in an alignment must have the same length. Check your input file for sequences of different lengths.</p>"},{"location":"faq/#sequence-id-already-exists","title":"\"Sequence ID already exists\"","text":"<p>Sequence IDs must be unique. Check for duplicate sequence names in your input file.</p>"},{"location":"faq/#distance-matrix-is-not-square","title":"\"Distance matrix is not square\"","text":"<p>This usually indicates a bug. Please report it on GitHub with your data and command.</p>"},{"location":"faq/#cannot-import-name-version","title":"\"Cannot import name 'version'\"","text":"<p>The package wasn't installed correctly. Try:</p> <pre><code>pip uninstall pypopart\npip install pypopart\n</code></pre>"},{"location":"faq/#file-formats","title":"File Formats","text":""},{"location":"faq/#what-input-formats-are-supported","title":"What input formats are supported?","text":"<ul> <li>FASTA (.fasta, .fa, .fna)</li> <li>NEXUS (.nexus, .nex)</li> <li>PHYLIP (.phy, .phylip)</li> <li>GenBank (.gb, .gbk)</li> </ul> <p>Compressed files (.gz, .zip) are automatically detected and decompressed.</p>"},{"location":"faq/#what-output-formats-are-available","title":"What output formats are available?","text":"<p>Networks:</p> <ul> <li>GraphML (.graphml) - Recommended</li> <li>GML (.gml)</li> <li>JSON (.json)</li> <li>NEXUS (.nexus, .nex)</li> </ul> <p>Visualizations:</p> <ul> <li>PNG (.png) - Raster</li> <li>PDF (.pdf) - Vector, publication-ready</li> <li>SVG (.svg) - Vector, web-friendly</li> <li>HTML (.html) - Interactive</li> </ul>"},{"location":"faq/#can-i-convert-between-formats","title":"Can I convert between formats?","text":"<p>Yes:</p> <pre><code># Load in one format, save in another\npypopart network sequences.fasta -o network.graphml\n# Convert to JSON\npython -c \"\nfrom pypopart.io import load_network, save_network\nnet = load_network('network.graphml')\nsave_network(net, 'network.json', format='json')\n\"\n</code></pre>"},{"location":"faq/#development","title":"Development","text":""},{"location":"faq/#how-can-i-contribute","title":"How can I contribute?","text":"<p>See the Contributing Guide for guidelines.</p>"},{"location":"faq/#where-should-i-report-bugs","title":"Where should I report bugs?","text":"<p>Open an issue on GitHub with:</p> <ul> <li>Python and PyPopART versions</li> <li>Command or code that caused the error</li> <li>Full error message</li> <li>Sample data if possible</li> </ul>"},{"location":"faq/#can-i-request-features","title":"Can I request features?","text":"<p>Yes! Open an issue on GitHub describing:</p> <ul> <li>The use case</li> <li>Proposed functionality</li> <li>Examples from other tools (if applicable)</li> </ul>"},{"location":"faq/#citation","title":"Citation","text":""},{"location":"faq/#how-do-i-cite-pypopart","title":"How do I cite PyPopART?","text":"<pre><code>Taranto, A. (2024). PyPopART: Pure Python implementation of haplotype network analysis.\nGitHub repository: https://github.com/adamtaranto/pypopart\n</code></pre> <p>BibTeX:</p> <pre><code>@software{pypopart,\n  author = {Taranto, Adam},\n  title = {PyPopART: Pure Python implementation of haplotype network analysis},\n  year = {2024},\n  url = {https://github.com/adamtaranto/pypopart}\n}\n</code></pre>"},{"location":"faq/#still-have-questions","title":"Still Have Questions?","text":"<ul> <li>Check the User Guide</li> <li>Read the Tutorials</li> <li>Search GitHub Issues</li> <li>Open a new issue with the \"question\" label</li> </ul>"},{"location":"gui_usage/","title":"PyPopART GUI Usage Guide","text":""},{"location":"gui_usage/#overview","title":"Overview","text":"<p>PyPopART provides a web-based graphical user interface (GUI) built with Dash for interactive haplotype network analysis. The GUI offers an intuitive workflow for:</p> <ol> <li>Uploading sequence alignments</li> <li>Computing haplotype networks</li> <li>Visualizing and analyzing results</li> <li>Exporting networks and figures</li> </ol>"},{"location":"gui_usage/#installation","title":"Installation","text":"<p>Ensure you have PyPopART installed with GUI dependencies:</p> <pre><code>pip install pypopart\n# Or install in development mode:\npip install -e .\n</code></pre> <p>The GUI requires the following additional dependencies (automatically installed):</p> <ul> <li>dash</li> <li>dash-bootstrap-components</li> </ul>"},{"location":"gui_usage/#launching-the-gui","title":"Launching the GUI","text":""},{"location":"gui_usage/#from-command-line","title":"From Command Line","text":"<p>The easiest way to start the GUI:</p> <pre><code># Start on default port 8050\npypopart-gui\n\n# Start on custom port\npypopart-gui --port 8080\n\n# Enable debug mode\npypopart-gui --debug\n</code></pre>"},{"location":"gui_usage/#from-python","title":"From Python","text":"<pre><code>from pypopart.gui.app import main\n\n# Launch with default settings (port 8050, debug=False)\nmain()\n\n# Or customize:\nmain(debug=True, port=8080)\n</code></pre> <p>The GUI will start a local web server. Open your browser to <code>http://localhost:8050</code> (or your specified port).</p>"},{"location":"gui_usage/#using-the-gui","title":"Using the GUI","text":""},{"location":"gui_usage/#1-upload-data","title":"1. Upload Data","text":""},{"location":"gui_usage/#sequence-file-required","title":"Sequence File (Required)","text":"<ul> <li>Click \"\ud83d\udcc1 Select Sequence File\"</li> <li>Supported formats:</li> <li>FASTA (.fasta, .fa)</li> <li>NEXUS (.nex, .nexus)</li> <li>PHYLIP (.phy, .phylip)</li> <li>After upload, you'll see a success message with sequence count and alignment length</li> </ul>"},{"location":"gui_usage/#metadata-file-optional","title":"Metadata File (Optional)","text":"<ul> <li>Click \"\ud83d\udcca Select Metadata File\" </li> <li>Upload a CSV file with population, location, or trait data</li> <li>Required columns: <code>id</code> (matching sequence IDs)</li> <li>Optional columns: <code>population</code>, <code>latitude</code>, <code>longitude</code>, <code>color</code>, <code>notes</code></li> <li>Population data enables:</li> <li>Colored nodes by population</li> <li>Pie charts for nodes with mixed populations</li> <li>Population-based statistics</li> </ul>"},{"location":"gui_usage/#2-configure-algorithm","title":"2. Configure Algorithm","text":"<p>Choose from six network construction algorithms:</p>"},{"location":"gui_usage/#mst-minimum-spanning-tree","title":"MST (Minimum Spanning Tree)","text":"<ul> <li>Parameters: Distance metric (Hamming, Jukes-Cantor, Kimura 2-parameter)</li> <li>Best for: Simplest tree-like relationships without reticulation</li> </ul>"},{"location":"gui_usage/#msn-minimum-spanning-network","title":"MSN (Minimum Spanning Network)","text":"<ul> <li>Parameters: Distance metric</li> <li>Best for: Showing alternative connections at equal distance</li> </ul>"},{"location":"gui_usage/#tcs-statistical-parsimony","title":"TCS (Statistical Parsimony)","text":"<ul> <li>Parameters: Connection limit (1-20 mutations)</li> <li>Best for: Recent divergence, intraspecific analysis</li> <li>Default: 10 mutations</li> </ul>"},{"location":"gui_usage/#mjn-median-joining-network","title":"MJN (Median-Joining Network)","text":"<ul> <li>Parameters: Epsilon value (0 = automatic)</li> <li>Best for: Complex reticulate relationships, infers median vectors</li> </ul>"},{"location":"gui_usage/#pn-parsimony-network","title":"PN (Parsimony Network)","text":"<ul> <li>Parameters: Number of trees to sample (10-500)</li> <li>Best for: Consensus approach capturing phylogenetic uncertainty</li> <li>Default: 100 trees</li> </ul>"},{"location":"gui_usage/#tsw-tight-span-walker","title":"TSW (Tight Span Walker)","text":"<ul> <li>Parameters: Distance metric</li> <li>Best for: Metric-preserving networks, small to medium datasets</li> <li>Note: Computationally intensive</li> </ul> <p>After selecting an algorithm and parameters, click \u26a1 Compute Network.</p>"},{"location":"gui_usage/#3-layout-options","title":"3. Layout Options","text":"<p>Choose how to arrange nodes in the network visualization:</p>"},{"location":"gui_usage/#available-layouts","title":"Available Layouts","text":"<ul> <li>Hierarchical (Fast): Tree-like hierarchical arrangement, quick computation</li> <li>Spring (Force-directed): Physics-based layout, good for general use</li> <li>Spring - Proportional Edge Length: Spring layout where edge length reflects mutation distance</li> <li>Spectral (Fast, Large networks): Eigenvalue-based layout, efficient for large networks</li> <li>Circular: Nodes arranged in a circle</li> <li>Radial: Concentric rings from center</li> <li>Kamada-Kawai (High quality, slow): Energy-minimization layout, best visual quality</li> <li>Kamada-Kawai - Proportional Edge Length: KK layout where edge length reflects mutation distance</li> </ul>"},{"location":"gui_usage/#customization-options","title":"Customization Options","text":"<ul> <li>Node Spacing: Adjust spacing between nodes (0.5x - 3.0x)</li> <li>Node Size: Adjust node size (10 - 100)</li> <li>Edge Width: Adjust edge thickness (1 - 10)</li> </ul> <p>Click \ud83c\udfa8 Apply Layout to recompute node positions with new settings.</p>"},{"location":"gui_usage/#4-viewing-results","title":"4. Viewing Results","text":"<p>The GUI provides five tabs:</p>"},{"location":"gui_usage/#network-tab","title":"Network Tab","text":"<ul> <li>Interactive visualization with Dash Cytoscape</li> <li>Node styling:</li> <li>Size: Proportional to haplotype frequency</li> <li>Color: Single population = solid color, mixed = pie chart</li> <li>Shape: Median vectors shown as gray circles</li> <li>Selection: Click to select (red border), search to highlight</li> <li>Edge styling:</li> <li>Labels: Show mutation count</li> <li>Thickness: Adjustable via slider</li> <li>Interactions:</li> <li>Zoom: Scroll wheel</li> <li>Pan: Click and drag background</li> <li>Move nodes: Drag individual nodes to reposition</li> <li>Hover: View haplotype details in tooltip</li> <li>Search: Use dropdown to find and highlight specific haplotypes</li> <li>Legend: Shows population colors and mixed population indicator</li> </ul>"},{"location":"gui_usage/#statistics-tab","title":"Statistics Tab","text":"<p>Displays comprehensive network metrics:</p> <ul> <li>Basic Metrics: Nodes, edges, diameter, clustering coefficient, reticulation index</li> <li>Diversity Metrics: Haplotype diversity, Shannon index</li> <li>Central Haplotypes: Degree, betweenness, and closeness centrality measures</li> </ul>"},{"location":"gui_usage/#haplotype-summary-tab","title":"Haplotype Summary Tab","text":"<ul> <li>Table view: H number, type (observed/inferred), frequency, sample IDs, populations</li> <li>Export options:</li> <li>Download haplotype summary as CSV</li> <li>Download H number label template</li> <li>Upload custom H number labels</li> <li>Shows which sequences belong to each haplotype</li> <li>Identifies inferred median nodes</li> </ul>"},{"location":"gui_usage/#metadata-tab","title":"Metadata Tab","text":"<ul> <li>View uploaded metadata aligned with sequence IDs</li> <li>Shows which IDs are in alignment vs. metadata</li> <li>Displays population assignments and colors</li> <li>Warns about mismatches or duplicates</li> </ul>"},{"location":"gui_usage/#alignment-tab","title":"Alignment Tab","text":"<ul> <li>View the uploaded sequence alignment</li> <li>Polymorphic sites highlighted in color (A=green, C=blue, G=orange, T=red)</li> <li>Shows first 50 sequences with ID and sequence data aligned</li> </ul>"},{"location":"gui_usage/#5-export","title":"5. Export","text":"<p>Export your results in various formats:</p> <ul> <li>GraphML: Network format, opens in Cytoscape, Gephi</li> <li>GML: Graph Markup Language</li> <li>JSON: JavaScript Object Notation, for web applications</li> <li>PNG: Raster image, good for presentations</li> <li>SVG: Vector image, scalable for publications</li> </ul> <p>Click Download to save the file.</p>"},{"location":"gui_usage/#tips-and-best-practices","title":"Tips and Best Practices","text":""},{"location":"gui_usage/#data-preparation","title":"Data Preparation","text":"<ul> <li>Ensure sequences are aligned before uploading</li> <li>All sequences should have the same length</li> <li>Include metadata in NEXUS format for population coloring</li> </ul>"},{"location":"gui_usage/#algorithm-selection","title":"Algorithm Selection","text":"<ul> <li>Start with MSN for most datasets (good balance)</li> <li>Use TCS for closely related sequences (e.g., same species)</li> <li>Use MJN for complex evolutionary scenarios</li> <li>MST is fastest but simplest</li> </ul>"},{"location":"gui_usage/#layout-optimization","title":"Layout Optimization","text":"<ul> <li>Try different layout algorithms to find the clearest visualization</li> <li>Spring layout works well for most networks</li> <li>Radial layout highlights star-like patterns</li> <li>Enable Snap to Grid for publication-ready figures</li> </ul>"},{"location":"gui_usage/#performance","title":"Performance","text":"<ul> <li>Large datasets (&gt;100 sequences) may take time to compute</li> <li>Progress indicators show when computation is running</li> <li>Network visualization is interactive even with many nodes</li> </ul>"},{"location":"gui_usage/#troubleshooting","title":"Troubleshooting","text":"<p>File Upload Fails</p> <ul> <li>Check file format and extension</li> <li>Ensure sequences are properly formatted</li> <li>Try a smaller test dataset first</li> </ul> <p>Network Computation Fails</p> <ul> <li>Check that all sequences have the same length</li> <li>Reduce connection limit for TCS if very large</li> <li>Try a different algorithm</li> </ul> <p>Visualization Issues</p> <ul> <li>Refresh the browser page</li> <li>Try a different layout algorithm</li> <li>Check browser console for errors (F12)</li> </ul> <p>Export Doesn't Work</p> <ul> <li>Ensure network has been computed</li> <li>Check browser's download settings</li> <li>Try a different export format</li> </ul>"},{"location":"gui_usage/#advanced-features","title":"Advanced Features","text":""},{"location":"gui_usage/#customization","title":"Customization","text":"<p>The GUI can be customized by modifying <code>src/pypopart/gui/app.py</code>:</p> <ul> <li>Adjust default parameters</li> <li>Change color schemes</li> <li>Add custom layout algorithms</li> <li>Modify statistics displayed</li> </ul>"},{"location":"gui_usage/#integration","title":"Integration","text":"<p>The GUI components can be used programmatically:</p> <pre><code>from pypopart.gui.app import PyPopARTApp\n\napp = PyPopARTApp(debug=True, port=8050)\n# Access app.app for the Dash application object\n# Customize before running\napp.run()\n</code></pre>"},{"location":"gui_usage/#support","title":"Support","text":"<p>For issues, questions, or feature requests:</p> <ul> <li>GitHub Issues: https://github.com/adamtaranto/pypopart/issues</li> <li>Documentation: https://github.com/adamtaranto/pypopart</li> </ul>"},{"location":"gui_usage/#citation","title":"Citation","text":"<p>If you use PyPopART in your research, please cite:</p> <p>[Citation information to be added]</p>"},{"location":"h_number_labeling/","title":"Custom H Number Labeling","text":""},{"location":"h_number_labeling/#overview","title":"Overview","text":"<p>The PyPopART Dash app allows users to customize the labels assigned to haplotype groups in network visualizations. By default, haplotypes are labeled sequentially as H1, H2, H3, etc. This feature enables you to replace these default labels with meaningful names for publication or analysis.</p>"},{"location":"h_number_labeling/#use-cases","title":"Use Cases","text":"<ul> <li>Publication-ready figures: Replace H1, H2, H3 with descriptive names like \"Central\", \"Branch_A\", \"Rare_variant\"</li> <li>Geographic populations: Label haplotypes by their predominant location (e.g., \"Pacific\", \"Atlantic\", \"Mediterranean\")</li> <li>Functional groups: Assign labels based on phenotype or functional characteristics</li> <li>Standardization: Use consistent labeling across multiple analyses</li> </ul>"},{"location":"h_number_labeling/#workflow","title":"Workflow","text":""},{"location":"h_number_labeling/#step-1-generate-the-network","title":"Step 1: Generate the Network","text":"<ol> <li>Upload your sequence alignment (FASTA, NEXUS, or PHYLIP format)</li> <li>Optionally upload metadata (population, location data)</li> <li>Select a network algorithm (MST, MSN, TCS, or MJN)</li> <li>Click \"Compute Network\"</li> </ol> <p>The network will be displayed with default labels (H1, H2, H3, etc.)</p>"},{"location":"h_number_labeling/#step-2-download-label-template","title":"Step 2: Download Label Template","text":"<ol> <li>Navigate to the Haplotype Summary tab</li> <li>Click the \"\u2b07\ufe0f Download Label Template\" button</li> <li>Save the CSV file (default name: <code>h_number_mapping_template.csv</code>)</li> </ol> <p>The template CSV contains two columns: - <code>current_h_number</code>: The current H number (H1, H2, H3, etc.) - <code>new_label</code>: Initially set to the same as current_h_number (for you to edit)</p>"},{"location":"h_number_labeling/#step-3-edit-labels","title":"Step 3: Edit Labels","text":"<p>Open the downloaded CSV in any spreadsheet application or text editor:</p> <pre><code>current_h_number,new_label\nH1,H1\nH2,H2\nH3,H3\nH4,H4\n</code></pre> <p>Edit the <code>new_label</code> column with your desired labels:</p> <pre><code>current_h_number,new_label\nH1,Central\nH2,Branch_A\nH3,Branch_B\nH4,Rare_variant\n</code></pre> <p>Important Guidelines: - Keep the <code>current_h_number</code> column unchanged - Do not use duplicate values in the <code>new_label</code> column - Avoid special characters that might cause issues in visualization - Keep labels concise for better readability in plots - Do not leave <code>new_label</code> cells empty</p>"},{"location":"h_number_labeling/#step-4-upload-custom-mapping","title":"Step 4: Upload Custom Mapping","text":"<ol> <li>Return to the Haplotype Summary tab in the app</li> <li>Click the \"\u2b06\ufe0f Upload Label Mapping\" button</li> <li>Select your edited CSV file</li> <li>The system will validate your mapping</li> </ol> <p>If successful: - A green success message appears - The network graph updates with your custom labels - The haplotype summary table shows your custom labels - Search dropdown reflects your custom labels - Tooltips display your custom labels</p> <p>If errors are detected: - A red error message appears with specific issues - Fix the errors in your CSV and try uploading again</p>"},{"location":"h_number_labeling/#validation-rules","title":"Validation Rules","text":"<p>The system performs the following validations:</p>"},{"location":"h_number_labeling/#1-column-format","title":"1. Column Format","text":"<ul> <li>CSV must have exactly two columns: <code>current_h_number</code> and <code>new_label</code></li> <li>Column headers must match exactly (case-sensitive)</li> </ul>"},{"location":"h_number_labeling/#2-unknown-h-numbers","title":"2. Unknown H Numbers","text":"<ul> <li>All <code>current_h_number</code> values must exist in the current network</li> <li>Error example: \"Row 5: Unknown H number 'H99'\"</li> </ul>"},{"location":"h_number_labeling/#3-duplicate-labels","title":"3. Duplicate Labels","text":"<ul> <li>Each <code>new_label</code> must be unique</li> <li>Error example: \"Duplicate label 'Central' for node1 and node2\"</li> </ul>"},{"location":"h_number_labeling/#4-missing-values","title":"4. Missing Values","text":"<ul> <li>Both columns must have values for each row</li> <li>Error example: \"Row 3: Missing new_label for H2\"</li> </ul>"},{"location":"h_number_labeling/#5-whitespace","title":"5. Whitespace","text":"<ul> <li>Leading and trailing whitespace is automatically trimmed</li> <li>Labels like <code>\" Central \"</code> become <code>\"Central\"</code></li> </ul>"},{"location":"h_number_labeling/#example-validation-errors","title":"Example Validation Errors","text":"<pre><code>\u274c Validation Errors:\n\u2022 Row 3: Missing new_label for H2\n\u2022 Row 5: Unknown H number \"H99\"\n\u2022 Duplicate label \"Central\" for H1 and H3\n(3 total errors)\n</code></pre>"},{"location":"h_number_labeling/#tips","title":"Tips","text":"<ol> <li>Start with the template: Always download the current template before editing to ensure you have the correct H numbers</li> <li>Backup your CSV: Keep a copy of your custom mapping for reuse</li> <li>Test with small changes: Try uploading with just a few label changes first</li> <li>Use consistent naming: Establish a naming convention for your labels</li> <li>Avoid unicode: Stick to ASCII characters for maximum compatibility</li> </ol>"},{"location":"h_number_labeling/#persistence","title":"Persistence","text":"<ul> <li>Custom labels persist across layout changes (e.g., switching from hierarchical to spring)</li> <li>Custom labels are not saved with the network export (they're display-only)</li> <li>To reset to default labels, compute a new network or reload the page</li> <li>To update labels, download a fresh template and upload a new mapping</li> </ul>"},{"location":"h_number_labeling/#integration-with-other-features","title":"Integration with Other Features","text":"<ul> <li>Search: Custom labels appear in the search dropdown</li> <li>Tooltips: Hovering over nodes shows custom labels</li> <li>Summary Export: Downloaded CSV includes custom labels</li> <li>Network Export: Exported GraphML/JSON uses original node IDs (not custom labels)</li> </ul>"},{"location":"h_number_labeling/#troubleshooting","title":"Troubleshooting","text":"<p>Problem: Upload button doesn't respond - Solution: Ensure you've computed a network first</p> <p>Problem: Template download is empty - Solution: Compute a network before downloading the template</p> <p>Problem: Custom labels don't appear after upload - Solution: Check the feedback message for validation errors</p> <p>Problem: Labels are too long and overlap in the plot - Solution: Use shorter labels or increase network spacing</p> <p>Problem: Need to start over - Solution: Refresh the page or compute a new network to reset labels</p>"},{"location":"h_number_labeling/#api-reference","title":"API Reference","text":"<p>For programmatic access, see the callback documentation in <code>src/pypopart/gui/app.py</code>: - <code>download_h_number_template()</code>: Generates template CSV - <code>upload_h_number_mapping()</code>: Processes uploaded mapping</p>"},{"location":"h_number_labeling/#example-mappings","title":"Example Mappings","text":""},{"location":"h_number_labeling/#geographic-labeling","title":"Geographic Labeling","text":"<pre><code>current_h_number,new_label\nH1,Pacific_Core\nH2,Atlantic_North\nH3,Atlantic_South\nH4,Mediterranean\n</code></pre>"},{"location":"h_number_labeling/#functional-labeling","title":"Functional Labeling","text":"<pre><code>current_h_number,new_label\nH1,Wildtype\nH2,Resistant\nH3,Tolerant\nH4,Susceptible\n</code></pre>"},{"location":"h_number_labeling/#alphanumeric-labeling","title":"Alphanumeric Labeling","text":"<pre><code>current_h_number,new_label\nH1,A\nH2,B\nH3,C\nH4,D\n</code></pre>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#requirements","title":"Requirements","text":"<p>PyPopART requires:</p> <ul> <li>Python 3.9 or higher</li> <li>Operating system: Linux, macOS, or Windows</li> </ul>"},{"location":"installation/#installation-methods","title":"Installation Methods","text":""},{"location":"installation/#from-pypi-recommended","title":"From PyPI (Recommended)","text":"<p>Once released, install PyPopART using pip:</p> <pre><code>pip install pypopart\n</code></pre>"},{"location":"installation/#from-source","title":"From Source","text":"<p>For the latest development version:</p> <pre><code># Clone the repository\ngit clone https://github.com/adamtaranto/pypopart.git\ncd pypopart\n\n# Install in development mode\npip install -e \".[dev]\"\n</code></pre>"},{"location":"installation/#using-condamamba","title":"Using conda/mamba","text":"<p>Create a conda environment (optional but recommended):</p> <pre><code># Create environment\nconda create -n pypopart python=3.11\nconda activate pypopart\n\n# Install pypopart\npip install pypopart\n</code></pre>"},{"location":"installation/#dependencies","title":"Dependencies","text":"<p>PyPopART automatically installs the following dependencies:</p>"},{"location":"installation/#core-dependencies","title":"Core Dependencies","text":"<ul> <li>biopython: Sequence I/O and manipulation</li> <li>click: Command-line interface</li> <li>matplotlib: Static visualization</li> <li>networkx: Graph data structures and algorithms</li> <li>numba: JIT compilation for performance</li> <li>numpy: Numerical operations</li> <li>pandas: Data manipulation</li> <li>plotly: Interactive visualization</li> <li>scipy: Scientific computing</li> <li>scikit-learn: Machine learning utilities</li> </ul>"},{"location":"installation/#development-dependencies-optional","title":"Development Dependencies (optional)","text":"<p>For development, install additional tools:</p> <pre><code>pip install pypopart[dev]\n</code></pre> <p>This includes:</p> <ul> <li>pytest: Testing framework</li> <li>pytest-cov: Coverage reporting</li> <li>ruff: Fast linting and formatting</li> <li>mypy: Static type checking</li> <li>pre-commit: Git hooks for code quality</li> </ul>"},{"location":"installation/#verify-installation","title":"Verify Installation","text":"<p>Check that PyPopART is installed correctly:</p> <pre><code># Check version\npypopart --version\n\n# Show help\npypopart --help\n\n# List available commands\npypopart info --list-algorithms\n</code></pre> <p>Expected output:</p> <pre><code>Available Network Construction Algorithms:\n  mst - Minimum Spanning Tree\n  msn - Minimum Spanning Network\n  tcs - Statistical Parsimony (TCS)\n  mjn - Median-Joining Network\n</code></pre>"},{"location":"installation/#testing-your-installation","title":"Testing Your Installation","text":"<p>Run a quick test with sample data:</p> <pre><code># Create a simple FASTA file\ncat &gt; test.fasta &lt;&lt; 'EOF'\n&gt;Seq1\nATCGATCG\n&gt;Seq2\nATCGATCG\n&gt;Seq3\nATCGATTG\nEOF\n\n# Construct a network\npypopart network test.fasta -o test.graphml\n\n# Visualize it\npypopart visualize test.graphml -o test.png\n</code></pre> <p>If these commands succeed, PyPopART is working correctly!</p>"},{"location":"installation/#python-version-compatibility","title":"Python Version Compatibility","text":"<p>PyPopART is tested on:</p> <ul> <li>Python 3.9</li> <li>Python 3.10</li> <li>Python 3.11</li> <li>Python 3.12</li> </ul>"},{"location":"installation/#platform-support","title":"Platform Support","text":"<p>PyPopART works on:</p> <ul> <li>Linux: Fully supported</li> <li>macOS: Fully supported (both Intel and Apple Silicon)</li> <li>Windows: Fully supported (Windows 10+)</li> </ul>"},{"location":"installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"installation/#importerror-no-module-named-pypopart","title":"ImportError: No module named 'pypopart'","text":"<p>The package is not installed. Try:</p> <pre><code>pip install pypopart\n</code></pre>"},{"location":"installation/#command-not-found-pypopart","title":"Command not found: pypopart","text":"<p>The pip install directory is not in your PATH. Try:</p> <pre><code>python -m pypopart --help\n</code></pre> <p>Or add pip's binary directory to your PATH.</p>"},{"location":"installation/#numpyscipy-installation-issues","title":"NumPy/SciPy Installation Issues","text":"<p>On some systems, you may need to install NumPy and SciPy separately first:</p> <pre><code>pip install numpy scipy\npip install pypopart\n</code></pre>"},{"location":"installation/#numba-compilation-warnings","title":"Numba Compilation Warnings","text":"<p>Numba may show warnings on first import. These are normal and can be ignored. The code will work correctly even without JIT compilation.</p>"},{"location":"installation/#visualization-issues-on-headless-servers","title":"Visualization Issues on Headless Servers","text":"<p>If running on a server without a display:</p> <pre><code># Set matplotlib backend\nexport MPLBACKEND=Agg\npypopart visualize network.graphml -o network.png\n</code></pre> <p>Or use interactive HTML output which doesn't require a display:</p> <pre><code>pypopart visualize network.graphml -o network.html --interactive\n</code></pre>"},{"location":"installation/#updating-pypopart","title":"Updating PyPopART","text":"<p>To update to the latest version:</p> <pre><code>pip install --upgrade pypopart\n</code></pre>"},{"location":"installation/#uninstalling","title":"Uninstalling","text":"<p>To remove PyPopART:</p> <pre><code>pip uninstall pypopart\n</code></pre>"},{"location":"installation/#getting-help","title":"Getting Help","text":"<p>If you encounter issues:</p> <ol> <li>Check the FAQ</li> <li>Search GitHub Issues</li> <li>Open a new issue with:</li> <li>Your Python version (<code>python --version</code>)</li> <li>Your OS and version</li> <li>Complete error message</li> <li>Steps to reproduce the problem</li> </ol>"},{"location":"installation/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start: Create your first haplotype network</li> <li>CLI Guide: Learn the command-line interface</li> <li>Tutorials: Step-by-step examples</li> </ul>"},{"location":"layout_algorithms/","title":"Network Layout Algorithms","text":"<p>This guide helps you choose the best layout algorithm for your haplotype network visualization in PyPopART.</p>"},{"location":"layout_algorithms/#quick-selection-guide","title":"Quick Selection Guide","text":""},{"location":"layout_algorithms/#by-network-size","title":"By Network Size","text":"Network Size Recommended Algorithm Alternative Small (&lt;50 nodes) Kamada-Kawai Force-Directed Medium (50-500 nodes) Force-Directed Spectral Large (&gt;500 nodes) Spectral Hierarchical"},{"location":"layout_algorithms/#by-purpose","title":"By Purpose","text":"Purpose Algorithm Notes General visualization Force-Directed Good balance of speed and quality Fast preview Hierarchical Instant layout, tree structure Large datasets Spectral Maintains structure, very fast Highest quality Kamada-Kawai Slow but optimal for small networks Highlight central node Radial Places important node at center Simple connectivity Circular Shows connection patterns clearly Proportional distances Spring/KK Proportional Edge length reflects mutation count"},{"location":"layout_algorithms/#algorithm-details","title":"Algorithm Details","text":""},{"location":"layout_algorithms/#1-hierarchical-layout","title":"1. Hierarchical Layout","text":"<p>Best for: Fast previews, tree-like structures</p> <p>Speed: \u26a1\u26a1\u26a1\u26a1\u26a1 Fastest (0.14ms for 100 nodes)</p> <p>Quality: \u2b50\u2b50\u2b50 Good for hierarchical data</p> <p>Description: Arranges nodes in levels based on distance from a root node. Creates a tree-like structure that's easy to interpret.</p> <p>Advantages: - Extremely fast, works well for very large networks - Clear hierarchical relationships - Handles disconnected components</p> <p>Disadvantages: - May not show cyclical relationships well - Layout depends on choice of root node</p> <p>Parameters: <pre><code>layout = manager.compute_layout(\n    'hierarchical',\n    root_node='H1',      # Optional: specify root\n    vertical=True,       # True = top-down, False = left-right\n    width=2.0,          # Layout width\n    height=2.0          # Layout height\n)\n</code></pre></p>"},{"location":"layout_algorithms/#2-spectral-layout","title":"2. Spectral Layout","text":"<p>Best for: Large networks (100-1000+ nodes)</p> <p>Speed: \u26a1\u26a1\u26a1\u26a1 Very fast (6.5ms for 100 nodes)</p> <p>Quality: \u2b50\u2b50\u2b50\u2b50 Excellent structure preservation</p> <p>Description: Uses eigenvectors of the graph Laplacian to position nodes. Excellent balance of speed and quality for large networks.</p> <p>Advantages: - Much faster than force-directed or Kamada-Kawai - Reveals clustering and community structure - Good for networks with clear groups</p> <p>Disadvantages: - May produce less aesthetic layouts than force-directed - Requires connected graph (handles disconnected with fallback)</p> <p>Parameters: <pre><code>layout = manager.compute_layout(\n    'spectral',\n    scale=1.0,          # Scale factor\n    center=(0.0, 0.0)   # Center position\n)\n</code></pre></p>"},{"location":"layout_algorithms/#3-force-directed-spring-layout","title":"3. Force-Directed (Spring) Layout","text":"<p>Best for: General purpose, medium networks</p> <p>Speed: \u26a1\u26a1\u26a1 Moderate (26ms for 100 nodes)</p> <p>Quality: \u2b50\u2b50\u2b50\u2b50 Very good aesthetic quality</p> <p>Description: Simulates physical springs between connected nodes. The default choice for most visualizations.</p> <p>Advantages: - Aesthetically pleasing layouts - Works well for most network types - Tunable with iterations parameter</p> <p>Disadvantages: - Slower than spectral or hierarchical - Can be slow for large networks (&gt;500 nodes) - Non-deterministic without seed</p> <p>Parameters: <pre><code>layout = manager.compute_layout(\n    'spring',\n    k=None,             # Optimal distance (None = auto)\n    iterations=50,      # More = better quality but slower\n    seed=42            # For reproducibility\n)\n</code></pre></p> <p>Tuning Tips: - Increase <code>iterations</code> for better quality (try 100-200) - Decrease <code>k</code> to bring nodes closer together - Use <code>seed</code> for consistent layouts across runs</p>"},{"location":"layout_algorithms/#4-kamada-kawai-layout","title":"4. Kamada-Kawai Layout","text":"<p>Best for: Small networks requiring highest quality</p> <p>Speed: \u26a1 Slow (187ms for 100 nodes)</p> <p>Quality: \u2b50\u2b50\u2b50\u2b50\u2b50 Optimal quality</p> <p>Description: Minimizes stress based on graph-theoretic distances. Produces optimal layouts but is computationally expensive.</p> <p>Advantages: - Highest quality layouts - Respects graph distances precisely - Deterministic results</p> <p>Disadvantages: - Very slow for networks &gt;100 nodes - O(N\u00b3) time complexity - Not suitable for interactive use with large networks</p> <p>Parameters: <pre><code>layout = manager.compute_layout(\n    'kamada_kawai',\n    scale=1.0,          # Scale factor\n    center=(0.0, 0.0)   # Center position\n)\n</code></pre></p> <p>Warning: Only use for small networks (&lt;50 nodes) or when layout quality is absolutely critical.</p>"},{"location":"layout_algorithms/#5-circular-layout","title":"5. Circular Layout","text":"<p>Best for: Showing connectivity patterns</p> <p>Speed: \u26a1\u26a1\u26a1\u26a1\u26a1 Very fast (0.16ms for 100 nodes)</p> <p>Quality: \u2b50\u2b50 Simple but effective</p> <p>Description: Arranges nodes evenly spaced around a circle.</p> <p>Advantages: - Extremely fast - Good for comparing edge densities - Works well with node coloring</p> <p>Disadvantages: - Doesn't reflect graph structure - Can be cluttered for dense networks</p> <p>Parameters: <pre><code>layout = manager.compute_layout(\n    'circular',\n    scale=1.0,          # Radius of circle\n    center=(0.0, 0.0)   # Center position\n)\n</code></pre></p>"},{"location":"layout_algorithms/#6-radial-layout","title":"6. Radial Layout","text":"<p>Best for: Networks with clear central node</p> <p>Speed: \u26a1\u26a1\u26a1\u26a1 Fast (0.26ms for 100 nodes)</p> <p>Quality: \u2b50\u2b50\u2b50 Good for star-like networks</p> <p>Description: Places a central node at origin, others in concentric rings based on distance.</p> <p>Advantages: - Fast and intuitive - Highlights central hub - Shows distance from center clearly</p> <p>Disadvantages: - Works best for star-like topologies - May be cluttered if many nodes at same distance</p> <p>Parameters: <pre><code>layout = manager.compute_layout(\n    'radial',\n    center_node='H1',   # Node to place at center\n    scale=1.0           # Scale factor\n)\n</code></pre></p>"},{"location":"layout_algorithms/#7-proportional-edge-length-layouts","title":"7. Proportional Edge Length Layouts","text":"<p>Best for: Showing mutation distances accurately</p> <p>Speed: \u26a1\u26a1\u26a1 Moderate (similar to base algorithms)</p> <p>Quality: \u2b50\u2b50\u2b50\u2b50 Accurate distance representation</p> <p>Description: Variations of spring and Kamada-Kawai layouts where edge lengths are proportional to the number of mutations between haplotypes.</p> <p>Advantages: - Visually represents genetic distance - Helps identify distant vs. close relationships - Useful for understanding evolutionary distances</p> <p>Disadvantages: - Can produce larger, more spread-out layouts - May reduce aesthetic appeal for highly variable data</p> <p>Available Variations:</p>"},{"location":"layout_algorithms/#spring-proportional","title":"Spring Proportional","text":"<pre><code>layout = manager.compute_layout(\n    'spring_proportional',\n    iterations=100,\n    seed=42\n)\n</code></pre>"},{"location":"layout_algorithms/#kamada-kawai-proportional","title":"Kamada-Kawai Proportional","text":"<pre><code>layout = manager.compute_layout(\n    'kamada_kawai_proportional',\n    scale=1.0\n)\n</code></pre>"},{"location":"layout_algorithms/#performance-benchmarks","title":"Performance Benchmarks","text":"<p>All benchmarks run on standard hardware with Python 3.12, NetworkX 3.5.</p>"},{"location":"layout_algorithms/#runtime-comparison-100-nodes","title":"Runtime Comparison (100 nodes)","text":"<pre><code>Hierarchical:     0.14 ms  \u26a1\u26a1\u26a1\u26a1\u26a1\nCircular:         0.16 ms  \u26a1\u26a1\u26a1\u26a1\u26a1\nRadial:           0.26 ms  \u26a1\u26a1\u26a1\u26a1\u26a1\nSpectral:         6.50 ms  \u26a1\u26a1\u26a1\u26a1\nForce-Directed:  26.00 ms  \u26a1\u26a1\u26a1\nKamada-Kawai:   187.00 ms  \u26a1\n</code></pre>"},{"location":"layout_algorithms/#scalability-200-nodes","title":"Scalability (200 nodes)","text":"<pre><code>Hierarchical:      0.28 ms\nSpectral:         23.88 ms\nForce-Directed:   87.00 ms\nKamada-Kawai:   1202.00 ms  \u26a0\ufe0f Not recommended\n</code></pre>"},{"location":"layout_algorithms/#best-practices","title":"Best Practices","text":""},{"location":"layout_algorithms/#1-start-fast-refine-later","title":"1. Start Fast, Refine Later","text":"<p>For exploratory analysis: 1. Use Hierarchical for quick preview 2. Switch to Force-Directed for publication 3. Try Spectral if force-directed is too slow</p>"},{"location":"layout_algorithms/#2-consider-network-properties","title":"2. Consider Network Properties","text":"<ul> <li>Clustered networks: Use Spectral</li> <li>Hierarchical networks: Use Hierarchical</li> <li>Star topologies: Use Radial</li> <li>Dense networks: Use Circular or Spectral</li> </ul>"},{"location":"layout_algorithms/#3-optimization-tips","title":"3. Optimization Tips","text":"<p>For large networks: - Reduce force-directed iterations: <code>iterations=30</code> - Use spectral instead of force-directed - Consider hierarchical for fastest results</p> <p>For highest quality: - Increase iterations: <code>iterations=100-200</code> - Use Kamada-Kawai for small networks - Set consistent seed for reproducibility</p>"},{"location":"layout_algorithms/#4-interactive-workflows","title":"4. Interactive Workflows","text":"<pre><code># Quick preview\nlayout = manager.compute_layout('hierarchical')\n\n# If network is small (&lt;100 nodes), upgrade to force-directed\nif len(network.nodes) &lt; 100:\n    layout = manager.compute_layout('spring', iterations=100, seed=42)\n\n# For large networks, use spectral\nif len(network.nodes) &gt; 500:\n    layout = manager.compute_layout('spectral')\n</code></pre>"},{"location":"layout_algorithms/#common-issues-and-solutions","title":"Common Issues and Solutions","text":""},{"location":"layout_algorithms/#layout-looks-cluttered","title":"Layout looks cluttered","text":"<p>Problem: Nodes overlap or edges cross excessively</p> <p>Solutions: - Increase iterations for force-directed: <code>iterations=100</code> - Try spectral layout for better spacing - Use radial or circular for clearer structure</p>"},{"location":"layout_algorithms/#layout-is-too-slow","title":"Layout is too slow","text":"<p>Problem: Layout computation takes too long</p> <p>Solutions: - Switch to spectral or hierarchical - Reduce iterations: <code>iterations=30</code> - Use hierarchical for instant preview</p>"},{"location":"layout_algorithms/#disconnected-components-overlap","title":"Disconnected components overlap","text":"<p>Problem: Separate network components are positioned on top of each other</p> <p>Solutions: - Use force-directed or spectral (handle components automatically) - Manually adjust with ManualLayout after initial computation</p>"},{"location":"layout_algorithms/#layout-changes-every-time","title":"Layout changes every time","text":"<p>Problem: Non-deterministic layouts make comparison difficult</p> <p>Solutions: - Set seed for force-directed: <code>seed=42</code> - Use deterministic algorithms: Hierarchical, Kamada-Kawai, Circular, Radial</p>"},{"location":"layout_algorithms/#advanced-usage","title":"Advanced Usage","text":""},{"location":"layout_algorithms/#combining-layouts","title":"Combining Layouts","text":"<p>You can start with one algorithm and refine with another:</p> <pre><code># Start with fast hierarchical\ninitial = manager.compute_layout('hierarchical')\n\n# Refine with force-directed (fewer iterations)\nrefined = manager.compute_layout('spring', iterations=30, pos=initial)\n</code></pre>"},{"location":"layout_algorithms/#manual-adjustments","title":"Manual Adjustments","text":"<p>After automatic layout, use ManualLayout for fine-tuning:</p> <pre><code># Compute initial layout\npositions = manager.compute_layout('spring')\n\n# Create manual layout for adjustments\nmanual = ManualLayout(network, initial_positions=positions)\n\n# Move a specific node\nmanual.set_position('H5', (1.0, 2.0))\n\n# Get final positions\nfinal = manual.compute()\n</code></pre>"},{"location":"layout_algorithms/#saving-and-loading-layouts","title":"Saving and Loading Layouts","text":"<p>Save time by reusing layouts:</p> <pre><code># Compute and save\nlayout = manager.compute_layout('spring', iterations=200, seed=42)\nmanager.save_layout(layout, 'my_network_layout.json')\n\n# Load later\nlayout = manager.load_layout('my_network_layout.json')\n</code></pre>"},{"location":"layout_algorithms/#references","title":"References","text":"<ul> <li>NetworkX Layouts: https://networkx.org/documentation/stable/reference/drawing.html</li> <li>Fruchterman-Reingold: \"Graph Drawing by Force-directed Placement\" (1991)</li> <li>Kamada-Kawai: \"An Algorithm for Drawing General Undirected Graphs\" (1989)</li> <li>Spectral Layout: Uses Laplacian eigendecomposition (Koren 2005)</li> </ul>"},{"location":"layout_algorithms/#getting-help","title":"Getting Help","text":"<p>If you're unsure which layout to use:</p> <ol> <li>Try Hierarchical first - it's instant and often good enough</li> <li>If that doesn't work well, try Force-Directed with default settings</li> <li>For large networks (&gt;500 nodes), use Spectral</li> <li>To show mutation distances accurately, try Spring Proportional or Kamada-Kawai Proportional</li> </ol> <p>For questions or issues, please see the main PyPopART documentation or open an issue on GitHub.</p>"},{"location":"license/","title":"License","text":"<p>PyPopART is released under the GNU General Public License v3.0.</p>"},{"location":"license/#full-license-text","title":"Full License Text","text":"<pre><code>GNU GENERAL PUBLIC LICENSE\nVersion 3, 29 June 2007\n\nCopyright (C) 2007 Free Software Foundation, Inc. &lt;https://fsf.org/&gt;\nEveryone is permitted to copy and distribute verbatim copies\nof this license document, but changing it is not allowed.\n</code></pre> <p>For the complete license text, see the LICENSE file in the repository.</p>"},{"location":"license/#summary","title":"Summary","text":"<p>PyPopART is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.</p> <p>PyPopART is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</p>"},{"location":"license/#citation","title":"Citation","text":"<p>If you use PyPopART in your research, please cite:</p> <pre><code>@software{pypopart,\n  author = {Taranto, Adam},\n  title = {PyPopART: Python Population Analysis with Reticulate Trees},\n  url = {https://github.com/Adamtaranto/pypopart},\n  year = {2024}\n}\n</code></pre>"},{"location":"quickstart/","title":"Quick Start Guide","text":"<p>Get started with PyPopART in minutes! This guide walks you through creating your first haplotype network.</p>"},{"location":"quickstart/#prerequisites","title":"Prerequisites","text":"<ul> <li>PyPopART installed (see Installation)</li> <li>A sequence alignment file (FASTA, NEXUS, PHYLIP, or GenBank format)</li> </ul>"},{"location":"quickstart/#choosing-your-interface","title":"Choosing Your Interface","text":"<p>PyPopART offers two ways to work with haplotype networks:</p>"},{"location":"quickstart/#option-1-web-based-gui-recommended-for-beginners","title":"Option 1: Web-based GUI (Recommended for Beginners)","text":"<p>Launch the interactive interface:</p> <pre><code>pypopart-gui\n</code></pre> <p>Open your browser to <code>http://localhost:8050</code> and follow the visual workflow: 1. Upload sequence file 2. Configure algorithm 3. Compute network 4. Customize layout 5. Export results</p> <p>Advantages: Visual, interactive, no command-line knowledge needed.</p>"},{"location":"quickstart/#option-2-command-line-interface","title":"Option 2: Command-Line Interface","text":"<p>For automation and scripting, use the CLI as shown below.</p>"},{"location":"quickstart/#your-first-network-in-3-steps-cli","title":"Your First Network in 3 Steps (CLI)","text":""},{"location":"quickstart/#step-1-prepare-your-data","title":"Step 1: Prepare Your Data","text":"<p>Create or use an existing sequence alignment. For this example, we'll create a simple FASTA file:</p> <pre><code>cat &gt; mysequences.fasta &lt;&lt; 'EOF'\n&gt;Sample1_PopA\nATCGATCGATCGATCGATCG\n&gt;Sample2_PopA\nATCGATCGATCGATCGATCG\n&gt;Sample3_PopB\nATCGATCGATCGATTGATCG\n&gt;Sample4_PopB\nATCGATCGATCGATTGATCG\n&gt;Sample5_PopC\nATCGATCGAGCGATCGATCG\nEOF\n</code></pre>"},{"location":"quickstart/#step-2-construct-the-network","title":"Step 2: Construct the Network","text":"<p>Use the <code>network</code> command to build a haplotype network:</p> <pre><code>pypopart network mysequences.fasta -o mynetwork.graphml\n</code></pre> <p>Output:</p> <pre><code>Loading sequences from mysequences.fasta...\n\u2713 Loaded 5 sequences (20 bp)\nCalculating hamming distances...\n\u2713 Distance matrix computed\nIdentifying unique haplotypes...\n\u2713 Found 3 unique haplotypes\nBuilding MJN network...\n\u2713 Network constructed\n\nNetwork Statistics:\n  Nodes: 3\n  Edges: 2\n  Median vectors: 0\n\n\u2713 Network saved as GRAPHML\n</code></pre>"},{"location":"quickstart/#step-3-visualize-the-network","title":"Step 3: Visualize the Network","text":"<p>Create a visualization:</p> <pre><code>pypopart visualize mynetwork.graphml -o mynetwork.png\n</code></pre> <p>Or create an interactive HTML visualization:</p> <pre><code>pypopart visualize mynetwork.graphml -o mynetwork.html --interactive\n</code></pre> <p>That's it! You've created your first haplotype network.</p>"},{"location":"quickstart/#exploring-further","title":"Exploring Further","text":""},{"location":"quickstart/#try-different-algorithms","title":"Try Different Algorithms","text":"<p>PyPopART offers six network construction algorithms:</p> <pre><code># Minimum Spanning Tree (simplest tree)\npypopart network mysequences.fasta -a mst -o network_mst.graphml\n\n# Minimum Spanning Network (shows alternatives)\npypopart network mysequences.fasta -a msn -o network_msn.graphml\n\n# Statistical Parsimony (TCS)\npypopart network mysequences.fasta -a tcs -o network_tcs.graphml\n\n# Median-Joining (default, infers ancestors)\npypopart network mysequences.fasta -a mjn -o network_mjn.graphml\n\n# Parsimony Network (consensus from multiple trees)\npypopart network mysequences.fasta -a pn -o network_pn.graphml\n\n# Tight Span Walker (metric-preserving, for small datasets)\npypopart network mysequences.fasta -a tsw -o network_tsw.graphml\n</code></pre> <p>Algorithm Comparison: - MST: Fastest, simplest tree - MSN: Adds alternative equal-distance connections - TCS: Best for closely related sequences - MJN: Infers ancestral sequences, handles reticulation - PN: Consensus approach, captures uncertainty - TSW: Most accurate metric preservation (slower)</p>"},{"location":"quickstart/#use-different-distance-metrics","title":"Use Different Distance Metrics","text":"<pre><code># Hamming distance (default, fastest)\npypopart network mysequences.fasta -d hamming -o network.graphml\n\n# Jukes-Cantor correction\npypopart network mysequences.fasta -d jc -o network.graphml\n\n# Kimura 2-parameter\npypopart network mysequences.fasta -d k2p -o network.graphml\n\n# Tamura-Nei (most complex)\npypopart network mysequences.fasta -d tamura_nei -o network.graphml\n</code></pre>"},{"location":"quickstart/#analyze-your-network","title":"Analyze Your Network","text":"<p>Get comprehensive statistics:</p> <pre><code>pypopart analyze mynetwork.graphml --stats\n</code></pre> <p>Output:</p> <pre><code>Loading network from mynetwork.graphml...\n\u2713 Loaded network with 3 nodes\n\n=== Network Statistics ===\nnodes: 3\nedges: 2\ndiameter: 2\navg_degree: 1.333\nclustering_coefficient: 0.0000\nreticulation_index: 0.0000\n</code></pre>"},{"location":"quickstart/#customize-visualizations","title":"Customize Visualizations","text":"<pre><code># Different layout algorithms\npypopart visualize mynetwork.graphml -o net.png --layout circular\npypopart visualize mynetwork.graphml -o net.png --layout radial\n\n# Show node labels\npypopart visualize mynetwork.graphml -o net.png --show-labels\n\n# Custom size\npypopart visualize mynetwork.graphml -o net.png --width 1200 --height 900\n\n# Save as PDF (publication-ready)\npypopart visualize mynetwork.graphml -o net.pdf\n</code></pre>"},{"location":"quickstart/#using-the-python-api","title":"Using the Python API","text":"<p>For more control, use Python directly:</p> <pre><code>from pypopart.io import load_alignment\nfrom pypopart.core.distance import DistanceCalculator\nfrom pypopart.core.condensation import condense_alignment\nfrom pypopart.algorithms import MJNAlgorithm\nfrom pypopart.visualization import StaticVisualizer\n\n# Load sequences\nalignment = load_alignment('mysequences.fasta')\nprint(f\"Loaded {len(alignment)} sequences\")\n\n# Calculate distances\ncalculator = DistanceCalculator(method='k2p')\ndistances = calculator.calculate_matrix(alignment)\n\n# Identify haplotypes\nhaplotypes, freq_map = condense_alignment(alignment)\nprint(f\"Found {len(haplotypes)} unique haplotypes\")\n\n# Construct network\nmjn = MJNAlgorithm(epsilon=0)\nnetwork = mjn.construct_network(haplotypes, distances)\n\n# Visualize\nviz = StaticVisualizer(network)\nviz.plot(\n    layout_algorithm='spring',\n    show_labels=True,\n    output_file='network.png'\n)\n</code></pre>"},{"location":"quickstart/#common-workflows","title":"Common Workflows","text":""},{"location":"quickstart/#workflow-1-basic-analysis","title":"Workflow 1: Basic Analysis","text":"<pre><code># 1. Load and inspect data\npypopart load mysequences.fasta\n\n# 2. Build network\npypopart network mysequences.fasta -o network.graphml\n\n# 3. Analyze\npypopart analyze network.graphml --stats --topology\n\n# 4. Visualize\npypopart visualize network.graphml -o network.png\n</code></pre>"},{"location":"quickstart/#workflow-2-algorithm-comparison","title":"Workflow 2: Algorithm Comparison","text":"<pre><code># Try all algorithms\nfor algo in mst msn tcs mjn pn tsw; do\n    pypopart network mysequences.fasta -a $algo -o network_${algo}.graphml\n    pypopart visualize network_${algo}.graphml -o network_${algo}.png\ndone\n</code></pre>"},{"location":"quickstart/#workflow-3-gui-based-analysis","title":"Workflow 3: GUI-based Analysis","text":"<p>For an interactive workflow:</p> <pre><code># Launch GUI\npypopart-gui\n\n# Then use the web interface to:\n# 1. Upload sequences and optional metadata\n# 2. Try different algorithms with real-time parameter adjustment\n# 3. Visualize with multiple layout options\n# 4. Drag nodes to reposition\n# 5. Export in various formats\n</code></pre>"},{"location":"quickstart/#workflow-4-with-metadata","title":"Workflow 4: With Metadata","text":"<p>If you have population or location data:</p> <pre><code># Create metadata file (metadata.csv)\ncat &gt; metadata.csv &lt;&lt; 'EOF'\nid,population,location\nSample1,PopA,Site1\nSample2,PopA,Site1\nSample3,PopB,Site2\nSample4,PopB,Site2\nSample5,PopC,Site3\nEOF\n\n# Load with metadata\npypopart load mysequences.fasta -m metadata.csv\n\n# Visualize colored by population\npypopart visualize network.graphml -o network.png --color-by population\n</code></pre>"},{"location":"quickstart/#next-steps","title":"Next Steps","text":"<p>Now that you've created your first network, learn more:</p> <ul> <li>CLI Guide: Complete command-line reference</li> <li>Algorithms: Choosing the right algorithm</li> <li>Tutorials: Detailed examples</li> <li>API Reference: Python API documentation</li> </ul>"},{"location":"quickstart/#getting-help","title":"Getting Help","text":"<ul> <li>Run <code>pypopart --help</code> for command help</li> <li>Run <code>pypopart COMMAND --help</code> for specific command help</li> <li>See FAQ for common questions</li> <li>Check GitHub Issues for known problems</li> </ul>"},{"location":"quickstart/#tips","title":"Tips","text":"<p>Performance</p> <p>For large datasets (&gt;1000 sequences), consider:</p> <ul> <li>Using MST or MSN instead of MJN for speed</li> <li>Using Hamming distance instead of more complex models</li> <li>Increasing epsilon parameter for MJN to reduce complexity</li> </ul> <p>Visualization</p> <ul> <li>PNG for presentations and documents</li> <li>PDF for publications (vector format, scalable)</li> <li>SVG for web use</li> <li>HTML for interactive exploration</li> </ul> <p>File Formats</p> <ul> <li>GraphML preserves all network attributes (recommended)</li> <li>JSON for web applications</li> <li>NEXUS for PopART compatibility</li> </ul> <p>Happy network building! \ud83c\udf33</p>"},{"location":"algorithms/tsw/","title":"Tight Span Walker (TSW) - Parsimony Network Algorithm","text":""},{"location":"algorithms/tsw/#overview","title":"Overview","text":"<p>The Tight Span Walker (TSW) algorithm constructs haplotype networks using parsimony principles by computing the tight span of a distance matrix. The tight span is the smallest metric space that contains all optimal paths between sequences, making it ideal for representing complex evolutionary relationships with reticulation events.</p>"},{"location":"algorithms/tsw/#algorithm-details","title":"Algorithm Details","text":""},{"location":"algorithms/tsw/#how-it-works","title":"How It Works","text":"<ol> <li>Compute dT Distances (Tree Metric)</li> <li>For each pair of sequences (i, j), calculate: <code>dT(i,j) = max over all k of |d(i,k) - d(j,k)|</code></li> <li> <p>This represents the minimum distance if sequences were constrained to a tree structure</p> </li> <li> <p>Build Geodesic Paths</p> </li> <li>For each pair of haplotypes, construct the geodesic (shortest) path</li> <li>Compare the actual distance with the dT distance</li> <li> <p>If <code>actual_distance - dT_distance &gt; epsilon</code>, infer intermediate median vertices</p> </li> <li> <p>Infer Median Vertices</p> </li> <li>When needed, create intermediate (ancestral) nodes</li> <li> <p>Medians represent hypothetical ancestral or intermediate sequences</p> </li> <li> <p>Construct Network</p> </li> <li>Connect all haplotypes through geodesic paths</li> <li>Include inferred median vertices to maintain metric properties</li> </ol>"},{"location":"algorithms/tsw/#key-features","title":"Key Features","text":"<ul> <li>Metric Preservation: Maintains all distance relationships from original data</li> <li>Reticulate Networks: Can represent complex relationships</li> <li>Ancestral Inference: Automatically infers hypothetical ancestral sequences</li> <li>Parsimony-Based: Uses parsimony principles</li> </ul>"},{"location":"algorithms/tsw/#parameters","title":"Parameters","text":"<ul> <li>epsilon (float, default=1e-6): Tolerance for metric comparisons</li> <li>distance_method (str, default='hamming'): Distance calculation method</li> </ul>"},{"location":"algorithms/tsw/#when-to-use-tsw","title":"When to Use TSW","text":"<p>\u2713 Complex evolutionary relationships with reticulation \u2713 Small to medium datasets (n &lt; 100) \u2713 Accurate metric representation needed \u2713 Ancestral sequence inference desired</p>"},{"location":"algorithms/tsw/#usage-example","title":"Usage Example","text":"<pre><code>from pypopart.algorithms import TightSpanWalker\nfrom pypopart.io import load_alignment\n\nalignment = load_alignment('sequences.fasta')\ntsw = TightSpanWalker(distance_method='hamming')\nnetwork = tsw.construct_network(alignment)\n</code></pre>"},{"location":"algorithms/tsw/#references","title":"References","text":"<ol> <li>Dress, A. W., &amp; Huson, D. H. (2004). Constructing splits graphs. IEEE/ACM Transactions on Computational Biology and Bioinformatics, 1(3), 109-115.</li> <li>Bryant, D., &amp; Moulton, V. (2004). Neighbor-Net. Molecular Biology and Evolution, 21(2), 255-265.</li> </ol>"},{"location":"api/algorithms/base/","title":"Base Algorithm Module","text":"<p>Base classes and interfaces for network algorithms.</p>"},{"location":"api/algorithms/base/#overview","title":"Overview","text":"<p>The <code>base</code> module defines the abstract base class for all network construction algorithms.</p>"},{"location":"api/algorithms/base/#classes","title":"Classes","text":""},{"location":"api/algorithms/base/#pypopart.algorithms.base","title":"pypopart.algorithms.base","text":"<p>Base classes for network construction algorithms in PyPopART.</p>"},{"location":"api/algorithms/base/#pypopart.algorithms.base.NetworkAlgorithm","title":"NetworkAlgorithm","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for haplotype network construction algorithms.</p> <p>All network construction algorithms should inherit from this class and implement the construct_network method.</p> Source code in <code>src/pypopart/algorithms/base.py</code> <pre><code>class NetworkAlgorithm(ABC):\n    \"\"\"\n    Abstract base class for haplotype network construction algorithms.\n\n    All network construction algorithms should inherit from this class\n    and implement the construct_network method.\n    \"\"\"\n\n    def __init__(self, distance_method: str = 'hamming', **kwargs):\n        \"\"\"\n        Initialize network algorithm.\n\n        Parameters\n        ----------\n        distance_method :\n            Method for calculating distances (hamming, p, jc, k2p, tn).\n        **kwargs :\n            Additional algorithm-specific parameters.\n        \"\"\"\n        self.distance_method = distance_method\n        self.params = kwargs\n        self._distance_matrix: Optional[DistanceMatrix] = None\n\n    @abstractmethod\n    def construct_network(\n        self, alignment: Alignment, distance_matrix: Optional[DistanceMatrix] = None\n    ) -&gt; HaplotypeNetwork:\n        \"\"\"\n            Construct haplotype network from sequence alignment.\n\n        Parameters\n        ----------\n            alignment :\n                Multiple sequence alignment.\n            distance_matrix :\n                Optional pre-computed distance matrix.\n\n        Returns\n        -------\n            Constructed haplotype network.\n        \"\"\"\n        pass\n\n    def calculate_distances(self, alignment: Alignment) -&gt; DistanceMatrix:\n        \"\"\"\n            Calculate pairwise distances between sequences.\n\n        Parameters\n        ----------\n            alignment :\n                Multiple sequence alignment.\n\n        Returns\n        -------\n            Distance matrix.\n        \"\"\"\n        return calculate_pairwise_distances(\n            alignment,\n            method=self.distance_method,\n            ignore_gaps=self.params.get('ignore_gaps', True),\n        )\n\n    def build_network(\n        self, alignment: Alignment, distance_matrix: Optional[DistanceMatrix] = None\n    ) -&gt; HaplotypeNetwork:\n        \"\"\"\n        Build haplotype network from sequence alignment.\n\n        This is an alias for construct_network() to maintain backward compatibility\n        with CLI and GUI code.\n\n        Parameters\n        ----------\n            alignment :\n                Multiple sequence alignment.\n            distance_matrix :\n                Optional pre-computed distance matrix.\n\n        Returns\n        -------\n            Constructed haplotype network.\n        \"\"\"\n        return self.construct_network(alignment, distance_matrix)\n\n    def get_parameters(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Get algorithm parameters.\n\n        Returns\n        -------\n            Dictionary of parameters.\n        \"\"\"\n        return {'distance_method': self.distance_method, **self.params}\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return string representation.\"\"\"\n        return f'{self.__class__.__name__}(distance={self.distance_method})'\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Detailed representation.\"\"\"\n        params_str = ', '.join(f'{k}={v}' for k, v in self.get_parameters().items())\n        return f'{self.__class__.__name__}({params_str})'\n</code></pre>"},{"location":"api/algorithms/base/#pypopart.algorithms.base.NetworkAlgorithm.__init__","title":"__init__","text":"<pre><code>__init__(distance_method: str = 'hamming', **kwargs)\n</code></pre> <p>Initialize network algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>distance_method</code> <code>str</code> <p>Method for calculating distances (hamming, p, jc, k2p, tn).</p> <code>'hamming'</code> <code>**kwargs</code> <p>Additional algorithm-specific parameters.</p> <code>{}</code> Source code in <code>src/pypopart/algorithms/base.py</code> <pre><code>def __init__(self, distance_method: str = 'hamming', **kwargs):\n    \"\"\"\n    Initialize network algorithm.\n\n    Parameters\n    ----------\n    distance_method :\n        Method for calculating distances (hamming, p, jc, k2p, tn).\n    **kwargs :\n        Additional algorithm-specific parameters.\n    \"\"\"\n    self.distance_method = distance_method\n    self.params = kwargs\n    self._distance_matrix: Optional[DistanceMatrix] = None\n</code></pre>"},{"location":"api/algorithms/base/#pypopart.algorithms.base.NetworkAlgorithm.construct_network","title":"construct_network  <code>abstractmethod</code>","text":"<pre><code>construct_network(\n    alignment: Alignment,\n    distance_matrix: Optional[DistanceMatrix] = None,\n) -&gt; HaplotypeNetwork\n</code></pre> <pre><code>Construct haplotype network from sequence alignment.\n</code></pre> <p>Returns:</p> Type Description <code>    Constructed haplotype network.</code> Source code in <code>src/pypopart/algorithms/base.py</code> <pre><code>@abstractmethod\ndef construct_network(\n    self, alignment: Alignment, distance_matrix: Optional[DistanceMatrix] = None\n) -&gt; HaplotypeNetwork:\n    \"\"\"\n        Construct haplotype network from sequence alignment.\n\n    Parameters\n    ----------\n        alignment :\n            Multiple sequence alignment.\n        distance_matrix :\n            Optional pre-computed distance matrix.\n\n    Returns\n    -------\n        Constructed haplotype network.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/algorithms/base/#pypopart.algorithms.base.NetworkAlgorithm.calculate_distances","title":"calculate_distances","text":"<pre><code>calculate_distances(alignment: Alignment) -&gt; DistanceMatrix\n</code></pre> <pre><code>Calculate pairwise distances between sequences.\n</code></pre> <p>Returns:</p> Type Description <code>    Distance matrix.</code> Source code in <code>src/pypopart/algorithms/base.py</code> <pre><code>def calculate_distances(self, alignment: Alignment) -&gt; DistanceMatrix:\n    \"\"\"\n        Calculate pairwise distances between sequences.\n\n    Parameters\n    ----------\n        alignment :\n            Multiple sequence alignment.\n\n    Returns\n    -------\n        Distance matrix.\n    \"\"\"\n    return calculate_pairwise_distances(\n        alignment,\n        method=self.distance_method,\n        ignore_gaps=self.params.get('ignore_gaps', True),\n    )\n</code></pre>"},{"location":"api/algorithms/base/#pypopart.algorithms.base.NetworkAlgorithm.build_network","title":"build_network","text":"<pre><code>build_network(\n    alignment: Alignment,\n    distance_matrix: Optional[DistanceMatrix] = None,\n) -&gt; HaplotypeNetwork\n</code></pre> <p>Build haplotype network from sequence alignment.</p> <p>This is an alias for construct_network() to maintain backward compatibility with CLI and GUI code.</p> <p>Returns:</p> Type Description <code>    Constructed haplotype network.</code> Source code in <code>src/pypopart/algorithms/base.py</code> <pre><code>def build_network(\n    self, alignment: Alignment, distance_matrix: Optional[DistanceMatrix] = None\n) -&gt; HaplotypeNetwork:\n    \"\"\"\n    Build haplotype network from sequence alignment.\n\n    This is an alias for construct_network() to maintain backward compatibility\n    with CLI and GUI code.\n\n    Parameters\n    ----------\n        alignment :\n            Multiple sequence alignment.\n        distance_matrix :\n            Optional pre-computed distance matrix.\n\n    Returns\n    -------\n        Constructed haplotype network.\n    \"\"\"\n    return self.construct_network(alignment, distance_matrix)\n</code></pre>"},{"location":"api/algorithms/base/#pypopart.algorithms.base.NetworkAlgorithm.get_parameters","title":"get_parameters","text":"<pre><code>get_parameters() -&gt; Dict[str, Any]\n</code></pre> <p>Get algorithm parameters.</p> <p>Returns:</p> Type Description <code>    Dictionary of parameters.</code> Source code in <code>src/pypopart/algorithms/base.py</code> <pre><code>def get_parameters(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Get algorithm parameters.\n\n    Returns\n    -------\n        Dictionary of parameters.\n    \"\"\"\n    return {'distance_method': self.distance_method, **self.params}\n</code></pre>"},{"location":"api/algorithms/base/#pypopart.algorithms.base.NetworkAlgorithm.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return string representation.</p> Source code in <code>src/pypopart/algorithms/base.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return string representation.\"\"\"\n    return f'{self.__class__.__name__}(distance={self.distance_method})'\n</code></pre>"},{"location":"api/algorithms/base/#pypopart.algorithms.base.NetworkAlgorithm.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Detailed representation.</p> Source code in <code>src/pypopart/algorithms/base.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Detailed representation.\"\"\"\n    params_str = ', '.join(f'{k}={v}' for k, v in self.get_parameters().items())\n    return f'{self.__class__.__name__}({params_str})'\n</code></pre>"},{"location":"api/algorithms/mjn/","title":"MJN Algorithm","text":"<p>Median-Joining Network with ancestral inference.</p>"},{"location":"api/algorithms/mjn/#overview","title":"Overview","text":"<p>The MJN (Median-Joining Network) algorithm infers ancestral haplotypes (median vectors) and creates a comprehensive network.</p> <p>Characteristics: - Infers median vectors (unobserved haplotypes) - Most comprehensive algorithm - Shows reticulation events - Computationally intensive</p>"},{"location":"api/algorithms/mjn/#classes","title":"Classes","text":""},{"location":"api/algorithms/mjn/#pypopart.algorithms.mjn","title":"pypopart.algorithms.mjn","text":"<p>Median-Joining Network (MJN) algorithm for haplotype network construction.</p> <p>Implements the method from Bandelt, Forster &amp; Rohl (1999): \"Median-joining networks for inferring intraspecific phylogenies\" Molecular Biology and Evolution 16: 37-48</p>"},{"location":"api/algorithms/mjn/#pypopart.algorithms.mjn.MedianJoiningNetwork","title":"MedianJoiningNetwork","text":"<p>               Bases: <code>MinimumSpanningNetwork</code></p> <p>Construct haplotype network using Median-Joining algorithm.</p> <p>The MJN method extends MSN by inferring median vectors (ancestral or unsampled haplotypes) that simplify the network structure. It combines minimum spanning network principles with median vector inference to create a more parsimonious representation of haplotype relationships.</p> <p>This is particularly useful for datasets with missing intermediate haplotypes and complex reticulation patterns.</p> Source code in <code>src/pypopart/algorithms/mjn.py</code> <pre><code>class MedianJoiningNetwork(MinimumSpanningNetwork):\n    \"\"\"\n    Construct haplotype network using Median-Joining algorithm.\n\n    The MJN method extends MSN by inferring median vectors (ancestral or\n    unsampled haplotypes) that simplify the network structure. It combines\n    minimum spanning network principles with median vector inference to\n    create a more parsimonious representation of haplotype relationships.\n\n    This is particularly useful for datasets with missing intermediate\n    haplotypes and complex reticulation patterns.\n    \"\"\"\n\n    def __init__(\n        self,\n        distance_method: str = 'hamming',\n        epsilon: float = 0.0,\n        max_median_vectors: Optional[int] = None,\n        simplify: bool = True,\n        **kwargs,\n    ):\n        \"\"\"\n        Initialize MJN algorithm.\n\n        Parameters\n        ----------\n        distance_method :\n            Method for calculating distances.\n        epsilon :\n            Weight parameter for controlling network complexity.\n        max_median_vectors :\n            Maximum number of median vectors to add.\n        simplify :\n            Whether to simplify network after median vector addition.\n        **kwargs :\n            Additional parameters.\n        \"\"\"\n        super().__init__(distance_method, epsilon=epsilon, **kwargs)\n        self.max_median_vectors = max_median_vectors\n        self.simplify = simplify\n        self._median_counter = 0\n\n    def construct_network(\n        self, alignment: Alignment, distance_matrix: Optional[DistanceMatrix] = None\n    ) -&gt; HaplotypeNetwork:\n        \"\"\"\n            Construct MJN from sequence alignment with iterative refinement.\n\n        Parameters\n        ----------\n            alignment :\n                Multiple sequence alignment.\n            distance_matrix :\n                Optional pre-computed distance matrix.\n\n        Returns\n        -------\n            Haplotype network with inferred median vectors.\n        \"\"\"\n        # Identify unique haplotypes\n        haplotypes = identify_haplotypes(alignment)\n\n        if len(haplotypes) &lt;= 2:\n            # Too few haplotypes for median vector inference\n            return super().construct_network(alignment, distance_matrix)\n\n        # Calculate or use provided distance matrix\n        if distance_matrix is None:\n            distance_matrix = self.calculate_distances(alignment)\n\n        self._distance_matrix = distance_matrix\n\n        # Iteratively refine network with median vectors (matches C++ behavior)\n        network = self._iterative_median_joining(haplotypes, alignment, distance_matrix)\n\n        return network\n\n    def _iterative_median_joining(\n        self, haplotypes: List, alignment: Alignment, distance_matrix: DistanceMatrix\n    ) -&gt; HaplotypeNetwork:\n        \"\"\"\n            Refine network iteratively by adding median vectors (C++ algorithm).\n\n            Repeatedly:\n            1. Build MSN from current haplotypes\n            2. Find quasi-median vectors for triplets\n            3. Add medians that reduce network cost\n            4. Remove obsolete vertices (degree &lt; 2)\n            5. Repeat until no new medians are added\n\n        Parameters\n        ----------\n            haplotypes :\n                Initial list of observed haplotypes.\n            alignment :\n                Sequence alignment.\n            distance_matrix :\n                Distance matrix.\n\n        Returns\n        -------\n            Refined network with median vectors.\n        \"\"\"\n        # Track all sequences seen (observed + inferred)\n        all_sequences = {h.sequence.data for h in haplotypes}\n        current_haplotypes = list(haplotypes)\n\n        iteration = 0\n        max_iterations = 50  # Prevent infinite loops\n        changed = True\n        old_msn_length = -1\n\n        while changed and iteration &lt; max_iterations:\n            iteration += 1\n            changed = False\n\n            # Build MSN from current haplotypes\n            msn = self._build_msn_for_iteration(current_haplotypes, distance_matrix)\n\n            # Calculate MSN total length\n            msn_length = sum(\n                msn.get_edge_distance(u, v) or 0 for u, v in msn.graph.edges()\n            )\n\n            # Check for convergence\n            if old_msn_length &gt; 0 and msn_length &gt;= old_msn_length:\n                # Network is not improving, stop\n                break\n\n            old_msn_length = msn_length\n\n            # Remove obsolete median vectors (degree &lt; 2)\n            current_haplotypes = self._remove_obsolete_medians(msn, current_haplotypes)\n\n            # Find minimum cost for median vectors\n            min_cost = float('inf')\n            candidate_medians = []\n\n            # Check all triplets in current MSN\n            for triplet in self._find_all_triplets_in_msn(msn):\n                h1_id, h2_id, h3_id = triplet\n\n                h1 = msn.get_haplotype(h1_id)\n                h2 = msn.get_haplotype(h2_id)\n                h3 = msn.get_haplotype(h3_id)\n\n                # Compute quasi-median sequences\n                quasi_medians = self._compute_quasi_medians(\n                    h1.sequence, h2.sequence, h3.sequence\n                )\n\n                # Check each quasi-median\n                for median_seq in quasi_medians:\n                    if median_seq not in all_sequences:\n                        # Calculate cost\n                        cost = self._compute_median_cost(\n                            h1.sequence, h2.sequence, h3.sequence, median_seq\n                        )\n\n                        if cost &lt; min_cost:\n                            min_cost = cost\n\n                        candidate_medians.append((median_seq, cost, triplet))\n\n            # Add medians within epsilon of minimum cost\n            for median_seq, cost, _triplet in candidate_medians:\n                if cost &lt;= min_cost + self.epsilon:\n                    # Create median haplotype\n                    median_hap = Haplotype(\n                        sequence=Sequence(\n                            id=f'Median_{self._median_counter}', data=median_seq\n                        ),\n                        sample_ids=[],\n                    )\n                    self._median_counter += 1\n\n                    # Add to working set\n                    current_haplotypes.append(median_hap)\n                    all_sequences.add(median_seq)\n                    changed = True\n\n                    if (\n                        self.max_median_vectors\n                        and self._median_counter &gt;= self.max_median_vectors\n                    ):\n                        break\n\n            if not changed:\n                break\n\n        # Final MSN construction\n        final_network = self._build_msn_for_iteration(\n            current_haplotypes, distance_matrix\n        )\n\n        # Final cleanup\n        if self.simplify:\n            final_network = self._simplify_network(final_network)\n\n        return final_network\n\n    def _build_msn_for_iteration(\n        self, haplotypes: List, distance_matrix: DistanceMatrix\n    ) -&gt; HaplotypeNetwork:\n        \"\"\"\n            Build MSN from current haplotypes for one iteration.\n\n        Parameters\n        ----------\n            haplotypes :\n                Current list of haplotypes.\n            distance_matrix :\n                Distance matrix (may need recalculation).\n\n        Returns\n        -------\n            MSN network.\n        \"\"\"\n        # Handle empty or single haplotype case\n        if len(haplotypes) == 0:\n            return HaplotypeNetwork()\n\n        if len(haplotypes) == 1:\n            network = HaplotypeNetwork()\n            network.add_haplotype(haplotypes[0])\n            return network\n\n        # Calculate distances between current haplotypes (including new medians)\n        haplotype_dist_matrix = self._calculate_haplotype_distances(haplotypes)\n\n        # Build initial MST\n        mst_edges = self._prim_mst(haplotypes, haplotype_dist_matrix)\n\n        # Add alternative connections at same distance\n        msn_edges = self._add_alternative_connections(\n            haplotypes, mst_edges, haplotype_dist_matrix\n        )\n\n        # Remove redundant edges\n        final_edges = self._remove_redundant_edges(haplotypes, msn_edges)\n\n        # Construct network (preserves haplotype IDs)\n        network = self._build_network(haplotypes, final_edges)\n\n        return network\n\n    def _find_all_triplets_in_msn(\n        self, network: HaplotypeNetwork\n    ) -&gt; List[Tuple[str, str, str]]:\n        \"\"\"\n            Find all triplets (connected triples) in MSN.\n\n            A triplet consists of three nodes where at least two edges exist\n            between them (not necessarily a triangle).\n\n        Parameters\n        ----------\n            network :\n                Current MSN.\n\n        Returns\n        -------\n            List of triplets.\n        \"\"\"\n        triplets = []\n        hap_ids = list({h.id for h in network.haplotypes})\n\n        for i, h1 in enumerate(hap_ids):\n            neighbors_h1 = set(network.get_neighbors(h1))\n\n            for j in range(i + 1, len(hap_ids)):\n                h2 = hap_ids[j]\n\n                if h2 in neighbors_h1:\n                    # h1 and h2 are connected\n                    neighbors_h2 = set(network.get_neighbors(h2))\n\n                    # Find common neighbors\n                    for h3 in neighbors_h1.intersection(neighbors_h2):\n                        if h3 != h1 and h3 != h2:\n                            triplets.append((h1, h2, h3))\n\n        return triplets\n\n    def _compute_quasi_medians(\n        self, seq1: Sequence, seq2: Sequence, seq3: Sequence\n    ) -&gt; Set[str]:\n        \"\"\"\n            Compute quasi-median sequences (Steiner tree approach).\n\n            For positions where all three sequences differ, generates all\n            possible combinations (creating a set of quasi-medians).\n\n            This matches the C++ computeQuasiMedianSeqs implementation.\n\n        Parameters\n        ----------\n                seq1, seq2, seq3: Three sequences\n\n        Returns\n        -------\n            Set of quasi-median sequence strings.\n        \"\"\"\n        if len(seq1) != len(seq2) or len(seq1) != len(seq3):\n            return set()\n\n        # Build initial quasi-median with '*' at ambiguous positions\n        qm_seq = []\n        has_star = False\n\n        for i in range(len(seq1)):\n            c1, c2, c3 = seq1.data[i], seq2.data[i], seq3.data[i]\n\n            if c1 == c2 or c1 == c3:\n                qm_seq.append(c1)\n            elif c2 == c3:\n                qm_seq.append(c2)\n            else:\n                # All three differ\n                qm_seq.append('*')\n                has_star = True\n\n        if not has_star:\n            # Simple median exists\n            return {''.join(qm_seq)}\n\n        # Resolve '*' positions by generating all combinations\n        medians = set()\n        stack = [''.join(qm_seq)]\n\n        while stack:\n            current = stack.pop()\n            first_star = current.find('*')\n\n            if first_star == -1:\n                # No more stars, add to result\n                medians.add(current)\n            else:\n                # Replace star with each of the three bases\n                for base in [\n                    seq1.data[first_star],\n                    seq2.data[first_star],\n                    seq3.data[first_star],\n                ]:\n                    new_seq = current[:first_star] + base + current[first_star + 1 :]\n                    stack.append(new_seq)\n\n        return medians\n\n    def _compute_median_cost(\n        self, seq1: Sequence, seq2: Sequence, seq3: Sequence, median_seq: str\n    ) -&gt; int:\n        \"\"\"\n            Compute cost of a median vector.\n\n            Cost is sum of distances from median to the three sequences.\n\n        Parameters\n        ----------\n                seq1, seq2, seq3: Three sequences forming the triplet\n            median_seq :\n                Candidate median sequence string.\n\n        Returns\n        -------\n            Total cost (sum of Hamming distances).\n        \"\"\"\n        median = Sequence(id='temp', data=median_seq)\n\n        dist1 = hamming_distance(seq1, median, ignore_gaps=True)\n        dist2 = hamming_distance(seq2, median, ignore_gaps=True)\n        dist3 = hamming_distance(seq3, median, ignore_gaps=True)\n\n        return dist1 + dist2 + dist3\n\n    def _remove_obsolete_medians(\n        self, network: HaplotypeNetwork, haplotypes: List\n    ) -&gt; List:\n        \"\"\"\n            Remove median vectors with degree &lt; 2 (obsolete).\n\n            Matches C++ removeObsoleteVerts behavior.\n\n        Parameters\n        ----------\n            network :\n                Current network.\n            haplotypes :\n                List of all haplotypes.\n\n        Returns\n        -------\n            Updated list with obsolete medians removed.\n        \"\"\"\n        changed = True\n\n        while changed:\n            changed = False\n            to_remove = []\n\n            for haplotype in haplotypes:\n                if haplotype.frequency == 0:  # Only check inferred medians\n                    # Check if haplotype exists in network before getting degree\n                    if network.has_node(haplotype.id):\n                        degree = network.get_degree(haplotype.id)\n                        if degree &lt; 2:\n                            to_remove.append(haplotype)\n                            changed = True\n                    else:\n                        # Haplotype not in network, remove it\n                        to_remove.append(haplotype)\n                        changed = True\n\n            # Remove obsolete medians\n            for hap in to_remove:\n                haplotypes = [h for h in haplotypes if h.id != hap.id]\n\n        return haplotypes\n\n    def _add_median_vectors(\n        self, network: HaplotypeNetwork, sequence_length: int\n    ) -&gt; HaplotypeNetwork:\n        \"\"\"\n            Infer and add median vectors to the network.\n\n        Parameters\n        ----------\n            network :\n                Initial haplotype network.\n            sequence_length :\n                Length of sequences.\n\n        Returns\n        -------\n            Network with median vectors added.\n        \"\"\"\n        self._median_counter = 0\n        median_vectors_added = 0\n\n        # Get all triangles (3-cliques) in the network\n        triangles = self._find_triplets(network)\n\n        for hap1_id, hap2_id, hap3_id in triangles:\n            if (\n                self.max_median_vectors\n                and median_vectors_added &gt;= self.max_median_vectors\n            ):\n                break\n\n            # Get the three haplotypes\n            hap1 = network.get_haplotype(hap1_id)\n            hap2 = network.get_haplotype(hap2_id)\n            hap3 = network.get_haplotype(hap3_id)\n\n            # Calculate median vector\n            median_seq = self._calculate_median(\n                hap1.sequence, hap2.sequence, hap3.sequence\n            )\n\n            if median_seq is None:\n                continue\n\n            # Check if median already exists in network\n            if self._sequence_in_network(median_seq, network):\n                continue\n\n            # Calculate distances from median to the three haplotypes\n            median_hap = Haplotype(\n                sequence=Sequence(id=f'Median_{self._median_counter}', data=median_seq),\n                sample_ids=[],\n            )\n            self._median_counter += 1\n\n            dist1 = hamming_distance(\n                median_hap.sequence, hap1.sequence, ignore_gaps=True\n            )\n            dist2 = hamming_distance(\n                median_hap.sequence, hap2.sequence, ignore_gaps=True\n            )\n            dist3 = hamming_distance(\n                median_hap.sequence, hap3.sequence, ignore_gaps=True\n            )\n\n            # Check if median vector simplifies the network\n            # (reduces total edge weight)\n            original_edges = [\n                network.get_edge_distance(hap1_id, hap2_id) or 0,\n                network.get_edge_distance(hap1_id, hap3_id) or 0,\n                network.get_edge_distance(hap2_id, hap3_id) or 0,\n            ]\n            original_weight = sum(d for d in original_edges if d &gt; 0)\n            new_weight = dist1 + dist2 + dist3\n\n            if new_weight &lt; original_weight:\n                # Add median vector to network\n                network.add_haplotype(median_hap)\n\n                # Connect median to the three haplotypes\n                if dist1 &gt; 0:\n                    network.add_edge(median_hap.id, hap1_id, distance=dist1)\n                if dist2 &gt; 0:\n                    network.add_edge(median_hap.id, hap2_id, distance=dist2)\n                if dist3 &gt; 0:\n                    network.add_edge(median_hap.id, hap3_id, distance=dist3)\n\n                median_vectors_added += 1\n\n        return network\n\n    def _find_triplets(self, network: HaplotypeNetwork) -&gt; List[Tuple[str, str, str]]:\n        \"\"\"\n            Find all triplets (triangles) in the network.\n\n        Parameters\n        ----------\n            network :\n                Haplotype network.\n\n        Returns\n        -------\n            List of triplets (id1, id2, id3).\n        \"\"\"\n        triplets = []\n        hap_ids = list({h.id for h in network.haplotypes})\n\n        # Check all combinations of 3 haplotypes\n        for hap1, hap2, hap3 in itertools.combinations(hap_ids, 3):\n            # Check if they form a triangle (all three edges exist)\n            has_12 = network.has_edge(hap1, hap2)\n            has_13 = network.has_edge(hap1, hap3)\n            has_23 = network.has_edge(hap2, hap3)\n\n            if has_12 and has_13 and has_23:\n                triplets.append((hap1, hap2, hap3))\n\n        return triplets\n\n    def _calculate_median(\n        self, seq1: Sequence, seq2: Sequence, seq3: Sequence\n    ) -&gt; Optional[Sequence]:\n        \"\"\"\n            Calculate median sequence of three sequences.\n\n            For each position, the median is the most common nucleotide\n            among the three sequences. If all three are different, no\n            clear median exists for that position.\n\n        Parameters\n        ----------\n                seq1, seq2, seq3: Three Sequence objects\n\n        Returns\n        -------\n            Median Sequence, or None if no clear median exists.\n        \"\"\"\n        if len(seq1) != len(seq2) or len(seq1) != len(seq3):\n            return None\n\n        median_data = []\n\n        for i in range(len(seq1)):\n            c1, c2, c3 = seq1.data[i], seq2.data[i], seq3.data[i]\n\n            # Find most common nucleotide\n            if c1 == c2:\n                median_data.append(c1)\n            elif c1 == c3:\n                median_data.append(c1)\n            elif c2 == c3:\n                median_data.append(c2)\n            else:\n                # All three different - no clear median\n                # Use majority rule or first sequence's base\n                # For simplicity, we'll say no median exists for this triplet\n                return None\n\n        median_seq = Sequence(id='median_temp', data=''.join(median_data))\n\n        return median_seq\n\n    def _sequence_in_network(\n        self, sequence: Sequence, network: HaplotypeNetwork\n    ) -&gt; bool:\n        \"\"\"\n            Check if a sequence already exists in the network.\n\n        Parameters\n        ----------\n            sequence :\n                Sequence to check.\n            network :\n                Haplotype network.\n\n        Returns\n        -------\n            True if sequence exists in network.\n        \"\"\"\n        seq_data = sequence.data\n\n        for haplotype in network.haplotypes:\n            if haplotype.sequence.data == seq_data:\n                return True\n\n        return False\n\n    def _simplify_network(self, network: HaplotypeNetwork) -&gt; HaplotypeNetwork:\n        \"\"\"\n            Simplify network by removing unnecessary median vectors.\n\n            Iteratively removes median vectors that:\n            - Have degree &lt; 2 (disconnected or terminal nodes)\n            - Have degree 2 and can be replaced by a direct edge\n\n            Matches the C++ implementation's removeObsoleteVerts behavior.\n\n        Parameters\n        ----------\n            network :\n                Network with median vectors.\n\n        Returns\n        -------\n            Simplified network.\n        \"\"\"\n        changed = True\n\n        # Iterate until no more changes (matches C++ while loop)\n        while changed:\n            changed = False\n            to_remove = []\n\n            for hap_id in list({h.id for h in network.haplotypes}):\n                if not hap_id.startswith('Median_'):\n                    continue\n\n                degree = network.get_degree(hap_id)\n\n                # Remove obsolete median vectors (degree &lt; 2) - matches C++ behavior\n                if degree &lt; 2:\n                    to_remove.append(hap_id)\n                    changed = True\n                elif degree == 2:\n                    # Get the two neighbors\n                    neighbors = network.get_neighbors(hap_id)\n                    if len(neighbors) == 2:\n                        n1, n2 = neighbors\n\n                        # Get distances\n                        d1 = network.get_edge_distance(hap_id, n1) or 0\n                        d2 = network.get_edge_distance(hap_id, n2) or 0\n\n                        # Check if direct connection exists between the two neighbors\n                        if not network.has_edge(n1, n2):\n                            # No direct connection - add it with combined distance\n                            network.add_edge(n1, n2, distance=d1 + d2)\n\n                        # Remove the median vector\n                        to_remove.append(hap_id)\n                        changed = True\n\n            # Remove marked median vectors\n            for hap_id in to_remove:\n                network.remove_haplotype(hap_id)\n\n        return network\n\n    def get_parameters(self) -&gt; dict:\n        \"\"\"Get algorithm parameters.\"\"\"\n        params = super().get_parameters()\n        params['max_median_vectors'] = self.max_median_vectors\n        params['simplify'] = self.simplify\n        return params\n</code></pre>"},{"location":"api/algorithms/mjn/#pypopart.algorithms.mjn.MedianJoiningNetwork.__init__","title":"__init__","text":"<pre><code>__init__(\n    distance_method: str = \"hamming\",\n    epsilon: float = 0.0,\n    max_median_vectors: Optional[int] = None,\n    simplify: bool = True,\n    **kwargs\n)\n</code></pre> <p>Initialize MJN algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>distance_method</code> <code>str</code> <p>Method for calculating distances.</p> <code>'hamming'</code> <code>epsilon</code> <code>float</code> <p>Weight parameter for controlling network complexity.</p> <code>0.0</code> <code>max_median_vectors</code> <code>Optional[int]</code> <p>Maximum number of median vectors to add.</p> <code>None</code> <code>simplify</code> <code>bool</code> <p>Whether to simplify network after median vector addition.</p> <code>True</code> <code>**kwargs</code> <p>Additional parameters.</p> <code>{}</code> Source code in <code>src/pypopart/algorithms/mjn.py</code> <pre><code>def __init__(\n    self,\n    distance_method: str = 'hamming',\n    epsilon: float = 0.0,\n    max_median_vectors: Optional[int] = None,\n    simplify: bool = True,\n    **kwargs,\n):\n    \"\"\"\n    Initialize MJN algorithm.\n\n    Parameters\n    ----------\n    distance_method :\n        Method for calculating distances.\n    epsilon :\n        Weight parameter for controlling network complexity.\n    max_median_vectors :\n        Maximum number of median vectors to add.\n    simplify :\n        Whether to simplify network after median vector addition.\n    **kwargs :\n        Additional parameters.\n    \"\"\"\n    super().__init__(distance_method, epsilon=epsilon, **kwargs)\n    self.max_median_vectors = max_median_vectors\n    self.simplify = simplify\n    self._median_counter = 0\n</code></pre>"},{"location":"api/algorithms/mjn/#pypopart.algorithms.mjn.MedianJoiningNetwork.construct_network","title":"construct_network","text":"<pre><code>construct_network(\n    alignment: Alignment,\n    distance_matrix: Optional[DistanceMatrix] = None,\n) -&gt; HaplotypeNetwork\n</code></pre> <pre><code>Construct MJN from sequence alignment with iterative refinement.\n</code></pre> <p>Returns:</p> Type Description <code>    Haplotype network with inferred median vectors.</code> Source code in <code>src/pypopart/algorithms/mjn.py</code> <pre><code>def construct_network(\n    self, alignment: Alignment, distance_matrix: Optional[DistanceMatrix] = None\n) -&gt; HaplotypeNetwork:\n    \"\"\"\n        Construct MJN from sequence alignment with iterative refinement.\n\n    Parameters\n    ----------\n        alignment :\n            Multiple sequence alignment.\n        distance_matrix :\n            Optional pre-computed distance matrix.\n\n    Returns\n    -------\n        Haplotype network with inferred median vectors.\n    \"\"\"\n    # Identify unique haplotypes\n    haplotypes = identify_haplotypes(alignment)\n\n    if len(haplotypes) &lt;= 2:\n        # Too few haplotypes for median vector inference\n        return super().construct_network(alignment, distance_matrix)\n\n    # Calculate or use provided distance matrix\n    if distance_matrix is None:\n        distance_matrix = self.calculate_distances(alignment)\n\n    self._distance_matrix = distance_matrix\n\n    # Iteratively refine network with median vectors (matches C++ behavior)\n    network = self._iterative_median_joining(haplotypes, alignment, distance_matrix)\n\n    return network\n</code></pre>"},{"location":"api/algorithms/mjn/#pypopart.algorithms.mjn.MedianJoiningNetwork.get_parameters","title":"get_parameters","text":"<pre><code>get_parameters() -&gt; dict\n</code></pre> <p>Get algorithm parameters.</p> Source code in <code>src/pypopart/algorithms/mjn.py</code> <pre><code>def get_parameters(self) -&gt; dict:\n    \"\"\"Get algorithm parameters.\"\"\"\n    params = super().get_parameters()\n    params['max_median_vectors'] = self.max_median_vectors\n    params['simplify'] = self.simplify\n    return params\n</code></pre>"},{"location":"api/algorithms/msn/","title":"MSN Algorithm","text":"<p>Minimum Spanning Network with alternative connections.</p>"},{"location":"api/algorithms/msn/#overview","title":"Overview","text":"<p>The MSN (Minimum Spanning Network) algorithm extends MST by adding alternative equally parsimonious connections.</p> <p>Characteristics: - Shows reticulation - Alternative evolutionary paths - Still relatively simple - Fast computation</p>"},{"location":"api/algorithms/msn/#classes","title":"Classes","text":""},{"location":"api/algorithms/msn/#pypopart.algorithms.msn","title":"pypopart.algorithms.msn","text":"<p>Minimum Spanning Network (MSN) algorithm for haplotype network construction.</p>"},{"location":"api/algorithms/msn/#pypopart.algorithms.msn.MinimumSpanningNetwork","title":"MinimumSpanningNetwork","text":"<p>               Bases: <code>MinimumSpanningTree</code></p> <p>Construct a Minimum Spanning Network from haplotype data.</p> <p>MSN extends MST by adding alternative connections at the same distance level, creating a network that shows all equally parsimonious relationships between haplotypes while removing redundant edges.</p> <p>This creates a more realistic representation of genetic relationships than a simple tree, as it can represent reticulation events and uncertainty in phylogenetic relationships.</p> Source code in <code>src/pypopart/algorithms/msn.py</code> <pre><code>class MinimumSpanningNetwork(MinimumSpanningTree):\n    \"\"\"\n    Construct a Minimum Spanning Network from haplotype data.\n\n    MSN extends MST by adding alternative connections at the same distance\n    level, creating a network that shows all equally parsimonious relationships\n    between haplotypes while removing redundant edges.\n\n    This creates a more realistic representation of genetic relationships than\n    a simple tree, as it can represent reticulation events and uncertainty in\n    phylogenetic relationships.\n    \"\"\"\n\n    def __init__(\n        self,\n        distance_method: str = 'hamming',\n        epsilon: float = 0.0,\n        max_connections: Optional[int] = None,\n        **kwargs,\n    ):\n        \"\"\"\n        Initialize MSN algorithm.\n\n        Parameters\n        ----------\n        distance_method :\n            Method for calculating distances.\n        epsilon :\n            Tolerance for considering distances equal (default 0.0).\n        max_connections :\n            Maximum number of alternative connections per node.\n        **kwargs :\n            Additional parameters.\n        \"\"\"\n        super().__init__(distance_method, algorithm='prim', **kwargs)\n        self.epsilon = epsilon\n        self.max_connections = max_connections\n\n    def construct_network(\n        self, alignment: Alignment, distance_matrix: Optional[DistanceMatrix] = None\n    ) -&gt; HaplotypeNetwork:\n        \"\"\"\n            Construct MSN from sequence alignment.\n\n        Parameters\n        ----------\n            alignment :\n                Multiple sequence alignment.\n            distance_matrix :\n                Optional pre-computed distance matrix.\n\n        Returns\n        -------\n            Haplotype network representing the MSN.\n        \"\"\"\n        # Identify unique haplotypes\n        haplotypes = identify_haplotypes(alignment)\n\n        if len(haplotypes) &lt;= 1:\n            return super().construct_network(alignment, distance_matrix)\n\n        # Calculate distances between haplotypes\n        haplotype_dist_matrix = self._calculate_haplotype_distances(haplotypes)\n        self._distance_matrix = haplotype_dist_matrix\n\n        # Build initial MST\n        mst_edges = self._prim_mst(haplotypes, haplotype_dist_matrix)\n\n        # Add alternative connections at same distance\n        msn_edges = self._add_alternative_connections(\n            haplotypes, mst_edges, haplotype_dist_matrix\n        )\n\n        # Remove redundant edges\n        final_edges = self._remove_redundant_edges(haplotypes, msn_edges)\n\n        # Construct network\n        network = self._build_network(haplotypes, final_edges)\n\n        return network\n\n    def _add_alternative_connections(\n        self,\n        haplotypes: List,\n        mst_edges: List[Tuple[str, str, float]],\n        distance_matrix: DistanceMatrix,\n    ) -&gt; List[Tuple[str, str, float]]:\n        \"\"\"\n            Add alternative connections at the same distance level.\n\n            For each distance level in the MST, add all edges at that distance\n            (or within epsilon) that don't create redundancy.\n\n        Parameters\n        ----------\n            haplotypes :\n                List of Haplotype objects.\n            mst_edges :\n                MST edges from Prim's algorithm.\n            distance_matrix :\n                Distance matrix.\n\n        Returns\n        -------\n            Extended list of edges including alternatives.\n        \"\"\"\n        hap_ids = [h.id for h in haplotypes]\n\n        # Track which edges are already in the network\n        existing_edges = set()\n        for id1, id2, _dist in mst_edges:\n            existing_edges.add((min(id1, id2), max(id1, id2)))\n\n        # Get unique distances from MST\n        mst_distances = sorted({dist for _, _, dist in mst_edges})\n\n        all_edges = list(mst_edges)\n\n        # For each distance level, add alternative edges\n        for target_dist in mst_distances:\n            # Find all possible edges at this distance (within epsilon)\n            candidate_edges = []\n\n            for i, id1 in enumerate(hap_ids):\n                for id2 in hap_ids[i + 1 :]:\n                    edge_key = (min(id1, id2), max(id1, id2))\n                    if edge_key in existing_edges:\n                        continue\n\n                    dist = distance_matrix.get_distance(id1, id2)\n\n                    # Check if distance matches target (within epsilon)\n                    if abs(dist - target_dist) &lt;= self.epsilon:\n                        candidate_edges.append((id1, id2, dist))\n\n            # Add candidate edges that create useful connections\n            for id1, id2, dist in candidate_edges:\n                # Check if adding this edge would be useful\n                # (connects nodes that aren't already directly connected)\n                edge_key = (min(id1, id2), max(id1, id2))\n\n                # Add the edge\n                all_edges.append((id1, id2, dist))\n                existing_edges.add(edge_key)\n\n                # Respect max_connections limit if specified\n                if self.max_connections is not None:\n                    conn_count1 = sum(1 for e in all_edges if id1 in (e[0], e[1]))\n                    conn_count2 = sum(1 for e in all_edges if id2 in (e[0], e[1]))\n\n                    if (\n                        conn_count1 &gt; self.max_connections\n                        or conn_count2 &gt; self.max_connections\n                    ):\n                        # Remove this edge if it violates max_connections\n                        all_edges.pop()\n                        existing_edges.remove(edge_key)\n\n        return all_edges\n\n    def _remove_redundant_edges(\n        self, haplotypes: List, edges: List[Tuple[str, str, float]]\n    ) -&gt; List[Tuple[str, str, float]]:\n        \"\"\"\n            Remove redundant edges from the network.\n\n            An edge is redundant if removing it doesn't disconnect the network\n            and there exists an alternative path of the same or shorter total length.\n\n        Parameters\n        ----------\n            haplotypes :\n                List of Haplotype objects.\n            edges :\n                List of edges.\n\n        Returns\n        -------\n            List of non-redundant edges.\n        \"\"\"\n        if len(edges) &lt;= len(haplotypes) - 1:\n            # Already minimal - can't remove any edges without disconnecting\n            return edges\n\n        # Build adjacency list\n        adjacency: Dict[str, List[Tuple[str, float]]] = {}\n        for id1, id2, dist in edges:\n            if id1 not in adjacency:\n                adjacency[id1] = []\n            if id2 not in adjacency:\n                adjacency[id2] = []\n            adjacency[id1].append((id2, dist))\n            adjacency[id2].append((id1, dist))\n\n        # Try to remove each edge and check if network remains connected\n        non_redundant = []\n\n        for edge in edges:\n            id1, id2, dist = edge\n\n            # Temporarily remove edge\n            adjacency[id1] = [(n, d) for n, d in adjacency[id1] if n != id2]\n            adjacency[id2] = [(n, d) for n, d in adjacency[id2] if n != id1]\n\n            # Check if still connected using BFS\n            if self._is_connected(adjacency, id1, id2):\n                # Check if alternative path exists with same or shorter length\n                alt_path_length = self._shortest_path_length(adjacency, id1, id2)\n                if alt_path_length is not None and alt_path_length &lt;= dist:\n                    # Edge is redundant - don't add it back\n                    continue\n\n            # Edge is not redundant - add it back\n            adjacency[id1].append((id2, dist))\n            adjacency[id2].append((id1, dist))\n            non_redundant.append(edge)\n\n        return non_redundant\n\n    def _is_connected(\n        self, adjacency: Dict[str, List[Tuple[str, float]]], start: str, end: str\n    ) -&gt; bool:\n        \"\"\"\n            Check if two nodes are connected using BFS.\n\n        Parameters\n        ----------\n            adjacency :\n                Adjacency list representation.\n            start :\n                Start node ID.\n            end :\n                End node ID.\n\n        Returns\n        -------\n            True if connected, False otherwise.\n        \"\"\"\n        if start == end:\n            return True\n\n        if start not in adjacency or end not in adjacency:\n            return False\n\n        visited = {start}\n        queue = [start]\n\n        while queue:\n            current = queue.pop(0)\n\n            if current == end:\n                return True\n\n            for neighbor, _ in adjacency.get(current, []):\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append(neighbor)\n\n        return False\n\n    def _shortest_path_length(\n        self, adjacency: Dict[str, List[Tuple[str, float]]], start: str, end: str\n    ) -&gt; Optional[float]:\n        \"\"\"\n            Find shortest path length between two nodes using Dijkstra's algorithm.\n\n        Parameters\n        ----------\n            adjacency :\n                Adjacency list representation.\n            start :\n                Start node ID.\n            end :\n                End node ID.\n\n        Returns\n        -------\n            Shortest path length, or None if no path exists.\n        \"\"\"\n        import heapq\n\n        if start not in adjacency or end not in adjacency:\n            return None\n\n        # Priority queue: (distance, node)\n        pq = [(0, start)]\n        distances = {start: 0}\n        visited = set()\n\n        while pq:\n            current_dist, current = heapq.heappop(pq)\n\n            if current in visited:\n                continue\n\n            visited.add(current)\n\n            if current == end:\n                return current_dist\n\n            for neighbor, edge_dist in adjacency.get(current, []):\n                if neighbor not in visited:\n                    new_dist = current_dist + edge_dist\n                    if neighbor not in distances or new_dist &lt; distances[neighbor]:\n                        distances[neighbor] = new_dist\n                        heapq.heappush(pq, (new_dist, neighbor))\n\n        return distances.get(end)\n\n    def get_parameters(self) -&gt; dict:\n        \"\"\"Get algorithm parameters.\"\"\"\n        params = super().get_parameters()\n        params['epsilon'] = self.epsilon\n        params['max_connections'] = self.max_connections\n        return params\n</code></pre>"},{"location":"api/algorithms/msn/#pypopart.algorithms.msn.MinimumSpanningNetwork.__init__","title":"__init__","text":"<pre><code>__init__(\n    distance_method: str = \"hamming\",\n    epsilon: float = 0.0,\n    max_connections: Optional[int] = None,\n    **kwargs\n)\n</code></pre> <p>Initialize MSN algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>distance_method</code> <code>str</code> <p>Method for calculating distances.</p> <code>'hamming'</code> <code>epsilon</code> <code>float</code> <p>Tolerance for considering distances equal (default 0.0).</p> <code>0.0</code> <code>max_connections</code> <code>Optional[int]</code> <p>Maximum number of alternative connections per node.</p> <code>None</code> <code>**kwargs</code> <p>Additional parameters.</p> <code>{}</code> Source code in <code>src/pypopart/algorithms/msn.py</code> <pre><code>def __init__(\n    self,\n    distance_method: str = 'hamming',\n    epsilon: float = 0.0,\n    max_connections: Optional[int] = None,\n    **kwargs,\n):\n    \"\"\"\n    Initialize MSN algorithm.\n\n    Parameters\n    ----------\n    distance_method :\n        Method for calculating distances.\n    epsilon :\n        Tolerance for considering distances equal (default 0.0).\n    max_connections :\n        Maximum number of alternative connections per node.\n    **kwargs :\n        Additional parameters.\n    \"\"\"\n    super().__init__(distance_method, algorithm='prim', **kwargs)\n    self.epsilon = epsilon\n    self.max_connections = max_connections\n</code></pre>"},{"location":"api/algorithms/msn/#pypopart.algorithms.msn.MinimumSpanningNetwork.construct_network","title":"construct_network","text":"<pre><code>construct_network(\n    alignment: Alignment,\n    distance_matrix: Optional[DistanceMatrix] = None,\n) -&gt; HaplotypeNetwork\n</code></pre> <pre><code>Construct MSN from sequence alignment.\n</code></pre> <p>Returns:</p> Type Description <code>    Haplotype network representing the MSN.</code> Source code in <code>src/pypopart/algorithms/msn.py</code> <pre><code>def construct_network(\n    self, alignment: Alignment, distance_matrix: Optional[DistanceMatrix] = None\n) -&gt; HaplotypeNetwork:\n    \"\"\"\n        Construct MSN from sequence alignment.\n\n    Parameters\n    ----------\n        alignment :\n            Multiple sequence alignment.\n        distance_matrix :\n            Optional pre-computed distance matrix.\n\n    Returns\n    -------\n        Haplotype network representing the MSN.\n    \"\"\"\n    # Identify unique haplotypes\n    haplotypes = identify_haplotypes(alignment)\n\n    if len(haplotypes) &lt;= 1:\n        return super().construct_network(alignment, distance_matrix)\n\n    # Calculate distances between haplotypes\n    haplotype_dist_matrix = self._calculate_haplotype_distances(haplotypes)\n    self._distance_matrix = haplotype_dist_matrix\n\n    # Build initial MST\n    mst_edges = self._prim_mst(haplotypes, haplotype_dist_matrix)\n\n    # Add alternative connections at same distance\n    msn_edges = self._add_alternative_connections(\n        haplotypes, mst_edges, haplotype_dist_matrix\n    )\n\n    # Remove redundant edges\n    final_edges = self._remove_redundant_edges(haplotypes, msn_edges)\n\n    # Construct network\n    network = self._build_network(haplotypes, final_edges)\n\n    return network\n</code></pre>"},{"location":"api/algorithms/msn/#pypopart.algorithms.msn.MinimumSpanningNetwork.get_parameters","title":"get_parameters","text":"<pre><code>get_parameters() -&gt; dict\n</code></pre> <p>Get algorithm parameters.</p> Source code in <code>src/pypopart/algorithms/msn.py</code> <pre><code>def get_parameters(self) -&gt; dict:\n    \"\"\"Get algorithm parameters.\"\"\"\n    params = super().get_parameters()\n    params['epsilon'] = self.epsilon\n    params['max_connections'] = self.max_connections\n    return params\n</code></pre>"},{"location":"api/algorithms/mst/","title":"MST Algorithm","text":"<p>Minimum Spanning Tree network construction.</p>"},{"location":"api/algorithms/mst/#overview","title":"Overview","text":"<p>The MST (Minimum Spanning Tree) algorithm creates the simplest tree connecting all haplotypes with minimum total distance.</p> <p>Characteristics: - Always produces a tree (no cycles) - Deterministic result - Fast computation - Best for initial exploration</p>"},{"location":"api/algorithms/mst/#classes","title":"Classes","text":""},{"location":"api/algorithms/mst/#pypopart.algorithms.mst","title":"pypopart.algorithms.mst","text":"<p>Minimum Spanning Tree (MST) algorithm for haplotype network construction.</p> <p>This module implements both Prim's and Kruskal's algorithms for constructing minimum spanning trees from genetic sequence data. The MST forms the foundation for more complex network algorithms including MSN and median-joining networks.</p> References <p>.. [1] Excoffier, L. &amp; Smouse, P. E. (1994). Using allele frequencies and        geographic subdivision to reconstruct gene trees within a species:        molecular variance parsimony. Genetics, 136(1), 343-359.</p>"},{"location":"api/algorithms/mst/#pypopart.algorithms.mst.MinimumSpanningTree","title":"MinimumSpanningTree","text":"<p>               Bases: <code>NetworkAlgorithm</code></p> <p>Construct a Minimum Spanning Tree from haplotype data.</p> <p>A minimum spanning tree (MST) connects all haplotypes with the minimum total genetic distance. This is the simplest haplotype network algorithm and forms the basis for more complex methods like MSN (Minimum Spanning Network).</p> <p>The MST is guaranteed to be a tree (no cycles) and provides the most parsimonious representation of relationships between haplotypes.</p> <p>Supports both Prim's and Kruskal's algorithms for MST construction:</p> <ul> <li> <p>Prim's algorithm: Grows the tree from a single starting node,   always adding the minimum-weight edge that connects a new node.   Time complexity: O(E log V) with binary heap.</p> </li> <li> <p>Kruskal's algorithm: Sorts all edges and adds them in order of   increasing weight, skipping edges that would create cycles.   Time complexity: O(E log E) with union-find.</p> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>distance_method</code> <code>str</code> <p>str, default='hamming'. Method for calculating pairwise distances between sequences.</p> <code>'hamming'</code> <code>Options</code> <p>'hamming', 'jukes_cantor', 'kimura_2p', 'tamura_nei'.</p> required <code>algorithm</code> <code>str</code> <p>str, default='prim'. MST construction algorithm to use: 'prim' or 'kruskal'.</p> <code>'prim'</code> <code>**kwargs</code> <p>dict. Additional parameters passed to base NetworkAlgorithm.</p> <code>{}</code> <p>Attributes:</p> Name Type Description <code>algorithm</code> <code>str</code> <p>The selected MST algorithm</p> <code>_distance_matrix</code> <code>DistanceMatrix</code> <p>Cached distance matrix from last construction</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pypopart.algorithms import MinimumSpanningTree\n&gt;&gt;&gt; from pypopart.io import load_alignment\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Load alignment\n&gt;&gt;&gt; alignment = load_alignment('sequences.fasta')\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Construct MST using Prim's algorithm\n&gt;&gt;&gt; mst = MinimumSpanningTree(algorithm='prim')\n&gt;&gt;&gt; network = mst.build_network(alignment)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Construct using Kruskal's algorithm\n&gt;&gt;&gt; mst = MinimumSpanningTree(algorithm='kruskal')\n&gt;&gt;&gt; network = mst.build_network(alignment)\n</code></pre> Notes <p>For most applications, Prim's algorithm is preferred as it's typically faster and uses less memory. Kruskal's algorithm can be advantageous when the graph is sparse or when edges are already sorted.</p> See Also <p>MinimumSpanningNetwork : Extension of MST allowing alternative connections TCS : Statistical parsimony network construction</p> Source code in <code>src/pypopart/algorithms/mst.py</code> <pre><code>class MinimumSpanningTree(NetworkAlgorithm):\n    \"\"\"\n    Construct a Minimum Spanning Tree from haplotype data.\n\n    A minimum spanning tree (MST) connects all haplotypes with the minimum total\n    genetic distance. This is the simplest haplotype network algorithm and\n    forms the basis for more complex methods like MSN (Minimum Spanning Network).\n\n    The MST is guaranteed to be a tree (no cycles) and provides the most\n    parsimonious representation of relationships between haplotypes.\n\n    Supports both Prim's and Kruskal's algorithms for MST construction:\n\n    - **Prim's algorithm**: Grows the tree from a single starting node,\n      always adding the minimum-weight edge that connects a new node.\n      Time complexity: O(E log V) with binary heap.\n\n    - **Kruskal's algorithm**: Sorts all edges and adds them in order of\n      increasing weight, skipping edges that would create cycles.\n      Time complexity: O(E log E) with union-find.\n\n    Parameters\n    ----------\n    distance_method :\n        str, default='hamming'.\n        Method for calculating pairwise distances between sequences.\n    Options :\n        'hamming', 'jukes_cantor', 'kimura_2p', 'tamura_nei'.\n    algorithm :\n        str, default='prim'.\n        MST construction algorithm to use: 'prim' or 'kruskal'.\n    **kwargs :\n        dict.\n        Additional parameters passed to base NetworkAlgorithm.\n\n    Attributes\n    ----------\n    algorithm : str\n        The selected MST algorithm\n    _distance_matrix : DistanceMatrix\n        Cached distance matrix from last construction\n\n    Examples\n    --------\n    &gt;&gt;&gt; from pypopart.algorithms import MinimumSpanningTree\n    &gt;&gt;&gt; from pypopart.io import load_alignment\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Load alignment\n    &gt;&gt;&gt; alignment = load_alignment('sequences.fasta')\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Construct MST using Prim's algorithm\n    &gt;&gt;&gt; mst = MinimumSpanningTree(algorithm='prim')\n    &gt;&gt;&gt; network = mst.build_network(alignment)\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Construct using Kruskal's algorithm\n    &gt;&gt;&gt; mst = MinimumSpanningTree(algorithm='kruskal')\n    &gt;&gt;&gt; network = mst.build_network(alignment)\n\n    Notes\n    -----\n    For most applications, Prim's algorithm is preferred as it's typically\n    faster and uses less memory. Kruskal's algorithm can be advantageous\n    when the graph is sparse or when edges are already sorted.\n\n    See Also\n    --------\n    MinimumSpanningNetwork : Extension of MST allowing alternative connections\n    TCS : Statistical parsimony network construction\n    \"\"\"\n\n    def __init__(\n        self, distance_method: str = 'hamming', algorithm: str = 'prim', **kwargs\n    ):\n        \"\"\"\n        Initialize MST algorithm.\n\n        Parameters\n        ----------\n        distance_method :\n            Method for calculating distances.\n        algorithm :\n            MST algorithm to use ('prim' or 'kruskal').\n        **kwargs :\n            Additional parameters.\n        \"\"\"\n        super().__init__(distance_method, **kwargs)\n        self.algorithm = algorithm.lower()\n        if self.algorithm not in ('prim', 'kruskal'):\n            raise ValueError(\n                f\"Unknown MST algorithm: {algorithm}. Use 'prim' or 'kruskal'\"\n            )\n\n    def construct_network(\n        self, alignment: Alignment, distance_matrix: Optional[DistanceMatrix] = None\n    ) -&gt; HaplotypeNetwork:\n        \"\"\"\n            Construct MST from sequence alignment.\n\n        Parameters\n        ----------\n            alignment :\n                Multiple sequence alignment.\n            distance_matrix :\n                Optional pre-computed distance matrix.\n\n        Returns\n        -------\n            Haplotype network representing the MST.\n        \"\"\"\n        # Identify unique haplotypes\n        haplotypes = identify_haplotypes(alignment)\n\n        if len(haplotypes) == 0:\n            return HaplotypeNetwork()\n\n        if len(haplotypes) == 1:\n            # Single haplotype - just add it to network\n            network = HaplotypeNetwork()\n            network.add_haplotype(haplotypes[0])\n            return network\n\n        # Calculate distances between haplotypes\n        haplotype_dist_matrix = self._calculate_haplotype_distances(haplotypes)\n        self._distance_matrix = haplotype_dist_matrix\n\n        # Build MST using selected algorithm\n        if self.algorithm == 'prim':\n            edges = self._prim_mst(haplotypes, haplotype_dist_matrix)\n        else:  # kruskal\n            edges = self._kruskal_mst(haplotypes, haplotype_dist_matrix)\n\n        # Construct network from MST edges\n        network = self._build_network(haplotypes, edges)\n\n        return network\n\n    def _prim_mst(\n        self, haplotypes: List, distance_matrix: DistanceMatrix\n    ) -&gt; List[Tuple[str, str, float]]:\n        \"\"\"\n            Construct MST using Prim's algorithm.\n\n        Parameters\n        ----------\n            haplotypes :\n                List of Haplotype objects.\n            distance_matrix :\n                Distance matrix between haplotypes.\n\n        Returns\n        -------\n            List of edges (id1, id2, distance).\n        \"\"\"\n        if len(haplotypes) == 0:\n            return []\n\n        # Map haplotype IDs to haplotype objects for quick lookup\n        hap_dict = {h.id: h for h in haplotypes}\n        hap_ids = list(hap_dict.keys())\n\n        # Track which nodes are in the tree\n        in_tree = {hap_ids[0]}  # Start with first haplotype\n        not_in_tree = set(hap_ids[1:])\n\n        edges = []\n\n        # Priority queue: (distance, from_id, to_id)\n        pq = []\n\n        # Add all edges from first haplotype\n        for other_id in not_in_tree:\n            dist = distance_matrix.get_distance(hap_ids[0], other_id)\n            heapq.heappush(pq, (dist, hap_ids[0], other_id))\n\n        # Build MST\n        while not_in_tree and pq:\n            dist, from_id, to_id = heapq.heappop(pq)\n\n            # Skip if to_id already in tree (edge is outdated)\n            if to_id not in not_in_tree:\n                continue\n\n            # Add edge to MST\n            edges.append((from_id, to_id, dist))\n            in_tree.add(to_id)\n            not_in_tree.remove(to_id)\n\n            # Add new edges from newly added node\n            for other_id in not_in_tree:\n                new_dist = distance_matrix.get_distance(to_id, other_id)\n                heapq.heappush(pq, (new_dist, to_id, other_id))\n\n        return edges\n\n    def _kruskal_mst(\n        self, haplotypes: List, distance_matrix: DistanceMatrix\n    ) -&gt; List[Tuple[str, str, float]]:\n        \"\"\"\n            Construct MST using Kruskal's algorithm with Union-Find.\n\n        Parameters\n        ----------\n            haplotypes :\n                List of Haplotype objects.\n            distance_matrix :\n                Distance matrix between haplotypes.\n\n        Returns\n        -------\n            List of edges (id1, id2, distance).\n        \"\"\"\n        if len(haplotypes) == 0:\n            return []\n\n        hap_ids = [h.id for h in haplotypes]\n\n        # Get all edges sorted by distance\n        all_edges = []\n        for i, id1 in enumerate(hap_ids):\n            for id2 in hap_ids[i + 1 :]:\n                dist = distance_matrix.get_distance(id1, id2)\n                all_edges.append((dist, id1, id2))\n\n        all_edges.sort()  # Sort by distance\n\n        # Union-Find data structure\n        parent = {hap_id: hap_id for hap_id in hap_ids}\n        rank = dict.fromkeys(hap_ids, 0)\n\n        def find(x):\n            \"\"\"Find root of x with path compression.\"\"\"\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        def union(x, y):\n            \"\"\"Union sets containing x and y.\"\"\"\n            root_x = find(x)\n            root_y = find(y)\n\n            if root_x == root_y:\n                return False\n\n            # Union by rank\n            if rank[root_x] &lt; rank[root_y]:\n                parent[root_x] = root_y\n            elif rank[root_x] &gt; rank[root_y]:\n                parent[root_y] = root_x\n            else:\n                parent[root_y] = root_x\n                rank[root_x] += 1\n\n            return True\n\n        # Build MST\n        mst_edges = []\n        for dist, id1, id2 in all_edges:\n            if union(id1, id2):\n                mst_edges.append((id1, id2, dist))\n                # Stop when we have n-1 edges\n                if len(mst_edges) == len(hap_ids) - 1:\n                    break\n\n        return mst_edges\n\n    def _build_network(\n        self, haplotypes: List, edges: List[Tuple[str, str, float]]\n    ) -&gt; HaplotypeNetwork:\n        \"\"\"\n            Build HaplotypeNetwork from haplotypes and MST edges.\n\n        Parameters\n        ----------\n            haplotypes :\n                List of Haplotype objects.\n            edges :\n                List of edges (id1, id2, distance).\n\n        Returns\n        -------\n            Constructed haplotype network.\n        \"\"\"\n        network = HaplotypeNetwork()\n\n        # Add all haplotypes\n        for haplotype in haplotypes:\n            network.add_haplotype(haplotype)\n\n        # Add MST edges\n        for id1, id2, dist in edges:\n            network.add_edge(id1, id2, distance=int(round(dist)))\n\n        return network\n\n    def _calculate_haplotype_distances(self, haplotypes: List) -&gt; DistanceMatrix:\n        \"\"\"\n            Calculate pairwise distances between haplotypes.\n\n        Parameters\n        ----------\n            haplotypes :\n                List of Haplotype objects.\n\n        Returns\n        -------\n            DistanceMatrix with distances between haplotypes.\n        \"\"\"\n        import numpy as np\n\n        from ..core.distance import hamming_distance\n\n        n = len(haplotypes)\n        labels = [h.id for h in haplotypes]\n        matrix = np.zeros((n, n))\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = hamming_distance(\n                    haplotypes[i].sequence,\n                    haplotypes[j].sequence,\n                    ignore_gaps=self.params.get('ignore_gaps', True),\n                )\n                matrix[i, j] = matrix[j, i] = dist\n\n        return DistanceMatrix(labels, matrix)\n\n    def get_parameters(self) -&gt; dict:\n        \"\"\"Get algorithm parameters including MST algorithm type.\"\"\"\n        params = super().get_parameters()\n        params['algorithm'] = self.algorithm\n        return params\n</code></pre>"},{"location":"api/algorithms/mst/#pypopart.algorithms.mst.MinimumSpanningTree.__init__","title":"__init__","text":"<pre><code>__init__(\n    distance_method: str = \"hamming\",\n    algorithm: str = \"prim\",\n    **kwargs\n)\n</code></pre> <p>Initialize MST algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>distance_method</code> <code>str</code> <p>Method for calculating distances.</p> <code>'hamming'</code> <code>algorithm</code> <code>str</code> <p>MST algorithm to use ('prim' or 'kruskal').</p> <code>'prim'</code> <code>**kwargs</code> <p>Additional parameters.</p> <code>{}</code> Source code in <code>src/pypopart/algorithms/mst.py</code> <pre><code>def __init__(\n    self, distance_method: str = 'hamming', algorithm: str = 'prim', **kwargs\n):\n    \"\"\"\n    Initialize MST algorithm.\n\n    Parameters\n    ----------\n    distance_method :\n        Method for calculating distances.\n    algorithm :\n        MST algorithm to use ('prim' or 'kruskal').\n    **kwargs :\n        Additional parameters.\n    \"\"\"\n    super().__init__(distance_method, **kwargs)\n    self.algorithm = algorithm.lower()\n    if self.algorithm not in ('prim', 'kruskal'):\n        raise ValueError(\n            f\"Unknown MST algorithm: {algorithm}. Use 'prim' or 'kruskal'\"\n        )\n</code></pre>"},{"location":"api/algorithms/mst/#pypopart.algorithms.mst.MinimumSpanningTree.construct_network","title":"construct_network","text":"<pre><code>construct_network(\n    alignment: Alignment,\n    distance_matrix: Optional[DistanceMatrix] = None,\n) -&gt; HaplotypeNetwork\n</code></pre> <pre><code>Construct MST from sequence alignment.\n</code></pre> <p>Returns:</p> Type Description <code>    Haplotype network representing the MST.</code> Source code in <code>src/pypopart/algorithms/mst.py</code> <pre><code>def construct_network(\n    self, alignment: Alignment, distance_matrix: Optional[DistanceMatrix] = None\n) -&gt; HaplotypeNetwork:\n    \"\"\"\n        Construct MST from sequence alignment.\n\n    Parameters\n    ----------\n        alignment :\n            Multiple sequence alignment.\n        distance_matrix :\n            Optional pre-computed distance matrix.\n\n    Returns\n    -------\n        Haplotype network representing the MST.\n    \"\"\"\n    # Identify unique haplotypes\n    haplotypes = identify_haplotypes(alignment)\n\n    if len(haplotypes) == 0:\n        return HaplotypeNetwork()\n\n    if len(haplotypes) == 1:\n        # Single haplotype - just add it to network\n        network = HaplotypeNetwork()\n        network.add_haplotype(haplotypes[0])\n        return network\n\n    # Calculate distances between haplotypes\n    haplotype_dist_matrix = self._calculate_haplotype_distances(haplotypes)\n    self._distance_matrix = haplotype_dist_matrix\n\n    # Build MST using selected algorithm\n    if self.algorithm == 'prim':\n        edges = self._prim_mst(haplotypes, haplotype_dist_matrix)\n    else:  # kruskal\n        edges = self._kruskal_mst(haplotypes, haplotype_dist_matrix)\n\n    # Construct network from MST edges\n    network = self._build_network(haplotypes, edges)\n\n    return network\n</code></pre>"},{"location":"api/algorithms/mst/#pypopart.algorithms.mst.MinimumSpanningTree.get_parameters","title":"get_parameters","text":"<pre><code>get_parameters() -&gt; dict\n</code></pre> <p>Get algorithm parameters including MST algorithm type.</p> Source code in <code>src/pypopart/algorithms/mst.py</code> <pre><code>def get_parameters(self) -&gt; dict:\n    \"\"\"Get algorithm parameters including MST algorithm type.\"\"\"\n    params = super().get_parameters()\n    params['algorithm'] = self.algorithm\n    return params\n</code></pre>"},{"location":"api/algorithms/tcs/","title":"TCS Algorithm","text":"<p>Statistical Parsimony network construction.</p>"},{"location":"api/algorithms/tcs/#overview","title":"Overview","text":"<p>The TCS (Templeton, Crandall, and Sing) algorithm connects haplotypes within a statistical parsimony limit.</p> <p>Characteristics: - Statistically justified connections - May produce disconnected networks - 95% confidence limit by default - Best for within-species variation</p>"},{"location":"api/algorithms/tcs/#classes","title":"Classes","text":""},{"location":"api/algorithms/tcs/#pypopart.algorithms.tcs","title":"pypopart.algorithms.tcs","text":"<p>TCS (Statistical Parsimony) algorithm - Enhanced to match C++ PopART implementation.</p> <p>This implementation closely follows the C++ PopART TCS.cpp logic: - Component-based connection algorithm - Intermediate sequence inference with scoring - Post-processing vertex collapse - Floyd-Warshall for path length calculations</p> <p>Implements the method from Clement, Posada &amp; Crandall (2000): \"TCS: a computer program to estimate gene genealogies\" Molecular Ecology 9: 1657-1659</p>"},{"location":"api/algorithms/tcs/#pypopart.algorithms.tcs.TCS","title":"TCS","text":"<p>               Bases: <code>NetworkAlgorithm</code></p> <p>Construct haplotype network using Statistical Parsimony (TCS algorithm).</p> <p>This implementation accurately reproduces the C++ PopART TCS algorithm: 1. Groups haplotypes by pairwise distances 2. Iteratively connects components at increasing distance levels 3. Infers intermediate sequences when distance &gt; 1 4. Uses scoring system to find optimal intermediates 5. Post-processes to collapse degree-2 vertices</p> <p>The TCS method uses a 95% parsimony criterion to determine which haplotypes can be connected with statistical confidence.</p> Source code in <code>src/pypopart/algorithms/tcs.py</code> <pre><code>class TCS(NetworkAlgorithm):\n    \"\"\"\n    Construct haplotype network using Statistical Parsimony (TCS algorithm).\n\n    This implementation accurately reproduces the C++ PopART TCS algorithm:\n    1. Groups haplotypes by pairwise distances\n    2. Iteratively connects components at increasing distance levels\n    3. Infers intermediate sequences when distance &gt; 1\n    4. Uses scoring system to find optimal intermediates\n    5. Post-processes to collapse degree-2 vertices\n\n    The TCS method uses a 95% parsimony criterion to determine which\n    haplotypes can be connected with statistical confidence.\n    \"\"\"\n\n    # Scoring constants from C++ implementation\n    BONUS = 20\n    SHORTCUTPENALTY = 10\n    LONGPENALTY = 5\n\n    def __init__(\n        self,\n        distance_method: str = 'hamming',\n        confidence: float = 0.95,\n        connection_limit: Optional[int] = None,\n        infer_intermediates: bool = True,\n        collapse_vertices: bool = True,\n        **kwargs,\n    ):\n        \"\"\"\n        Initialize TCS algorithm.\n\n        Parameters\n        ----------\n        distance_method :\n            Method for calculating distances (should be hamming).\n        confidence :\n            Confidence level for parsimony criterion (default 0.95).\n        connection_limit :\n            Maximum connection distance (auto-calculated if None).\n        infer_intermediates :\n            Whether to infer intermediate sequences (default True).\n        collapse_vertices :\n            Whether to collapse degree-2 vertices (default True).\n        **kwargs :\n            Additional parameters.\n        \"\"\"\n        super().__init__(distance_method, **kwargs)\n        self.confidence = confidence\n        self.connection_limit = connection_limit\n        self.infer_intermediates = infer_intermediates\n        self.collapse_vertices = collapse_vertices\n        self._intermediate_counter = 0\n\n        if distance_method not in ('hamming',):\n            import warnings\n\n            warnings.warn(\n                f\"TCS is designed for hamming distance. Using '{distance_method}' \"\n                'may not produce theoretically correct results.',\n                stacklevel=2,\n            )\n\n    def construct_network(\n        self, alignment: Alignment, distance_matrix: Optional[DistanceMatrix] = None\n    ) -&gt; HaplotypeNetwork:\n        \"\"\"\n        Construct TCS network from sequence alignment.\n\n        Implements the component-based connection algorithm from C++ TCS.cpp.\n\n        Parameters\n        ----------\n        alignment :\n            Multiple sequence alignment.\n        distance_matrix :\n            Optional pre-computed distance matrix.\n\n        Returns\n        -------\n            Haplotype network constructed using statistical parsimony.\n        \"\"\"\n        # Identify unique haplotypes\n        haplotypes = identify_haplotypes(alignment)\n\n        if len(haplotypes) == 0:\n            return HaplotypeNetwork()\n\n        if len(haplotypes) == 1:\n            network = HaplotypeNetwork()\n            network.add_haplotype(haplotypes[0])\n            return network\n\n        # Calculate distances between haplotypes\n        haplotype_dist_matrix = self._calculate_haplotype_distances(haplotypes)\n        self._distance_matrix = haplotype_dist_matrix\n\n        # Calculate connection limit if not provided\n        if self.connection_limit is None:\n            self.connection_limit = self._calculate_connection_limit(\n                alignment.length, len(haplotypes)\n            )\n\n        # Build network using component-based algorithm (matches C++ TCS.cpp)\n        network = self._build_network_with_components(\n            haplotypes, haplotype_dist_matrix, alignment.length\n        )\n\n        # Collapse degree-2 vertices (post-processing simplification)\n        if self.collapse_vertices:\n            network = self._collapse_degree2_vertices(network)\n\n        return network\n\n    def _calculate_connection_limit(\n        self, sequence_length: int, num_haplotypes: int\n    ) -&gt; int:\n        \"\"\"\n        Calculate maximum parsimony connection limit.\n\n        Uses the formula from Templeton et al. (1992) to estimate the\n        maximum number of mutational differences that can be explained\n        by parsimony at the specified confidence level.\n\n        Parameters\n        ----------\n        sequence_length :\n            Length of aligned sequences.\n        num_haplotypes :\n            Number of unique haplotypes.\n\n        Returns\n        -------\n            Maximum connection distance for parsimony criterion.\n        \"\"\"\n        connection_limit = 1\n        cumulative_prob = 0.0\n\n        for k in range(1, sequence_length + 1):\n            prob_k = self._poisson_probability(k, sequence_length, num_haplotypes)\n            cumulative_prob += prob_k\n\n            if cumulative_prob &gt;= (1 - self.confidence):\n                connection_limit = k\n                break\n\n        return max(1, connection_limit)\n\n    def _poisson_probability(self, k: int, seq_length: int, sample_size: int) -&gt; float:\n        \"\"\"\n        Calculate probability using Poisson distribution.\n\n        Parameters\n        ----------\n        k :\n            Number of mutations.\n        seq_length :\n            Sequence length.\n        sample_size :\n            Number of sequences.\n\n        Returns\n        -------\n            Probability.\n        \"\"\"\n        lambda_param = 2.0 * math.log(sample_size) if sample_size &gt; 1 else 1.0\n\n        try:\n            prob = (lambda_param**k) * math.exp(-lambda_param) / math.factorial(k)\n        except (OverflowError, ValueError):\n            prob = 0.0\n\n        return prob\n\n    def _calculate_haplotype_distances(self, haplotypes: List) -&gt; DistanceMatrix:\n        \"\"\"\n        Calculate pairwise distances between haplotypes.\n\n        Parameters\n        ----------\n        haplotypes :\n            List of Haplotype objects.\n\n        Returns\n        -------\n            DistanceMatrix with distances between haplotypes.\n        \"\"\"\n        import numpy as np\n\n        n = len(haplotypes)\n        labels = [h.id for h in haplotypes]\n        matrix = np.zeros((n, n))\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = hamming_distance(\n                    haplotypes[i].sequence,\n                    haplotypes[j].sequence,\n                    ignore_gaps=self.params.get('ignore_gaps', True),\n                )\n                matrix[i, j] = matrix[j, i] = dist\n\n        return DistanceMatrix(labels, matrix)\n\n    def _build_network_with_components(\n        self, haplotypes: List, distance_matrix: DistanceMatrix, sequence_length: int\n    ) -&gt; HaplotypeNetwork:\n        \"\"\"\n        Build network using component-based algorithm from C++ TCS.cpp.\n\n        This accurately reproduces the C++ logic:\n        1. Create all haplotypes as vertices, each in its own component\n        2. Group pairs by distance\n        3. For each distance level (1 to connection_limit):\n           - Process pairs at that distance\n           - Connect vertices from different components\n           - Infer intermediates for distance &gt; 1\n           - Merge components when connected\n        4. Clean up intermediate vertices in post-processing\n\n        Parameters\n        ----------\n        haplotypes :\n            List of Haplotype objects.\n        distance_matrix :\n            Distance matrix.\n        sequence_length :\n            Length of sequences for creating intermediates.\n\n        Returns\n        -------\n            Network with inferred intermediate sequences.\n        \"\"\"\n        # Initialize network with all haplotypes\n        network = HaplotypeNetwork()\n        for haplotype in haplotypes:\n            network.add_haplotype(haplotype)\n\n        # Component tracking: maps haplotype ID to component ID\n        # Each haplotype starts in its own component\n        component_ids: Dict[str, int] = {h.id: i for i, h in enumerate(haplotypes)}\n\n        # Group pairs by distance (like C++ VertContainer and priority queue)\n        pairs_by_distance: Dict[int, List[Tuple[str, str]]] = {}\n\n        for i, h1 in enumerate(haplotypes):\n            for j in range(i + 1, len(haplotypes)):\n                h2 = haplotypes[j]\n                dist = int(round(distance_matrix.get_distance(h1.id, h2.id)))\n\n                if dist &lt;= self.connection_limit:\n                    if dist not in pairs_by_distance:\n                        pairs_by_distance[dist] = []\n                    pairs_by_distance[dist].append((h1.id, h2.id))\n\n        # Process pairs in order of increasing distance (like C++ priority queue)\n        for M in sorted(pairs_by_distance.keys()):\n            # Keep processing this distance level until no more pairs remain\n            while M in pairs_by_distance and len(pairs_by_distance[M]) &gt; 0:\n                pairs = pairs_by_distance[M]\n\n                # Track which component pair we're working on\n                comp_a = -1\n                comp_b = -1\n                other_pairs = []\n\n                for u_id, v_id in pairs:\n                    comp_u = component_ids.get(u_id, -1)\n                    comp_v = component_ids.get(v_id, -1)\n\n                    # Skip if already in same component\n                    if comp_u == comp_v:\n                        continue\n\n                    # Ensure comp_u &lt; comp_v\n                    if comp_u &gt; comp_v:\n                        comp_u, comp_v = comp_v, comp_u\n                        u_id, v_id = v_id, u_id\n\n                    # Set component pair on first distinct pair\n                    if comp_a &lt; 0:\n                        comp_a = comp_u\n                        comp_b = comp_v\n\n                    # Process pairs for the current component pair\n                    if comp_u == comp_a and comp_v == comp_b:\n                        if M == 1:\n                            # Direct connection for distance 1\n                            network.add_edge(u_id, v_id, distance=1)\n                        else:\n                            # Infer intermediates for distance &gt; 1\n                            if self.infer_intermediates:\n                                self._add_connection_with_intermediates(\n                                    network,\n                                    u_id,\n                                    v_id,\n                                    M,\n                                    sequence_length,\n                                    component_ids,\n                                    comp_u,\n                                    comp_v,\n                                )\n                            else:\n                                # Simple connection without intermediates\n                                network.add_edge(u_id, v_id, distance=M)\n                    else:\n                        # Save for next iteration of this distance level\n                        other_pairs.append((u_id, v_id))\n\n                # Merge components (like C++ component renumbering)\n                if comp_a &gt;= 0:\n                    for hap_id in list(component_ids.keys()):\n                        if component_ids[hap_id] &lt; 0 or component_ids[hap_id] == comp_b:\n                            component_ids[hap_id] = comp_a\n                        elif component_ids[hap_id] &gt; comp_b:\n                            component_ids[hap_id] -= 1\n\n                # Update pairs for this distance level\n                if other_pairs:\n                    pairs_by_distance[M] = other_pairs\n                else:\n                    # No more pairs at this distance, remove from dict\n                    del pairs_by_distance[M]\n\n        return network\n\n    def _add_connection_with_intermediates(\n        self,\n        network: HaplotypeNetwork,\n        u_id: str,\n        v_id: str,\n        distance: int,\n        sequence_length: int,\n        component_ids: Dict[str, int],\n        comp_u: int,\n        comp_v: int,\n    ) -&gt; None:\n        \"\"\"\n        Add connection between u and v, inferring intermediates if needed.\n\n        Implements findIntermediates() and newCompositePath() from C++ TCS.cpp.\n\n        Parameters\n        ----------\n        network :\n            Current network.\n        u_id :\n            Source haplotype ID.\n        v_id :\n            Target haplotype ID.\n        distance :\n            Distance between u and v.\n        sequence_length :\n            Length of sequences.\n        component_ids :\n            Component membership tracker.\n        comp_u :\n            Component of u.\n        comp_v :\n            Component of v.\n        \"\"\"\n        # Find optimal intermediate vertices (like C++ findIntermediates)\n        int_u, int_v, min_path_length = self._find_intermediates(\n            network, u_id, v_id, distance, component_ids, comp_u, comp_v\n        )\n\n        # Check if path already exists\n        try:\n            existing_path_length = network.get_shortest_path_length(int_u, int_v)\n        except Exception:\n            existing_path_length = float('inf')\n\n        # Only add new path if it's shorter or doesn't exist\n        if (\n            existing_path_length == float('inf')\n            or existing_path_length &gt; min_path_length\n        ):\n            self._create_composite_path(\n                network, int_u, int_v, min_path_length, sequence_length, component_ids\n            )\n\n    def _find_intermediates(\n        self,\n        network: HaplotypeNetwork,\n        u_id: str,\n        v_id: str,\n        dist: int,\n        component_ids: Dict[str, int],\n        comp_u: int,\n        comp_v: int,\n    ) -&gt; Tuple[str, str, int]:\n        \"\"\"\n        Find optimal intermediate vertices to connect two components.\n\n        Implements C++ TCS::findIntermediates() with scoring system.\n\n        Parameters\n        ----------\n        network :\n            Current network.\n        u_id :\n            Source haplotype ID from component comp_u.\n        v_id :\n            Target haplotype ID from component comp_v.\n        dist :\n            Distance between components.\n        component_ids :\n            Component membership tracker.\n        comp_u :\n            Source component.\n        comp_v :\n            Target component.\n\n        Returns\n        -------\n            Tuple of (intermediate_u_id, intermediate_v_id, path_length).\n        \"\"\"\n        max_score = float('-inf')\n        min_path_length = dist\n        best_u = u_id\n        best_v = v_id\n\n        # Try all vertices in comp_u (or \"no man's land\" with comp_id &lt; 0)\n        for i_id in list(component_ids.keys()):\n            if (\n                component_ids.get(i_id, -1) != comp_u\n                and component_ids.get(i_id, -1) &gt;= 0\n            ):\n                continue\n\n            # Check if connected to u\n            try:\n                path_ui = network.get_shortest_path_length(u_id, i_id)\n            except Exception:\n                continue\n\n            if path_ui &gt;= dist:\n                continue\n\n            # Try all vertices in comp_v\n            for j_id in list(component_ids.keys()):\n                if (\n                    component_ids.get(j_id, -1) != comp_v\n                    and component_ids.get(j_id, -1) &gt;= 0\n                ):\n                    continue\n\n                # Check if connected to v\n                try:\n                    path_vj = network.get_shortest_path_length(v_id, j_id)\n                except Exception:\n                    continue\n\n                if path_vj + path_ui &gt;= dist:\n                    continue\n\n                dP = dist - path_vj - path_ui\n                score = self._compute_score(\n                    network, i_id, j_id, comp_u, comp_v, dP, dist, component_ids\n                )\n\n                # Select best scoring pair (or shortest path if tied)\n                if score &gt; max_score or (score == max_score and dP &lt; min_path_length):\n                    min_path_length = dP\n                    max_score = score\n                    best_u = i_id\n                    best_v = j_id\n\n        return best_u, best_v, min_path_length\n\n    def _compute_score(\n        self,\n        network: HaplotypeNetwork,\n        u_id: str,\n        v_id: str,\n        comp_u: int,\n        comp_v: int,\n        dP: int,\n        clust_dist: int,\n        component_ids: Dict[str, int],\n    ) -&gt; float:\n        \"\"\"\n        Compute score for intermediate pair using C++ scoring system.\n\n        Implements C++ TCS::computeScore().\n\n        Parameters\n        ----------\n        network :\n            Current network.\n        u_id :\n            Intermediate in component u.\n        v_id :\n            Intermediate in component v.\n        comp_u :\n            Component u.\n        comp_v :\n            Component v.\n        dP :\n            Path length between intermediates.\n        clust_dist :\n            Distance between original components.\n        component_ids :\n            Component membership tracker.\n\n        Returns\n        -------\n            Score for this intermediate pair.\n        \"\"\"\n        score = 0\n\n        # Get all original haplotypes (not intermediates)\n        original_haps = [\n            hap_id\n            for hap_id in component_ids.keys()\n            if not hap_id.startswith('intermediate_')\n        ]\n\n        for i_id in original_haps:\n            if component_ids.get(i_id, -1) != comp_u:\n                continue\n\n            for j_id in original_haps:\n                if component_ids.get(j_id, -1) != comp_v:\n                    continue\n\n                # Calculate total path through proposed intermediates\n                try:\n                    path_ui = network.get_shortest_path_length(u_id, i_id)\n                    path_vj = network.get_shortest_path_length(v_id, j_id)\n                    total_path = dP + path_ui + path_vj\n                except Exception:\n                    continue\n\n                # Get original distance\n                orig_dist = self._distance_matrix.get_distance(i_id, j_id)\n\n                # Score based on how well path matches original distance\n                if abs(total_path - orig_dist) &lt; 0.5:\n                    score += self.BONUS\n                elif total_path &gt; orig_dist:\n                    score -= self.LONGPENALTY\n                else:\n                    # Shortcut\n                    if total_path &lt; clust_dist:\n                        return float('-inf')  # Invalid\n                    else:\n                        score -= self.SHORTCUTPENALTY\n\n        return score\n\n    def _create_composite_path(\n        self,\n        network: HaplotypeNetwork,\n        start_id: str,\n        end_id: str,\n        distance: int,\n        sequence_length: int,\n        component_ids: Dict[str, int],\n    ) -&gt; None:\n        \"\"\"\n        Create path of intermediate vertices connecting start to end.\n\n        Implements C++ TCS::newCompositePath().\n\n        Parameters\n        ----------\n        network :\n            Current network.\n        start_id :\n            Starting vertex ID.\n        end_id :\n            Ending vertex ID.\n        distance :\n            Number of intermediates to create.\n        sequence_length :\n            Sequence length for intermediates.\n        component_ids :\n            Component membership tracker.\n        \"\"\"\n        current_id = start_id\n\n        # Create distance-1 intermediate vertices\n        for _i in range(1, distance):\n            intermediate_id = f'intermediate_{self._intermediate_counter}'\n            self._intermediate_counter += 1\n\n            # Create placeholder sequence\n            intermediate_seq = Sequence(\n                id=intermediate_id,\n                data='N' * sequence_length,\n                description='Inferred intermediate sequence',\n            )\n\n            intermediate_hap = Haplotype(\n                sequence=intermediate_seq,\n                sample_ids=[],\n            )\n\n            # Add to network\n            network.add_haplotype(intermediate_hap)\n            network.add_edge(current_id, intermediate_id, distance=1)\n\n            # Mark as \"no man's land\" (component ID = -1)\n            component_ids[intermediate_id] = -1\n\n            current_id = intermediate_id\n\n        # Connect last intermediate to end\n        network.add_edge(current_id, end_id, distance=1)\n\n    def _collapse_degree2_vertices(self, network: HaplotypeNetwork) -&gt; HaplotypeNetwork:\n        \"\"\"\n        Collapse vertices with degree 2 (post-processing simplification).\n\n        Implements C++ TCS post-processing that removes degree-2 vertices\n        connecting only two other vertices. This matches lines 161-194 of TCS.cpp.\n\n        Parameters\n        ----------\n        network :\n            Network with potential degree-2 vertices.\n\n        Returns\n        -------\n            Simplified network.\n        \"\"\"\n        # Process one vertex at a time (like C++ implementation)\n        # Keep looping until no more collapses possible\n        changed = True\n\n        while changed:\n            changed = False\n\n            # Find and collapse ONE degree-2 intermediate vertex\n            for hap_id in list(network.nodes):\n                # Skip if already removed\n                if not network.has_node(hap_id):\n                    continue\n\n                degree = network.get_degree(hap_id)\n\n                # Only collapse degree-2 vertices\n                if degree != 2:\n                    continue\n\n                neighbors = network.get_neighbors(hap_id)\n\n                if len(neighbors) != 2:\n                    continue\n\n                n1, n2 = neighbors\n\n                # Get edge weights\n                try:\n                    w1 = network.get_edge_distance(hap_id, n1)\n                    w2 = network.get_edge_distance(hap_id, n2)\n                except Exception:\n                    continue\n\n                # Only collapse intermediates (not original haplotypes)\n                # In C++ this checks if vertex index &gt;= nseqs (number of original sequences)\n                hap = network.get_haplotype(hap_id)\n                if hap.frequency == 0 or 'intermediate' in hap_id.lower():\n                    try:\n                        combined_weight = w1 + w2\n\n                        # Remove the intermediate vertex and its edges\n                        network.remove_haplotype(hap_id)\n\n                        # Add direct edge if it doesn't exist\n                        if not network.has_edge(n1, n2):\n                            network.add_edge(n1, n2, distance=combined_weight)\n\n                        # Mark that we made a change - restart loop\n                        changed = True\n                        break  # Exit for loop and restart while loop\n                    except Exception:\n                        # Skip if removal fails\n                        pass\n\n        return network\n\n    def get_parameters(self) -&gt; dict:\n        \"\"\"Get algorithm parameters.\"\"\"\n        params = super().get_parameters()\n        params['confidence'] = self.confidence\n        params['connection_limit'] = self.connection_limit\n        params['infer_intermediates'] = self.infer_intermediates\n        params['collapse_vertices'] = self.collapse_vertices\n        return params\n</code></pre>"},{"location":"api/algorithms/tcs/#pypopart.algorithms.tcs.TCS.__init__","title":"__init__","text":"<pre><code>__init__(\n    distance_method: str = \"hamming\",\n    confidence: float = 0.95,\n    connection_limit: Optional[int] = None,\n    infer_intermediates: bool = True,\n    collapse_vertices: bool = True,\n    **kwargs\n)\n</code></pre> <p>Initialize TCS algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>distance_method</code> <code>str</code> <p>Method for calculating distances (should be hamming).</p> <code>'hamming'</code> <code>confidence</code> <code>float</code> <p>Confidence level for parsimony criterion (default 0.95).</p> <code>0.95</code> <code>connection_limit</code> <code>Optional[int]</code> <p>Maximum connection distance (auto-calculated if None).</p> <code>None</code> <code>infer_intermediates</code> <code>bool</code> <p>Whether to infer intermediate sequences (default True).</p> <code>True</code> <code>collapse_vertices</code> <code>bool</code> <p>Whether to collapse degree-2 vertices (default True).</p> <code>True</code> <code>**kwargs</code> <p>Additional parameters.</p> <code>{}</code> Source code in <code>src/pypopart/algorithms/tcs.py</code> <pre><code>def __init__(\n    self,\n    distance_method: str = 'hamming',\n    confidence: float = 0.95,\n    connection_limit: Optional[int] = None,\n    infer_intermediates: bool = True,\n    collapse_vertices: bool = True,\n    **kwargs,\n):\n    \"\"\"\n    Initialize TCS algorithm.\n\n    Parameters\n    ----------\n    distance_method :\n        Method for calculating distances (should be hamming).\n    confidence :\n        Confidence level for parsimony criterion (default 0.95).\n    connection_limit :\n        Maximum connection distance (auto-calculated if None).\n    infer_intermediates :\n        Whether to infer intermediate sequences (default True).\n    collapse_vertices :\n        Whether to collapse degree-2 vertices (default True).\n    **kwargs :\n        Additional parameters.\n    \"\"\"\n    super().__init__(distance_method, **kwargs)\n    self.confidence = confidence\n    self.connection_limit = connection_limit\n    self.infer_intermediates = infer_intermediates\n    self.collapse_vertices = collapse_vertices\n    self._intermediate_counter = 0\n\n    if distance_method not in ('hamming',):\n        import warnings\n\n        warnings.warn(\n            f\"TCS is designed for hamming distance. Using '{distance_method}' \"\n            'may not produce theoretically correct results.',\n            stacklevel=2,\n        )\n</code></pre>"},{"location":"api/algorithms/tcs/#pypopart.algorithms.tcs.TCS.construct_network","title":"construct_network","text":"<pre><code>construct_network(\n    alignment: Alignment,\n    distance_matrix: Optional[DistanceMatrix] = None,\n) -&gt; HaplotypeNetwork\n</code></pre> <p>Construct TCS network from sequence alignment.</p> <p>Implements the component-based connection algorithm from C++ TCS.cpp.</p> <p>Parameters:</p> Name Type Description Default <code>alignment</code> <code>Alignment</code> <p>Multiple sequence alignment.</p> required <code>distance_matrix</code> <code>Optional[DistanceMatrix]</code> <p>Optional pre-computed distance matrix.</p> <code>None</code> <p>Returns:</p> Type Description <code>    Haplotype network constructed using statistical parsimony.</code> Source code in <code>src/pypopart/algorithms/tcs.py</code> <pre><code>def construct_network(\n    self, alignment: Alignment, distance_matrix: Optional[DistanceMatrix] = None\n) -&gt; HaplotypeNetwork:\n    \"\"\"\n    Construct TCS network from sequence alignment.\n\n    Implements the component-based connection algorithm from C++ TCS.cpp.\n\n    Parameters\n    ----------\n    alignment :\n        Multiple sequence alignment.\n    distance_matrix :\n        Optional pre-computed distance matrix.\n\n    Returns\n    -------\n        Haplotype network constructed using statistical parsimony.\n    \"\"\"\n    # Identify unique haplotypes\n    haplotypes = identify_haplotypes(alignment)\n\n    if len(haplotypes) == 0:\n        return HaplotypeNetwork()\n\n    if len(haplotypes) == 1:\n        network = HaplotypeNetwork()\n        network.add_haplotype(haplotypes[0])\n        return network\n\n    # Calculate distances between haplotypes\n    haplotype_dist_matrix = self._calculate_haplotype_distances(haplotypes)\n    self._distance_matrix = haplotype_dist_matrix\n\n    # Calculate connection limit if not provided\n    if self.connection_limit is None:\n        self.connection_limit = self._calculate_connection_limit(\n            alignment.length, len(haplotypes)\n        )\n\n    # Build network using component-based algorithm (matches C++ TCS.cpp)\n    network = self._build_network_with_components(\n        haplotypes, haplotype_dist_matrix, alignment.length\n    )\n\n    # Collapse degree-2 vertices (post-processing simplification)\n    if self.collapse_vertices:\n        network = self._collapse_degree2_vertices(network)\n\n    return network\n</code></pre>"},{"location":"api/algorithms/tcs/#pypopart.algorithms.tcs.TCS.get_parameters","title":"get_parameters","text":"<pre><code>get_parameters() -&gt; dict\n</code></pre> <p>Get algorithm parameters.</p> Source code in <code>src/pypopart/algorithms/tcs.py</code> <pre><code>def get_parameters(self) -&gt; dict:\n    \"\"\"Get algorithm parameters.\"\"\"\n    params = super().get_parameters()\n    params['confidence'] = self.confidence\n    params['connection_limit'] = self.connection_limit\n    params['infer_intermediates'] = self.infer_intermediates\n    params['collapse_vertices'] = self.collapse_vertices\n    return params\n</code></pre>"},{"location":"api/core/alignment/","title":"Alignment Module","text":"<p>Sequence alignment handling and analysis.</p>"},{"location":"api/core/alignment/#overview","title":"Overview","text":"<p>The <code>alignment</code> module provides the <code>Alignment</code> class for working with multiple sequence alignments.</p>"},{"location":"api/core/alignment/#classes","title":"Classes","text":""},{"location":"api/core/alignment/#pypopart.core.alignment","title":"pypopart.core.alignment","text":"<p>Multiple sequence alignment representation and analysis for PyPopART.</p>"},{"location":"api/core/alignment/#pypopart.core.alignment.AlignmentStats","title":"AlignmentStats  <code>dataclass</code>","text":"<p>Statistics about a multiple sequence alignment.</p> Source code in <code>src/pypopart/core/alignment.py</code> <pre><code>@dataclass\nclass AlignmentStats:\n    \"\"\"Statistics about a multiple sequence alignment.\"\"\"\n\n    length: int\n    num_sequences: int\n    total_gaps: int\n    gap_percentage: float\n    conserved_sites: int\n    variable_sites: int\n    parsimony_informative_sites: int\n    gc_content: float\n</code></pre>"},{"location":"api/core/alignment/#pypopart.core.alignment.Alignment","title":"Alignment","text":"<p>Represents a multiple sequence alignment.</p> <p>Provides methods for alignment analysis, validation, and manipulation.</p> Source code in <code>src/pypopart/core/alignment.py</code> <pre><code>class Alignment:\n    \"\"\"\n    Represents a multiple sequence alignment.\n\n    Provides methods for alignment analysis, validation, and manipulation.\n    \"\"\"\n\n    def __init__(self, sequences: Optional[List[Sequence]] = None):\n        \"\"\"\n        Initialize alignment with optional sequences.\n\n        Parameters\n        ----------\n        sequences :\n            List of Sequence objects.\n        \"\"\"\n        self._sequences: List[Sequence] = []\n        self._sequence_index: Dict[str, int] = {}\n\n        if sequences:\n            for seq in sequences:\n                self.add_sequence(seq)\n\n    def add_sequence(self, sequence: Sequence) -&gt; None:\n        \"\"\"\n        Add a sequence to the alignment.\n\n        Parameters\n        ----------\n        sequence :\n            Sequence object to add.\n\n        Raises :\n        ValueError :\n            If sequence ID already exists or length doesn't match.\n        \"\"\"\n        if sequence.id in self._sequence_index:\n            raise ValueError(f\"Sequence ID '{sequence.id}' already exists in alignment\")\n\n        # Check length consistency (if not first sequence)\n        if self._sequences and len(sequence) != self.length:\n            raise ValueError(\n                f\"Sequence length {len(sequence)} doesn't match alignment length {self.length}\"\n            )\n\n        self._sequence_index[sequence.id] = len(self._sequences)\n        self._sequences.append(sequence)\n\n    def remove_sequence(self, sequence_id: str) -&gt; None:\n        \"\"\"\n        Remove a sequence from the alignment.\n\n        Parameters\n        ----------\n        sequence_id :\n            ID of sequence to remove.\n\n        Raises :\n        KeyError :\n            If sequence ID not found.\n        \"\"\"\n        if sequence_id not in self._sequence_index:\n            raise KeyError(f\"Sequence ID '{sequence_id}' not found in alignment\")\n\n        index = self._sequence_index[sequence_id]\n        del self._sequences[index]\n\n        # Rebuild index\n        self._sequence_index = {seq.id: i for i, seq in enumerate(self._sequences)}\n\n    def get_sequence(self, sequence_id: str) -&gt; Sequence:\n        \"\"\"\n            Get sequence by ID.\n\n        Parameters\n        ----------\n            sequence_id :\n                ID of sequence to retrieve.\n\n        Returns\n        -------\n            Sequence object.\n\n            Raises :\n            KeyError :\n                If sequence ID not found.\n        \"\"\"\n        if sequence_id not in self._sequence_index:\n            raise KeyError(f\"Sequence ID '{sequence_id}' not found in alignment\")\n\n        index = self._sequence_index[sequence_id]\n        return self._sequences[index]\n\n    def __len__(self) -&gt; int:\n        \"\"\"Return number of sequences in alignment.\"\"\"\n        return len(self._sequences)\n\n    def __iter__(self) -&gt; Iterator[Sequence]:\n        \"\"\"Iterate over sequences in alignment.\"\"\"\n        return iter(self._sequences)\n\n    def __getitem__(self, key: Union[int, str, slice]) -&gt; Union[Sequence, 'Alignment']:\n        \"\"\"\n            Get sequence(s) by index, ID, or slice.\n\n        Parameters\n        ----------\n            key :\n                Index, sequence ID, or slice.\n\n        Returns\n        -------\n            Sequence object or new Alignment object for slices.\n        \"\"\"\n        if isinstance(key, str):\n            return self.get_sequence(key)\n        elif isinstance(key, int):\n            return self._sequences[key]\n        elif isinstance(key, slice):\n            return Alignment(self._sequences[key])\n        else:\n            raise TypeError(f'Invalid key type: {type(key)}')\n\n    @property\n    def length(self) -&gt; int:\n        \"\"\"Get alignment length (sequence length).\"\"\"\n        if not self._sequences:\n            return 0\n        return len(self._sequences[0])\n\n    @property\n    def sequence_ids(self) -&gt; List[str]:\n        \"\"\"Get list of sequence IDs.\"\"\"\n        return [seq.id for seq in self._sequences]\n\n    def is_valid(self) -&gt; bool:\n        \"\"\"\n        Check if alignment is valid (all sequences same length).\n\n        Returns\n        -------\n            True if all sequences have the same length.\n        \"\"\"\n        if not self._sequences:\n            return True\n\n        first_length = len(self._sequences[0])\n        return all(len(seq) == first_length for seq in self._sequences)\n\n    def validate(self) -&gt; None:\n        \"\"\"\n        Validate alignment and raise exception if invalid.\n\n        Raises\n        ------\n            ValueError: If alignment is invalid\n        \"\"\"\n        if not self.is_valid():\n            lengths = [len(seq) for seq in self._sequences]\n            raise ValueError(\n                f'Alignment invalid: sequences have different lengths {set(lengths)}'\n            )\n\n    def get_column(self, position: int) -&gt; List[str]:\n        \"\"\"\n            Get all characters at a specific position.\n\n        Parameters\n        ----------\n            position :\n                0-based position in alignment.\n\n        Returns\n        -------\n            List of characters at that position.\n        \"\"\"\n        if position &lt; 0 or position &gt;= self.length:\n            raise IndexError(f'Position {position} out of range [0, {self.length})')\n\n        return [seq.data[position] for seq in self._sequences]\n\n    def slice_alignment(self, start: int, end: Optional[int] = None) -&gt; 'Alignment':\n        \"\"\"\n            Extract a slice of the alignment (specific columns).\n\n        Parameters\n        ----------\n            start :\n                Start position (0-based, inclusive).\n            end :\n                End position (0-based, exclusive, None for end).\n\n        Returns\n        -------\n            New Alignment object with sliced sequences.\n        \"\"\"\n        sliced_sequences = []\n        for seq in self._sequences:\n            sliced_seq = seq.slice(start, end)\n            sliced_sequences.append(sliced_seq)\n\n        return Alignment(sliced_sequences)\n\n    def remove_gaps_columns(self, gap_threshold: float = 1.0) -&gt; 'Alignment':\n        \"\"\"\n            Remove columns with gaps above threshold.\n\n        Parameters\n        ----------\n            gap_threshold :\n                Fraction of gaps required to remove column (0.0-1.0).\n\n        Returns\n        -------\n            New Alignment object with gap columns removed.\n        \"\"\"\n        columns_to_keep = []\n\n        for pos in range(self.length):\n            column = self.get_column(pos)\n            gap_fraction = column.count('-') / len(column)\n\n            if gap_fraction &lt; gap_threshold:\n                columns_to_keep.append(pos)\n\n        # Build new sequences with kept columns\n        new_sequences = []\n        for seq in self._sequences:\n            new_data = ''.join(seq.data[pos] for pos in columns_to_keep)\n            new_seq = Sequence(\n                id=seq.id,\n                data=new_data,\n                metadata=seq.metadata.copy(),\n                description=seq.description,\n            )\n            new_sequences.append(new_seq)\n\n        return Alignment(new_sequences)\n\n    def calculate_stats(self) -&gt; AlignmentStats:\n        \"\"\"\n        Calculate comprehensive alignment statistics.\n\n        Returns\n        -------\n            AlignmentStats object with alignment metrics.\n        \"\"\"\n        if not self._sequences:\n            return AlignmentStats(0, 0, 0, 0.0, 0, 0, 0, 0.0)\n\n        length = self.length\n        num_sequences = len(self._sequences)\n\n        # Count gaps\n        total_gaps = sum(seq.count_gaps() for seq in self._sequences)\n        gap_percentage = (total_gaps / (length * num_sequences)) * 100\n\n        # Analyze sites\n        conserved_sites = 0\n        variable_sites = 0\n        parsimony_informative_sites = 0\n\n        for pos in range(length):\n            column = self.get_column(pos)\n            # Remove gaps for site analysis\n            column_no_gaps = [char for char in column if char != '-']\n\n            if not column_no_gaps:\n                continue\n\n            char_counts = Counter(column_no_gaps)\n            unique_chars = len(char_counts)\n\n            if unique_chars == 1:\n                conserved_sites += 1\n            else:\n                variable_sites += 1\n\n                # Parsimony informative: at least 2 different chars, each appearing \u22652 times\n                if sum(1 for count in char_counts.values() if count &gt;= 2) &gt;= 2:\n                    parsimony_informative_sites += 1\n\n        # Calculate overall GC content\n        all_bases = ''.join(seq.data.replace('-', '') for seq in self._sequences)\n        gc_count = all_bases.count('G') + all_bases.count('C') + all_bases.count('S')\n        total_bases = len(all_bases.replace('N', '').replace('?', ''))\n        gc_content = (gc_count / total_bases) * 100 if total_bases &gt; 0 else 0.0\n\n        return AlignmentStats(\n            length=length,\n            num_sequences=num_sequences,\n            total_gaps=total_gaps,\n            gap_percentage=gap_percentage,\n            conserved_sites=conserved_sites,\n            variable_sites=variable_sites,\n            parsimony_informative_sites=parsimony_informative_sites,\n            gc_content=gc_content,\n        )\n\n    def get_distance_matrix(self, distance_func=None) -&gt; np.ndarray:\n        \"\"\"\n            Calculate pairwise distance matrix between sequences.\n\n        Parameters\n        ----------\n            distance_func :\n                Function to calculate distance between two sequences.\n                              If None, uses Hamming distance.\n\n        Returns\n        -------\n            Square numpy array with pairwise distances.\n        \"\"\"\n        if distance_func is None:\n            distance_func = self._hamming_distance\n\n        n = len(self._sequences)\n        matrix = np.zeros((n, n))\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = distance_func(self._sequences[i], self._sequences[j])\n                matrix[i, j] = matrix[j, i] = dist\n\n        return matrix\n\n    def _hamming_distance(self, seq1: Sequence, seq2: Sequence) -&gt; int:\n        \"\"\"\n            Calculate Hamming distance between two sequences.\n\n        Parameters\n        ----------\n            seq1 :\n                First sequence.\n            seq2 :\n                Second sequence.\n\n        Returns\n        -------\n            Number of differing positions.\n        \"\"\"\n        if len(seq1) != len(seq2):\n            raise ValueError('Sequences must have same length for Hamming distance')\n\n        return sum(\n            c1 != c2 for c1, c2 in zip(seq1.data, seq2.data) if c1 != '-' and c2 != '-'\n        )\n\n    def identify_haplotypes(self) -&gt; Dict[str, List[str]]:\n        \"\"\"\n        Identify unique haplotypes and group sequences.\n\n        Returns\n        -------\n            Dictionary mapping unique sequence data to list of sequence IDs.\n        \"\"\"\n        haplotypes = {}\n\n        for seq in self._sequences:\n            # Use sequence without gaps as haplotype key\n            haplotype_key = seq.remove_gaps().data\n\n            if haplotype_key not in haplotypes:\n                haplotypes[haplotype_key] = []\n\n            haplotypes[haplotype_key].append(seq.id)\n\n        return haplotypes\n\n    def to_fasta(self) -&gt; str:\n        \"\"\"\n        Convert alignment to FASTA format string.\n\n        Returns\n        -------\n            FASTA formatted string.\n        \"\"\"\n        return '\\n'.join(str(seq) for seq in self._sequences)\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return string representation of alignment.\"\"\"\n        stats = self.calculate_stats()\n        return (\n            f'Alignment: {stats.num_sequences} sequences, '\n            f'{stats.length} positions, '\n            f'{stats.variable_sites} variable sites'\n        )\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Detailed representation of alignment.\"\"\"\n        return f'Alignment({len(self._sequences)} sequences, length={self.length})'\n</code></pre>"},{"location":"api/core/alignment/#pypopart.core.alignment.Alignment.length","title":"length  <code>property</code>","text":"<pre><code>length: int\n</code></pre> <p>Get alignment length (sequence length).</p>"},{"location":"api/core/alignment/#pypopart.core.alignment.Alignment.sequence_ids","title":"sequence_ids  <code>property</code>","text":"<pre><code>sequence_ids: List[str]\n</code></pre> <p>Get list of sequence IDs.</p>"},{"location":"api/core/alignment/#pypopart.core.alignment.Alignment.__init__","title":"__init__","text":"<pre><code>__init__(sequences: Optional[List[Sequence]] = None)\n</code></pre> <p>Initialize alignment with optional sequences.</p> <p>Parameters:</p> Name Type Description Default <code>sequences</code> <code>Optional[List[Sequence]]</code> <p>List of Sequence objects.</p> <code>None</code> Source code in <code>src/pypopart/core/alignment.py</code> <pre><code>def __init__(self, sequences: Optional[List[Sequence]] = None):\n    \"\"\"\n    Initialize alignment with optional sequences.\n\n    Parameters\n    ----------\n    sequences :\n        List of Sequence objects.\n    \"\"\"\n    self._sequences: List[Sequence] = []\n    self._sequence_index: Dict[str, int] = {}\n\n    if sequences:\n        for seq in sequences:\n            self.add_sequence(seq)\n</code></pre>"},{"location":"api/core/alignment/#pypopart.core.alignment.Alignment.add_sequence","title":"add_sequence","text":"<pre><code>add_sequence(sequence: Sequence) -&gt; None\n</code></pre> <p>Add a sequence to the alignment.</p> <p>Parameters:</p> Name Type Description Default <code>sequence</code> <code>Sequence</code> <p>Sequence object to add.</p> required <code>Raises</code> required <code>ValueError</code> <p>If sequence ID already exists or length doesn't match.</p> required Source code in <code>src/pypopart/core/alignment.py</code> <pre><code>def add_sequence(self, sequence: Sequence) -&gt; None:\n    \"\"\"\n    Add a sequence to the alignment.\n\n    Parameters\n    ----------\n    sequence :\n        Sequence object to add.\n\n    Raises :\n    ValueError :\n        If sequence ID already exists or length doesn't match.\n    \"\"\"\n    if sequence.id in self._sequence_index:\n        raise ValueError(f\"Sequence ID '{sequence.id}' already exists in alignment\")\n\n    # Check length consistency (if not first sequence)\n    if self._sequences and len(sequence) != self.length:\n        raise ValueError(\n            f\"Sequence length {len(sequence)} doesn't match alignment length {self.length}\"\n        )\n\n    self._sequence_index[sequence.id] = len(self._sequences)\n    self._sequences.append(sequence)\n</code></pre>"},{"location":"api/core/alignment/#pypopart.core.alignment.Alignment.remove_sequence","title":"remove_sequence","text":"<pre><code>remove_sequence(sequence_id: str) -&gt; None\n</code></pre> <p>Remove a sequence from the alignment.</p> <p>Parameters:</p> Name Type Description Default <code>sequence_id</code> <code>str</code> <p>ID of sequence to remove.</p> required <code>Raises</code> required <code>KeyError</code> <p>If sequence ID not found.</p> required Source code in <code>src/pypopart/core/alignment.py</code> <pre><code>def remove_sequence(self, sequence_id: str) -&gt; None:\n    \"\"\"\n    Remove a sequence from the alignment.\n\n    Parameters\n    ----------\n    sequence_id :\n        ID of sequence to remove.\n\n    Raises :\n    KeyError :\n        If sequence ID not found.\n    \"\"\"\n    if sequence_id not in self._sequence_index:\n        raise KeyError(f\"Sequence ID '{sequence_id}' not found in alignment\")\n\n    index = self._sequence_index[sequence_id]\n    del self._sequences[index]\n\n    # Rebuild index\n    self._sequence_index = {seq.id: i for i, seq in enumerate(self._sequences)}\n</code></pre>"},{"location":"api/core/alignment/#pypopart.core.alignment.Alignment.get_sequence","title":"get_sequence","text":"<pre><code>get_sequence(sequence_id: str) -&gt; Sequence\n</code></pre> <pre><code>Get sequence by ID.\n</code></pre> <p>Returns:</p> Type Description <code>    Sequence object.</code> <p>Raises : KeyError :     If sequence ID not found.</p> Source code in <code>src/pypopart/core/alignment.py</code> <pre><code>def get_sequence(self, sequence_id: str) -&gt; Sequence:\n    \"\"\"\n        Get sequence by ID.\n\n    Parameters\n    ----------\n        sequence_id :\n            ID of sequence to retrieve.\n\n    Returns\n    -------\n        Sequence object.\n\n        Raises :\n        KeyError :\n            If sequence ID not found.\n    \"\"\"\n    if sequence_id not in self._sequence_index:\n        raise KeyError(f\"Sequence ID '{sequence_id}' not found in alignment\")\n\n    index = self._sequence_index[sequence_id]\n    return self._sequences[index]\n</code></pre>"},{"location":"api/core/alignment/#pypopart.core.alignment.Alignment.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>Return number of sequences in alignment.</p> Source code in <code>src/pypopart/core/alignment.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Return number of sequences in alignment.\"\"\"\n    return len(self._sequences)\n</code></pre>"},{"location":"api/core/alignment/#pypopart.core.alignment.Alignment.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; Iterator[Sequence]\n</code></pre> <p>Iterate over sequences in alignment.</p> Source code in <code>src/pypopart/core/alignment.py</code> <pre><code>def __iter__(self) -&gt; Iterator[Sequence]:\n    \"\"\"Iterate over sequences in alignment.\"\"\"\n    return iter(self._sequences)\n</code></pre>"},{"location":"api/core/alignment/#pypopart.core.alignment.Alignment.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(\n    key: Union[int, str, slice],\n) -&gt; Union[Sequence, Alignment]\n</code></pre> <pre><code>Get sequence(s) by index, ID, or slice.\n</code></pre> <p>Returns:</p> Type Description <code>    Sequence object or new Alignment object for slices.</code> Source code in <code>src/pypopart/core/alignment.py</code> <pre><code>def __getitem__(self, key: Union[int, str, slice]) -&gt; Union[Sequence, 'Alignment']:\n    \"\"\"\n        Get sequence(s) by index, ID, or slice.\n\n    Parameters\n    ----------\n        key :\n            Index, sequence ID, or slice.\n\n    Returns\n    -------\n        Sequence object or new Alignment object for slices.\n    \"\"\"\n    if isinstance(key, str):\n        return self.get_sequence(key)\n    elif isinstance(key, int):\n        return self._sequences[key]\n    elif isinstance(key, slice):\n        return Alignment(self._sequences[key])\n    else:\n        raise TypeError(f'Invalid key type: {type(key)}')\n</code></pre>"},{"location":"api/core/alignment/#pypopart.core.alignment.Alignment.is_valid","title":"is_valid","text":"<pre><code>is_valid() -&gt; bool\n</code></pre> <p>Check if alignment is valid (all sequences same length).</p> <p>Returns:</p> Type Description <code>    True if all sequences have the same length.</code> Source code in <code>src/pypopart/core/alignment.py</code> <pre><code>def is_valid(self) -&gt; bool:\n    \"\"\"\n    Check if alignment is valid (all sequences same length).\n\n    Returns\n    -------\n        True if all sequences have the same length.\n    \"\"\"\n    if not self._sequences:\n        return True\n\n    first_length = len(self._sequences[0])\n    return all(len(seq) == first_length for seq in self._sequences)\n</code></pre>"},{"location":"api/core/alignment/#pypopart.core.alignment.Alignment.validate","title":"validate","text":"<pre><code>validate() -&gt; None\n</code></pre> <p>Validate alignment and raise exception if invalid.</p> <p>Raises:</p> Type Description <code>    ValueError: If alignment is invalid</code> Source code in <code>src/pypopart/core/alignment.py</code> <pre><code>def validate(self) -&gt; None:\n    \"\"\"\n    Validate alignment and raise exception if invalid.\n\n    Raises\n    ------\n        ValueError: If alignment is invalid\n    \"\"\"\n    if not self.is_valid():\n        lengths = [len(seq) for seq in self._sequences]\n        raise ValueError(\n            f'Alignment invalid: sequences have different lengths {set(lengths)}'\n        )\n</code></pre>"},{"location":"api/core/alignment/#pypopart.core.alignment.Alignment.get_column","title":"get_column","text":"<pre><code>get_column(position: int) -&gt; List[str]\n</code></pre> <pre><code>Get all characters at a specific position.\n</code></pre> <p>Returns:</p> Type Description <code>    List of characters at that position.</code> Source code in <code>src/pypopart/core/alignment.py</code> <pre><code>def get_column(self, position: int) -&gt; List[str]:\n    \"\"\"\n        Get all characters at a specific position.\n\n    Parameters\n    ----------\n        position :\n            0-based position in alignment.\n\n    Returns\n    -------\n        List of characters at that position.\n    \"\"\"\n    if position &lt; 0 or position &gt;= self.length:\n        raise IndexError(f'Position {position} out of range [0, {self.length})')\n\n    return [seq.data[position] for seq in self._sequences]\n</code></pre>"},{"location":"api/core/alignment/#pypopart.core.alignment.Alignment.slice_alignment","title":"slice_alignment","text":"<pre><code>slice_alignment(\n    start: int, end: Optional[int] = None\n) -&gt; Alignment\n</code></pre> <pre><code>Extract a slice of the alignment (specific columns).\n</code></pre> <p>Returns:</p> Type Description <code>    New Alignment object with sliced sequences.</code> Source code in <code>src/pypopart/core/alignment.py</code> <pre><code>def slice_alignment(self, start: int, end: Optional[int] = None) -&gt; 'Alignment':\n    \"\"\"\n        Extract a slice of the alignment (specific columns).\n\n    Parameters\n    ----------\n        start :\n            Start position (0-based, inclusive).\n        end :\n            End position (0-based, exclusive, None for end).\n\n    Returns\n    -------\n        New Alignment object with sliced sequences.\n    \"\"\"\n    sliced_sequences = []\n    for seq in self._sequences:\n        sliced_seq = seq.slice(start, end)\n        sliced_sequences.append(sliced_seq)\n\n    return Alignment(sliced_sequences)\n</code></pre>"},{"location":"api/core/alignment/#pypopart.core.alignment.Alignment.remove_gaps_columns","title":"remove_gaps_columns","text":"<pre><code>remove_gaps_columns(\n    gap_threshold: float = 1.0,\n) -&gt; Alignment\n</code></pre> <pre><code>Remove columns with gaps above threshold.\n</code></pre> <p>Returns:</p> Type Description <code>    New Alignment object with gap columns removed.</code> Source code in <code>src/pypopart/core/alignment.py</code> <pre><code>def remove_gaps_columns(self, gap_threshold: float = 1.0) -&gt; 'Alignment':\n    \"\"\"\n        Remove columns with gaps above threshold.\n\n    Parameters\n    ----------\n        gap_threshold :\n            Fraction of gaps required to remove column (0.0-1.0).\n\n    Returns\n    -------\n        New Alignment object with gap columns removed.\n    \"\"\"\n    columns_to_keep = []\n\n    for pos in range(self.length):\n        column = self.get_column(pos)\n        gap_fraction = column.count('-') / len(column)\n\n        if gap_fraction &lt; gap_threshold:\n            columns_to_keep.append(pos)\n\n    # Build new sequences with kept columns\n    new_sequences = []\n    for seq in self._sequences:\n        new_data = ''.join(seq.data[pos] for pos in columns_to_keep)\n        new_seq = Sequence(\n            id=seq.id,\n            data=new_data,\n            metadata=seq.metadata.copy(),\n            description=seq.description,\n        )\n        new_sequences.append(new_seq)\n\n    return Alignment(new_sequences)\n</code></pre>"},{"location":"api/core/alignment/#pypopart.core.alignment.Alignment.calculate_stats","title":"calculate_stats","text":"<pre><code>calculate_stats() -&gt; AlignmentStats\n</code></pre> <p>Calculate comprehensive alignment statistics.</p> <p>Returns:</p> Type Description <code>    AlignmentStats object with alignment metrics.</code> Source code in <code>src/pypopart/core/alignment.py</code> <pre><code>def calculate_stats(self) -&gt; AlignmentStats:\n    \"\"\"\n    Calculate comprehensive alignment statistics.\n\n    Returns\n    -------\n        AlignmentStats object with alignment metrics.\n    \"\"\"\n    if not self._sequences:\n        return AlignmentStats(0, 0, 0, 0.0, 0, 0, 0, 0.0)\n\n    length = self.length\n    num_sequences = len(self._sequences)\n\n    # Count gaps\n    total_gaps = sum(seq.count_gaps() for seq in self._sequences)\n    gap_percentage = (total_gaps / (length * num_sequences)) * 100\n\n    # Analyze sites\n    conserved_sites = 0\n    variable_sites = 0\n    parsimony_informative_sites = 0\n\n    for pos in range(length):\n        column = self.get_column(pos)\n        # Remove gaps for site analysis\n        column_no_gaps = [char for char in column if char != '-']\n\n        if not column_no_gaps:\n            continue\n\n        char_counts = Counter(column_no_gaps)\n        unique_chars = len(char_counts)\n\n        if unique_chars == 1:\n            conserved_sites += 1\n        else:\n            variable_sites += 1\n\n            # Parsimony informative: at least 2 different chars, each appearing \u22652 times\n            if sum(1 for count in char_counts.values() if count &gt;= 2) &gt;= 2:\n                parsimony_informative_sites += 1\n\n    # Calculate overall GC content\n    all_bases = ''.join(seq.data.replace('-', '') for seq in self._sequences)\n    gc_count = all_bases.count('G') + all_bases.count('C') + all_bases.count('S')\n    total_bases = len(all_bases.replace('N', '').replace('?', ''))\n    gc_content = (gc_count / total_bases) * 100 if total_bases &gt; 0 else 0.0\n\n    return AlignmentStats(\n        length=length,\n        num_sequences=num_sequences,\n        total_gaps=total_gaps,\n        gap_percentage=gap_percentage,\n        conserved_sites=conserved_sites,\n        variable_sites=variable_sites,\n        parsimony_informative_sites=parsimony_informative_sites,\n        gc_content=gc_content,\n    )\n</code></pre>"},{"location":"api/core/alignment/#pypopart.core.alignment.Alignment.get_distance_matrix","title":"get_distance_matrix","text":"<pre><code>get_distance_matrix(distance_func=None) -&gt; np.ndarray\n</code></pre> <pre><code>Calculate pairwise distance matrix between sequences.\n</code></pre> <p>Returns:</p> Type Description <code>    Square numpy array with pairwise distances.</code> Source code in <code>src/pypopart/core/alignment.py</code> <pre><code>def get_distance_matrix(self, distance_func=None) -&gt; np.ndarray:\n    \"\"\"\n        Calculate pairwise distance matrix between sequences.\n\n    Parameters\n    ----------\n        distance_func :\n            Function to calculate distance between two sequences.\n                          If None, uses Hamming distance.\n\n    Returns\n    -------\n        Square numpy array with pairwise distances.\n    \"\"\"\n    if distance_func is None:\n        distance_func = self._hamming_distance\n\n    n = len(self._sequences)\n    matrix = np.zeros((n, n))\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = distance_func(self._sequences[i], self._sequences[j])\n            matrix[i, j] = matrix[j, i] = dist\n\n    return matrix\n</code></pre>"},{"location":"api/core/alignment/#pypopart.core.alignment.Alignment.identify_haplotypes","title":"identify_haplotypes","text":"<pre><code>identify_haplotypes() -&gt; Dict[str, List[str]]\n</code></pre> <p>Identify unique haplotypes and group sequences.</p> <p>Returns:</p> Type Description <code>    Dictionary mapping unique sequence data to list of sequence IDs.</code> Source code in <code>src/pypopart/core/alignment.py</code> <pre><code>def identify_haplotypes(self) -&gt; Dict[str, List[str]]:\n    \"\"\"\n    Identify unique haplotypes and group sequences.\n\n    Returns\n    -------\n        Dictionary mapping unique sequence data to list of sequence IDs.\n    \"\"\"\n    haplotypes = {}\n\n    for seq in self._sequences:\n        # Use sequence without gaps as haplotype key\n        haplotype_key = seq.remove_gaps().data\n\n        if haplotype_key not in haplotypes:\n            haplotypes[haplotype_key] = []\n\n        haplotypes[haplotype_key].append(seq.id)\n\n    return haplotypes\n</code></pre>"},{"location":"api/core/alignment/#pypopart.core.alignment.Alignment.to_fasta","title":"to_fasta","text":"<pre><code>to_fasta() -&gt; str\n</code></pre> <p>Convert alignment to FASTA format string.</p> <p>Returns:</p> Type Description <code>    FASTA formatted string.</code> Source code in <code>src/pypopart/core/alignment.py</code> <pre><code>def to_fasta(self) -&gt; str:\n    \"\"\"\n    Convert alignment to FASTA format string.\n\n    Returns\n    -------\n        FASTA formatted string.\n    \"\"\"\n    return '\\n'.join(str(seq) for seq in self._sequences)\n</code></pre>"},{"location":"api/core/alignment/#pypopart.core.alignment.Alignment.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return string representation of alignment.</p> Source code in <code>src/pypopart/core/alignment.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return string representation of alignment.\"\"\"\n    stats = self.calculate_stats()\n    return (\n        f'Alignment: {stats.num_sequences} sequences, '\n        f'{stats.length} positions, '\n        f'{stats.variable_sites} variable sites'\n    )\n</code></pre>"},{"location":"api/core/alignment/#pypopart.core.alignment.Alignment.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Detailed representation of alignment.</p> Source code in <code>src/pypopart/core/alignment.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Detailed representation of alignment.\"\"\"\n    return f'Alignment({len(self._sequences)} sequences, length={self.length})'\n</code></pre>"},{"location":"api/core/distance/","title":"Distance Module","text":"<p>Genetic distance calculations with multiple evolutionary models.</p>"},{"location":"api/core/distance/#overview","title":"Overview","text":"<p>The <code>distance</code> module implements various distance metrics:</p> <ul> <li>Hamming distance: Simple pairwise differences</li> <li>Jukes-Cantor: Corrects for multiple substitutions</li> <li>Kimura 2-parameter (K2P): Distinguishes transitions/transversions</li> <li>Tamura-Nei: Accounts for unequal base frequencies</li> </ul>"},{"location":"api/core/distance/#classes","title":"Classes","text":""},{"location":"api/core/distance/#pypopart.core.distance","title":"pypopart.core.distance","text":"<p>Distance calculation and metrics for PyPopART.</p> <p>Implements various distance metrics for DNA sequences including Hamming distance and evolutionary models.</p>"},{"location":"api/core/distance/#pypopart.core.distance.DistanceMatrix","title":"DistanceMatrix","text":"<p>Store and manage pairwise distance matrix.</p> Source code in <code>src/pypopart/core/distance.py</code> <pre><code>class DistanceMatrix:\n    \"\"\"Store and manage pairwise distance matrix.\"\"\"\n\n    def __init__(self, labels: List[str], matrix: Optional[np.ndarray] = None):\n        \"\"\"Initialize distance matrix.\"\"\"\n        self.labels = labels\n        self.n = len(labels)\n        self._label_index = {label: i for i, label in enumerate(labels)}\n\n        if matrix is not None:\n            if matrix.shape != (self.n, self.n):\n                raise ValueError(\n                    f\"Matrix shape {matrix.shape} doesn't match labels {self.n}\"\n                )\n            self.matrix = matrix\n        else:\n            self.matrix = np.zeros((self.n, self.n))\n\n    def get_distance(self, label1: str, label2: str) -&gt; float:\n        \"\"\"Get distance between two sequences by label.\"\"\"\n        i = self._label_index[label1]\n        j = self._label_index[label2]\n        return self.matrix[i, j]\n\n    def set_distance(self, label1: str, label2: str, distance: float) -&gt; None:\n        \"\"\"Set distance between two sequences.\"\"\"\n        i = self._label_index[label1]\n        j = self._label_index[label2]\n        self.matrix[i, j] = distance\n        self.matrix[j, i] = distance\n\n    def get_row(self, label: str) -&gt; np.ndarray:\n        \"\"\"Get all distances for a sequence.\"\"\"\n        i = self._label_index[label]\n        return self.matrix[i, :]\n\n    def get_min_distance(self, exclude_zero: bool = True) -&gt; float:\n        \"\"\"Get minimum distance in matrix.\"\"\"\n        if exclude_zero:\n            mask = np.triu(np.ones_like(self.matrix, dtype=bool), k=1)\n            return self.matrix[mask].min()\n        else:\n            return self.matrix.min()\n\n    def get_max_distance(self) -&gt; float:\n        \"\"\"Get maximum distance in matrix.\"\"\"\n        return self.matrix.max()\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Convert matrix to dictionary representation.\"\"\"\n        return {'labels': self.labels, 'matrix': self.matrix.tolist()}\n\n    @classmethod\n    def from_dict(cls, data: dict) -&gt; 'DistanceMatrix':\n        \"\"\"Create distance matrix from dictionary.\"\"\"\n        return cls(labels=data['labels'], matrix=np.array(data['matrix']))\n\n    def visualize(\n        self,\n        title: str = 'Distance Matrix',\n        cmap: str = 'viridis',\n        figsize: Optional[Tuple[int, int]] = None,\n        show_values: bool = True,\n        save_path: Optional[str] = None,\n    ) -&gt; 'matplotlib.figure.Figure':\n        \"\"\"\n            Visualize distance matrix as a heatmap.\n\n        Parameters\n        ----------\n            title :\n                Plot title.\n            cmap :\n                Matplotlib colormap name.\n            figsize :\n                Figure size (width, height), auto-calculated if None.\n            show_values :\n                Whether to show distance values in cells.\n            save_path :\n                Optional path to save figure.\n\n        Returns\n        -------\n            Matplotlib figure object.\n\n            Raises :\n            ImportError :\n                If matplotlib is not installed.\n        \"\"\"\n        try:\n            import matplotlib.pyplot as plt\n        except ImportError:\n            raise ImportError(\n                'Matplotlib is required for visualization. '\n                'Install it with: pip install matplotlib'\n            ) from None\n\n        # Auto-calculate figure size based on matrix size\n        if figsize is None:\n            size = max(8, min(20, self.n * 0.5))\n            figsize = (size, size)\n\n        fig, ax = plt.subplots(figsize=figsize)\n\n        # Create heatmap\n        im = ax.imshow(self.matrix, cmap=cmap, aspect='auto')\n\n        # Set ticks and labels\n        ax.set_xticks(np.arange(self.n))\n        ax.set_yticks(np.arange(self.n))\n        ax.set_xticklabels(self.labels, rotation=45, ha='right')\n        ax.set_yticklabels(self.labels)\n\n        # Add colorbar\n        cbar = plt.colorbar(im, ax=ax)\n        cbar.set_label('Distance', rotation=270, labelpad=15)\n\n        # Show values in cells if requested and matrix is not too large\n        if show_values and self.n &lt;= 20:\n            for i in range(self.n):\n                for j in range(self.n):\n                    value = self.matrix[i, j]\n                    if np.isfinite(value):\n                        text_color = (\n                            'white' if value &gt; self.matrix.max() * 0.5 else 'black'\n                        )\n                        ax.text(\n                            j,\n                            i,\n                            f'{value:.2f}',\n                            ha='center',\n                            va='center',\n                            color=text_color,\n                            fontsize=8,\n                        )\n\n        ax.set_title(title)\n        fig.tight_layout()\n\n        if save_path:\n            fig.savefig(save_path, dpi=300, bbox_inches='tight')\n\n        return fig\n\n    def to_csv(self, filepath: str, delimiter: str = ',') -&gt; None:\n        \"\"\"\n        Export distance matrix to CSV file.\n\n        Parameters\n        ----------\n        filepath :\n            Path to output CSV file.\n        delimiter :\n            Delimiter character (default: comma).\n        \"\"\"\n        with open(filepath, 'w') as f:\n            # Write header\n            f.write(delimiter.join([''] + self.labels) + '\\n')\n\n            # Write data rows\n            for i, label in enumerate(self.labels):\n                row_data = [label] + [f'{val:.6f}' for val in self.matrix[i]]\n                f.write(delimiter.join(row_data) + '\\n')\n\n    @classmethod\n    def from_csv(cls, filepath: str, delimiter: str = ',') -&gt; 'DistanceMatrix':\n        \"\"\"\n            Import distance matrix from CSV file.\n\n        Parameters\n        ----------\n            filepath :\n                Path to CSV file.\n            delimiter :\n                Delimiter character (default: comma).\n\n        Returns\n        -------\n            DistanceMatrix object.\n        \"\"\"\n        with open(filepath, 'r') as f:\n            lines = [line.strip() for line in f if line.strip()]\n\n        # Parse header (column labels)\n        header = lines[0].split(delimiter)\n        labels = header[1:]  # Skip first empty cell\n\n        # Parse data\n        n = len(labels)\n        matrix = np.zeros((n, n))\n\n        for i, line in enumerate(lines[1:]):\n            parts = line.split(delimiter)\n            parts[0]\n            values = [float(v) for v in parts[1:]]\n            matrix[i] = values\n\n        return cls(labels, matrix)\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return string representation.\"\"\"\n        return f'DistanceMatrix({self.n} sequences)'\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Detailed representation.\"\"\"\n        return f'DistanceMatrix(n={self.n}, min={self.get_min_distance():.4f}, max={self.get_max_distance():.4f})'\n</code></pre>"},{"location":"api/core/distance/#pypopart.core.distance.DistanceMatrix.__init__","title":"__init__","text":"<pre><code>__init__(\n    labels: List[str], matrix: Optional[ndarray] = None\n)\n</code></pre> <p>Initialize distance matrix.</p> Source code in <code>src/pypopart/core/distance.py</code> <pre><code>def __init__(self, labels: List[str], matrix: Optional[np.ndarray] = None):\n    \"\"\"Initialize distance matrix.\"\"\"\n    self.labels = labels\n    self.n = len(labels)\n    self._label_index = {label: i for i, label in enumerate(labels)}\n\n    if matrix is not None:\n        if matrix.shape != (self.n, self.n):\n            raise ValueError(\n                f\"Matrix shape {matrix.shape} doesn't match labels {self.n}\"\n            )\n        self.matrix = matrix\n    else:\n        self.matrix = np.zeros((self.n, self.n))\n</code></pre>"},{"location":"api/core/distance/#pypopart.core.distance.DistanceMatrix.get_distance","title":"get_distance","text":"<pre><code>get_distance(label1: str, label2: str) -&gt; float\n</code></pre> <p>Get distance between two sequences by label.</p> Source code in <code>src/pypopart/core/distance.py</code> <pre><code>def get_distance(self, label1: str, label2: str) -&gt; float:\n    \"\"\"Get distance between two sequences by label.\"\"\"\n    i = self._label_index[label1]\n    j = self._label_index[label2]\n    return self.matrix[i, j]\n</code></pre>"},{"location":"api/core/distance/#pypopart.core.distance.DistanceMatrix.set_distance","title":"set_distance","text":"<pre><code>set_distance(\n    label1: str, label2: str, distance: float\n) -&gt; None\n</code></pre> <p>Set distance between two sequences.</p> Source code in <code>src/pypopart/core/distance.py</code> <pre><code>def set_distance(self, label1: str, label2: str, distance: float) -&gt; None:\n    \"\"\"Set distance between two sequences.\"\"\"\n    i = self._label_index[label1]\n    j = self._label_index[label2]\n    self.matrix[i, j] = distance\n    self.matrix[j, i] = distance\n</code></pre>"},{"location":"api/core/distance/#pypopart.core.distance.DistanceMatrix.get_row","title":"get_row","text":"<pre><code>get_row(label: str) -&gt; np.ndarray\n</code></pre> <p>Get all distances for a sequence.</p> Source code in <code>src/pypopart/core/distance.py</code> <pre><code>def get_row(self, label: str) -&gt; np.ndarray:\n    \"\"\"Get all distances for a sequence.\"\"\"\n    i = self._label_index[label]\n    return self.matrix[i, :]\n</code></pre>"},{"location":"api/core/distance/#pypopart.core.distance.DistanceMatrix.get_min_distance","title":"get_min_distance","text":"<pre><code>get_min_distance(exclude_zero: bool = True) -&gt; float\n</code></pre> <p>Get minimum distance in matrix.</p> Source code in <code>src/pypopart/core/distance.py</code> <pre><code>def get_min_distance(self, exclude_zero: bool = True) -&gt; float:\n    \"\"\"Get minimum distance in matrix.\"\"\"\n    if exclude_zero:\n        mask = np.triu(np.ones_like(self.matrix, dtype=bool), k=1)\n        return self.matrix[mask].min()\n    else:\n        return self.matrix.min()\n</code></pre>"},{"location":"api/core/distance/#pypopart.core.distance.DistanceMatrix.get_max_distance","title":"get_max_distance","text":"<pre><code>get_max_distance() -&gt; float\n</code></pre> <p>Get maximum distance in matrix.</p> Source code in <code>src/pypopart/core/distance.py</code> <pre><code>def get_max_distance(self) -&gt; float:\n    \"\"\"Get maximum distance in matrix.\"\"\"\n    return self.matrix.max()\n</code></pre>"},{"location":"api/core/distance/#pypopart.core.distance.DistanceMatrix.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Convert matrix to dictionary representation.</p> Source code in <code>src/pypopart/core/distance.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Convert matrix to dictionary representation.\"\"\"\n    return {'labels': self.labels, 'matrix': self.matrix.tolist()}\n</code></pre>"},{"location":"api/core/distance/#pypopart.core.distance.DistanceMatrix.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: dict) -&gt; DistanceMatrix\n</code></pre> <p>Create distance matrix from dictionary.</p> Source code in <code>src/pypopart/core/distance.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: dict) -&gt; 'DistanceMatrix':\n    \"\"\"Create distance matrix from dictionary.\"\"\"\n    return cls(labels=data['labels'], matrix=np.array(data['matrix']))\n</code></pre>"},{"location":"api/core/distance/#pypopart.core.distance.DistanceMatrix.visualize","title":"visualize","text":"<pre><code>visualize(\n    title: str = \"Distance Matrix\",\n    cmap: str = \"viridis\",\n    figsize: Optional[Tuple[int, int]] = None,\n    show_values: bool = True,\n    save_path: Optional[str] = None,\n) -&gt; matplotlib.figure.Figure\n</code></pre> <pre><code>Visualize distance matrix as a heatmap.\n</code></pre> <p>Returns:</p> Type Description <code>    Matplotlib figure object.</code> <p>Raises : ImportError :     If matplotlib is not installed.</p> Source code in <code>src/pypopart/core/distance.py</code> <pre><code>def visualize(\n    self,\n    title: str = 'Distance Matrix',\n    cmap: str = 'viridis',\n    figsize: Optional[Tuple[int, int]] = None,\n    show_values: bool = True,\n    save_path: Optional[str] = None,\n) -&gt; 'matplotlib.figure.Figure':\n    \"\"\"\n        Visualize distance matrix as a heatmap.\n\n    Parameters\n    ----------\n        title :\n            Plot title.\n        cmap :\n            Matplotlib colormap name.\n        figsize :\n            Figure size (width, height), auto-calculated if None.\n        show_values :\n            Whether to show distance values in cells.\n        save_path :\n            Optional path to save figure.\n\n    Returns\n    -------\n        Matplotlib figure object.\n\n        Raises :\n        ImportError :\n            If matplotlib is not installed.\n    \"\"\"\n    try:\n        import matplotlib.pyplot as plt\n    except ImportError:\n        raise ImportError(\n            'Matplotlib is required for visualization. '\n            'Install it with: pip install matplotlib'\n        ) from None\n\n    # Auto-calculate figure size based on matrix size\n    if figsize is None:\n        size = max(8, min(20, self.n * 0.5))\n        figsize = (size, size)\n\n    fig, ax = plt.subplots(figsize=figsize)\n\n    # Create heatmap\n    im = ax.imshow(self.matrix, cmap=cmap, aspect='auto')\n\n    # Set ticks and labels\n    ax.set_xticks(np.arange(self.n))\n    ax.set_yticks(np.arange(self.n))\n    ax.set_xticklabels(self.labels, rotation=45, ha='right')\n    ax.set_yticklabels(self.labels)\n\n    # Add colorbar\n    cbar = plt.colorbar(im, ax=ax)\n    cbar.set_label('Distance', rotation=270, labelpad=15)\n\n    # Show values in cells if requested and matrix is not too large\n    if show_values and self.n &lt;= 20:\n        for i in range(self.n):\n            for j in range(self.n):\n                value = self.matrix[i, j]\n                if np.isfinite(value):\n                    text_color = (\n                        'white' if value &gt; self.matrix.max() * 0.5 else 'black'\n                    )\n                    ax.text(\n                        j,\n                        i,\n                        f'{value:.2f}',\n                        ha='center',\n                        va='center',\n                        color=text_color,\n                        fontsize=8,\n                    )\n\n    ax.set_title(title)\n    fig.tight_layout()\n\n    if save_path:\n        fig.savefig(save_path, dpi=300, bbox_inches='tight')\n\n    return fig\n</code></pre>"},{"location":"api/core/distance/#pypopart.core.distance.DistanceMatrix.to_csv","title":"to_csv","text":"<pre><code>to_csv(filepath: str, delimiter: str = ',') -&gt; None\n</code></pre> <p>Export distance matrix to CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to output CSV file.</p> required <code>delimiter</code> <code>str</code> <p>Delimiter character (default: comma).</p> <code>','</code> Source code in <code>src/pypopart/core/distance.py</code> <pre><code>def to_csv(self, filepath: str, delimiter: str = ',') -&gt; None:\n    \"\"\"\n    Export distance matrix to CSV file.\n\n    Parameters\n    ----------\n    filepath :\n        Path to output CSV file.\n    delimiter :\n        Delimiter character (default: comma).\n    \"\"\"\n    with open(filepath, 'w') as f:\n        # Write header\n        f.write(delimiter.join([''] + self.labels) + '\\n')\n\n        # Write data rows\n        for i, label in enumerate(self.labels):\n            row_data = [label] + [f'{val:.6f}' for val in self.matrix[i]]\n            f.write(delimiter.join(row_data) + '\\n')\n</code></pre>"},{"location":"api/core/distance/#pypopart.core.distance.DistanceMatrix.from_csv","title":"from_csv  <code>classmethod</code>","text":"<pre><code>from_csv(\n    filepath: str, delimiter: str = \",\"\n) -&gt; DistanceMatrix\n</code></pre> <pre><code>Import distance matrix from CSV file.\n</code></pre> <p>Returns:</p> Type Description <code>    DistanceMatrix object.</code> Source code in <code>src/pypopart/core/distance.py</code> <pre><code>@classmethod\ndef from_csv(cls, filepath: str, delimiter: str = ',') -&gt; 'DistanceMatrix':\n    \"\"\"\n        Import distance matrix from CSV file.\n\n    Parameters\n    ----------\n        filepath :\n            Path to CSV file.\n        delimiter :\n            Delimiter character (default: comma).\n\n    Returns\n    -------\n        DistanceMatrix object.\n    \"\"\"\n    with open(filepath, 'r') as f:\n        lines = [line.strip() for line in f if line.strip()]\n\n    # Parse header (column labels)\n    header = lines[0].split(delimiter)\n    labels = header[1:]  # Skip first empty cell\n\n    # Parse data\n    n = len(labels)\n    matrix = np.zeros((n, n))\n\n    for i, line in enumerate(lines[1:]):\n        parts = line.split(delimiter)\n        parts[0]\n        values = [float(v) for v in parts[1:]]\n        matrix[i] = values\n\n    return cls(labels, matrix)\n</code></pre>"},{"location":"api/core/distance/#pypopart.core.distance.DistanceMatrix.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return string representation.</p> Source code in <code>src/pypopart/core/distance.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return string representation.\"\"\"\n    return f'DistanceMatrix({self.n} sequences)'\n</code></pre>"},{"location":"api/core/distance/#pypopart.core.distance.DistanceMatrix.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Detailed representation.</p> Source code in <code>src/pypopart/core/distance.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Detailed representation.\"\"\"\n    return f'DistanceMatrix(n={self.n}, min={self.get_min_distance():.4f}, max={self.get_max_distance():.4f})'\n</code></pre>"},{"location":"api/core/distance/#pypopart.core.distance.DistanceCalculator","title":"DistanceCalculator","text":"<p>Convenience class for calculating distance matrices.</p> <p>Provides a simple interface for distance calculation with different evolutionary models.</p> Source code in <code>src/pypopart/core/distance.py</code> <pre><code>class DistanceCalculator:\n    \"\"\"\n    Convenience class for calculating distance matrices.\n\n    Provides a simple interface for distance calculation with\n    different evolutionary models.\n    \"\"\"\n\n    def __init__(self, method: str = 'hamming', ignore_gaps: bool = True):\n        \"\"\"\n        Initialize distance calculator.\n\n        Parameters\n        ----------\n        method :\n            str.\n            Distance method: 'hamming', 'jc', 'k2p', 'tamura_nei'.\n        ignore_gaps :\n            bool.\n            Whether to ignore gaps in calculations.\n        \"\"\"\n        self.method = method.lower()\n        self.ignore_gaps = ignore_gaps\n\n        # Map method names to functions\n        if self.method == 'hamming':\n            self.distance_func = hamming_distance\n        elif self.method in ('jc', 'jukes_cantor', 'jukes-cantor'):\n            self.distance_func = jukes_cantor_distance\n        elif self.method in ('k2p', 'kimura', 'kimura_2p'):\n            self.distance_func = kimura_2p_distance\n        elif self.method in ('tn', 'tamura_nei', 'tamura-nei'):\n            self.distance_func = tamura_nei_distance\n        elif self.method == 'p':\n            self.distance_func = p_distance\n        else:\n            raise ValueError(f'Unknown distance method: {method}')\n\n    def calculate(self, seq1: Sequence, seq2: Sequence) -&gt; float:\n        \"\"\"\n        Calculate distance between two sequences.\n\n        Parameters\n        ----------\n        seq1 :\n            Sequence.\n            First sequence.\n        seq2 :\n            Sequence.\n            Second sequence.\n\n        Returns\n        -------\n            float            Distance value.\n        \"\"\"\n        return self.distance_func(seq1, seq2, ignore_gaps=self.ignore_gaps)\n\n    def calculate_matrix(self, alignment: Alignment) -&gt; np.ndarray:\n        \"\"\"\n        Calculate pairwise distance matrix for alignment.\n\n        Parameters\n        ----------\n        alignment :\n            Alignment.\n            Sequence alignment.\n\n        Returns\n        -------\n            np.ndarray            Square distance matrix.\n        \"\"\"\n        dist_matrix = calculate_pairwise_distances(\n            alignment, method=self.method, ignore_gaps=self.ignore_gaps\n        )\n        return dist_matrix.matrix\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return detailed string representation.\"\"\"\n        return f\"DistanceCalculator(method='{self.method}', ignore_gaps={self.ignore_gaps})\"\n</code></pre>"},{"location":"api/core/distance/#pypopart.core.distance.DistanceCalculator.__init__","title":"__init__","text":"<pre><code>__init__(method: str = 'hamming', ignore_gaps: bool = True)\n</code></pre> <p>Initialize distance calculator.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>str. Distance method: 'hamming', 'jc', 'k2p', 'tamura_nei'.</p> <code>'hamming'</code> <code>ignore_gaps</code> <code>bool</code> <p>bool. Whether to ignore gaps in calculations.</p> <code>True</code> Source code in <code>src/pypopart/core/distance.py</code> <pre><code>def __init__(self, method: str = 'hamming', ignore_gaps: bool = True):\n    \"\"\"\n    Initialize distance calculator.\n\n    Parameters\n    ----------\n    method :\n        str.\n        Distance method: 'hamming', 'jc', 'k2p', 'tamura_nei'.\n    ignore_gaps :\n        bool.\n        Whether to ignore gaps in calculations.\n    \"\"\"\n    self.method = method.lower()\n    self.ignore_gaps = ignore_gaps\n\n    # Map method names to functions\n    if self.method == 'hamming':\n        self.distance_func = hamming_distance\n    elif self.method in ('jc', 'jukes_cantor', 'jukes-cantor'):\n        self.distance_func = jukes_cantor_distance\n    elif self.method in ('k2p', 'kimura', 'kimura_2p'):\n        self.distance_func = kimura_2p_distance\n    elif self.method in ('tn', 'tamura_nei', 'tamura-nei'):\n        self.distance_func = tamura_nei_distance\n    elif self.method == 'p':\n        self.distance_func = p_distance\n    else:\n        raise ValueError(f'Unknown distance method: {method}')\n</code></pre>"},{"location":"api/core/distance/#pypopart.core.distance.DistanceCalculator.calculate","title":"calculate","text":"<pre><code>calculate(seq1: Sequence, seq2: Sequence) -&gt; float\n</code></pre> <p>Calculate distance between two sequences.</p> <p>Parameters:</p> Name Type Description Default <code>seq1</code> <code>Sequence</code> <p>Sequence. First sequence.</p> required <code>seq2</code> <code>Sequence</code> <p>Sequence. Second sequence.</p> required <p>Returns:</p> Type Description <code>    float            Distance value.</code> Source code in <code>src/pypopart/core/distance.py</code> <pre><code>def calculate(self, seq1: Sequence, seq2: Sequence) -&gt; float:\n    \"\"\"\n    Calculate distance between two sequences.\n\n    Parameters\n    ----------\n    seq1 :\n        Sequence.\n        First sequence.\n    seq2 :\n        Sequence.\n        Second sequence.\n\n    Returns\n    -------\n        float            Distance value.\n    \"\"\"\n    return self.distance_func(seq1, seq2, ignore_gaps=self.ignore_gaps)\n</code></pre>"},{"location":"api/core/distance/#pypopart.core.distance.DistanceCalculator.calculate_matrix","title":"calculate_matrix","text":"<pre><code>calculate_matrix(alignment: Alignment) -&gt; np.ndarray\n</code></pre> <p>Calculate pairwise distance matrix for alignment.</p> <p>Parameters:</p> Name Type Description Default <code>alignment</code> <code>Alignment</code> <p>Alignment. Sequence alignment.</p> required <p>Returns:</p> Type Description <code>    np.ndarray            Square distance matrix.</code> Source code in <code>src/pypopart/core/distance.py</code> <pre><code>def calculate_matrix(self, alignment: Alignment) -&gt; np.ndarray:\n    \"\"\"\n    Calculate pairwise distance matrix for alignment.\n\n    Parameters\n    ----------\n    alignment :\n        Alignment.\n        Sequence alignment.\n\n    Returns\n    -------\n        np.ndarray            Square distance matrix.\n    \"\"\"\n    dist_matrix = calculate_pairwise_distances(\n        alignment, method=self.method, ignore_gaps=self.ignore_gaps\n    )\n    return dist_matrix.matrix\n</code></pre>"},{"location":"api/core/distance/#pypopart.core.distance.DistanceCalculator.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return detailed string representation.</p> Source code in <code>src/pypopart/core/distance.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return detailed string representation.\"\"\"\n    return f\"DistanceCalculator(method='{self.method}', ignore_gaps={self.ignore_gaps})\"\n</code></pre>"},{"location":"api/core/distance/#pypopart.core.distance.hamming_distance","title":"hamming_distance","text":"<pre><code>hamming_distance(\n    seq1: Sequence,\n    seq2: Sequence,\n    ignore_gaps: bool = True,\n    use_numba: bool = True,\n) -&gt; int\n</code></pre> <p>Calculate Hamming distance between two sequences.</p> <p>Parameters:</p> Name Type Description Default <code>seq1</code> <code>Sequence</code> <p>Sequence. First sequence.</p> required <code>seq2</code> <code>Sequence</code> <p>Sequence. Second sequence.</p> required <code>ignore_gaps</code> <code>bool</code> <p>bool, default=True. Whether to ignore gap characters ('-').</p> <code>True</code> <code>use_numba</code> <code>bool</code> <p>bool, default=True. Use Numba-optimized version if available.</p> <code>True</code> <p>Returns:</p> Type Description <code>    int        Number of differing positions.</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If sequences have different lengths</p> Notes <p>When use_numba=True and Numba is available, uses JIT-compiled optimized version for better performance on large datasets.</p> <p>N and ? characters are treated as ambiguous and do not count as mutations when compared to any base (A, T, G, C) or to each other.</p> Source code in <code>src/pypopart/core/distance.py</code> <pre><code>def hamming_distance(\n    seq1: Sequence,\n    seq2: Sequence,\n    ignore_gaps: bool = True,\n    use_numba: bool = True,\n) -&gt; int:\n    \"\"\"\n    Calculate Hamming distance between two sequences.\n\n    Parameters\n    ----------\n    seq1 :\n        Sequence.\n        First sequence.\n    seq2 :\n        Sequence.\n        Second sequence.\n    ignore_gaps :\n        bool, default=True.\n        Whether to ignore gap characters ('-').\n    use_numba :\n        bool, default=True.\n        Use Numba-optimized version if available.\n\n    Returns\n    -------\n        int        Number of differing positions.\n\n    Raises\n    ------\n    ValueError\n        If sequences have different lengths\n\n    Notes\n    -----\n    When use_numba=True and Numba is available, uses JIT-compiled\n    optimized version for better performance on large datasets.\n\n    N and ? characters are treated as ambiguous and do not count as\n    mutations when compared to any base (A, T, G, C) or to each other.\n    \"\"\"\n    if len(seq1) != len(seq2):\n        raise ValueError(f'Sequences must have same length: {len(seq1)} vs {len(seq2)}')\n\n    # Use Numba optimized version if available and requested\n    if use_numba and _NUMBA_AVAILABLE:\n        return hamming_distance_optimized(seq1, seq2, ignore_gaps)\n\n    # Fall back to pure Python implementation\n    differences = 0\n    for c1, c2 in zip(seq1.data, seq2.data):\n        if ignore_gaps and (c1 == '-' or c2 == '-'):\n            continue\n        # Skip positions with N or ? (ambiguous bases)\n        if c1 in 'N?' or c2 in 'N?':\n            continue\n        if c1 != c2:\n            differences += 1\n\n    return differences\n</code></pre>"},{"location":"api/core/distance/#pypopart.core.distance.p_distance","title":"p_distance","text":"<pre><code>p_distance(\n    seq1: Sequence, seq2: Sequence, ignore_gaps: bool = True\n) -&gt; float\n</code></pre> <p>Calculate p-distance (proportion of differing sites).</p> <p>N and ? characters are treated as ambiguous and do not count as mutations when compared to any base (A, T, G, C) or to each other.</p> Source code in <code>src/pypopart/core/distance.py</code> <pre><code>def p_distance(seq1: Sequence, seq2: Sequence, ignore_gaps: bool = True) -&gt; float:\n    \"\"\"\n    Calculate p-distance (proportion of differing sites).\n\n    N and ? characters are treated as ambiguous and do not count as\n    mutations when compared to any base (A, T, G, C) or to each other.\n    \"\"\"\n    if len(seq1) != len(seq2):\n        raise ValueError(f'Sequences must have same length: {len(seq1)} vs {len(seq2)}')\n\n    differences = 0\n    compared_sites = 0\n\n    for c1, c2 in zip(seq1.data, seq2.data):\n        if ignore_gaps and (c1 == '-' or c2 == '-'):\n            continue\n        # Skip positions with N or ? (ambiguous bases)\n        if c1 in 'N?' or c2 in 'N?':\n            continue\n        compared_sites += 1\n        if c1 != c2:\n            differences += 1\n\n    if compared_sites == 0:\n        raise ValueError('No valid sites to compare')\n\n    return differences / compared_sites\n</code></pre>"},{"location":"api/core/distance/#pypopart.core.distance.jukes_cantor_distance","title":"jukes_cantor_distance","text":"<pre><code>jukes_cantor_distance(\n    seq1: Sequence, seq2: Sequence, ignore_gaps: bool = True\n) -&gt; float\n</code></pre> <p>Calculate Jukes-Cantor corrected distance.</p> Source code in <code>src/pypopart/core/distance.py</code> <pre><code>def jukes_cantor_distance(\n    seq1: Sequence, seq2: Sequence, ignore_gaps: bool = True\n) -&gt; float:\n    \"\"\"Calculate Jukes-Cantor corrected distance.\"\"\"\n    p = p_distance(seq1, seq2, ignore_gaps)\n\n    if p &gt;= 0.75:\n        raise ValueError(\n            f'Sequences too divergent for Jukes-Cantor correction (p={p:.3f} &gt;= 0.75)'\n        )\n\n    distance = -0.75 * log(1 - (4.0 / 3.0) * p)\n    return distance\n</code></pre>"},{"location":"api/core/distance/#pypopart.core.distance.kimura_2p_distance","title":"kimura_2p_distance","text":"<pre><code>kimura_2p_distance(\n    seq1: Sequence, seq2: Sequence, ignore_gaps: bool = True\n) -&gt; float\n</code></pre> <p>Calculate Kimura 2-parameter distance.</p> Source code in <code>src/pypopart/core/distance.py</code> <pre><code>def kimura_2p_distance(\n    seq1: Sequence, seq2: Sequence, ignore_gaps: bool = True\n) -&gt; float:\n    \"\"\"Calculate Kimura 2-parameter distance.\"\"\"\n    if len(seq1) != len(seq2):\n        raise ValueError(f'Sequences must have same length: {len(seq1)} vs {len(seq2)}')\n\n    transitions = 0\n    transversions = 0\n    compared_sites = 0\n\n    transition_pairs = {('A', 'G'), ('G', 'A'), ('C', 'T'), ('T', 'C')}\n\n    for c1, c2 in zip(seq1.data, seq2.data):\n        if ignore_gaps and (c1 == '-' or c2 == '-'):\n            continue\n        if c1 in 'N?' or c2 in 'N?':\n            continue\n\n        compared_sites += 1\n\n        if c1 != c2:\n            if (c1, c2) in transition_pairs:\n                transitions += 1\n            else:\n                transversions += 1\n\n    if compared_sites == 0:\n        raise ValueError('No valid sites to compare')\n\n    P = transitions / compared_sites\n    Q = transversions / compared_sites\n\n    term1 = 1 - 2 * P - Q\n    term2 = 1 - 2 * Q\n\n    if term1 &lt;= 0 or term2 &lt;= 0:\n        raise ValueError(\n            f'Sequences too divergent for K2P correction (P={P:.3f}, Q={Q:.3f})'\n        )\n\n    distance = -0.5 * log(term1 * (term2**0.5))\n    return distance\n</code></pre>"},{"location":"api/core/distance/#pypopart.core.distance.tamura_nei_distance","title":"tamura_nei_distance","text":"<pre><code>tamura_nei_distance(\n    seq1: Sequence, seq2: Sequence, ignore_gaps: bool = True\n) -&gt; float\n</code></pre> <p>Calculate Tamura-Nei distance.</p> <p>The Tamura-Nei model accounts for: - Different base frequencies (GC content) - Different rates for transitions within purines (A&lt;-&gt;G) and pyrimidines (C&lt;-&gt;T) - Different rate for transversions</p> <p>Args:     seq1: First sequence     seq2: Second sequence     ignore_gaps: Whether to ignore gap positions</p> <p>Returns:</p> Type Description <code>    Tamura-Nei corrected distance.</code> <p>Raises:</p> Type Description <code>    ValueError: If sequences have different lengths or are too divergent</code> <code>Reference:</code> <p>Tamura K, Nei M (1993) Mol Biol Evol 10(3):512-526</p> Source code in <code>src/pypopart/core/distance.py</code> <pre><code>def tamura_nei_distance(\n    seq1: Sequence, seq2: Sequence, ignore_gaps: bool = True\n) -&gt; float:\n    \"\"\"\n    Calculate Tamura-Nei distance.\n\n    The Tamura-Nei model accounts for:\n    - Different base frequencies (GC content)\n    - Different rates for transitions within purines (A&lt;-&gt;G) and pyrimidines (C&lt;-&gt;T)\n    - Different rate for transversions\n\n    Args:\n        seq1: First sequence\n        seq2: Second sequence\n        ignore_gaps: Whether to ignore gap positions\n\n    Returns\n    -------\n        Tamura-Nei corrected distance.\n\n    Raises\n    ------\n        ValueError: If sequences have different lengths or are too divergent\n\n    Reference:\n        Tamura K, Nei M (1993) Mol Biol Evol 10(3):512-526\n    \"\"\"\n    if len(seq1) != len(seq2):\n        raise ValueError(f'Sequences must have same length: {len(seq1)} vs {len(seq2)}')\n\n    # Count base frequencies and differences\n    purine_transitions = 0  # A&lt;-&gt;G\n    pyrimidine_transitions = 0  # C&lt;-&gt;T\n    transversions = 0\n    compared_sites = 0\n\n    base_counts = {'A': 0, 'G': 0, 'C': 0, 'T': 0}\n\n    for c1, c2 in zip(seq1.data, seq2.data):\n        if ignore_gaps and (c1 == '-' or c2 == '-'):\n            continue\n        if c1 in 'N?' or c2 in 'N?':\n            continue\n\n        compared_sites += 1\n\n        # Count base frequencies\n        if c1 in base_counts:\n            base_counts[c1] += 1\n        if c2 in base_counts:\n            base_counts[c2] += 1\n\n        # Count differences\n        if c1 != c2:\n            if (c1, c2) in {('A', 'G'), ('G', 'A')}:\n                purine_transitions += 1\n            elif (c1, c2) in {('C', 'T'), ('T', 'C')}:\n                pyrimidine_transitions += 1\n            else:\n                transversions += 1\n\n    if compared_sites == 0:\n        raise ValueError('No valid sites to compare')\n\n    # Calculate base frequencies\n    total_bases = sum(base_counts.values())\n    if total_bases == 0:\n        raise ValueError('No valid bases found')\n\n    freq_A = base_counts['A'] / total_bases\n    freq_G = base_counts['G'] / total_bases\n    freq_C = base_counts['C'] / total_bases\n    freq_T = base_counts['T'] / total_bases\n\n    # Calculate GC content components\n    freq_purines = freq_A + freq_G\n    freq_pyrimidines = freq_C + freq_T\n\n    # Calculate proportions of differences\n    P1 = purine_transitions / compared_sites  # A&lt;-&gt;G transitions\n    P2 = pyrimidine_transitions / compared_sites  # C&lt;-&gt;T transitions\n    Q = transversions / compared_sites  # Transversions\n\n    # Calculate GC content and related parameters\n    freq_G + freq_C\n\n    # Handle edge cases\n    if freq_purines == 0 or freq_pyrimidines == 0:\n        # Fall back to Kimura 2-parameter\n        P = P1 + P2\n        term1 = 1 - 2 * P - Q\n        term2 = 1 - 2 * Q\n        if term1 &lt;= 0 or term2 &lt;= 0:\n            raise ValueError(\n                f'Sequences too divergent for TN correction (P={P:.3f}, Q={Q:.3f})'\n            )\n        return -0.5 * log(term1 * (term2**0.5))\n\n    # Calculate correction terms\n    h_R = (\n        2 * freq_A * freq_G / freq_purines if freq_purines &gt; 0 else 0\n    )  # Purine heterozygosity\n    h_Y = (\n        2 * freq_C * freq_T / freq_pyrimidines if freq_pyrimidines &gt; 0 else 0\n    )  # Pyrimidine heterozygosity\n\n    # Calculate w terms for distance calculation\n    # Use small epsilon to avoid division by zero\n    epsilon = 1e-10\n\n    if h_R &gt; epsilon:\n        w1 = 1 - P1 / h_R - Q / (2 * freq_purines * freq_pyrimidines)\n    else:\n        # When h_R is very small, use a simplified form\n        w1 = (\n            1 - P1 - Q / (2 * freq_purines * freq_pyrimidines)\n            if freq_purines * freq_pyrimidines &gt; 0\n            else 1\n        )\n\n    if h_Y &gt; epsilon:\n        w2 = 1 - P2 / h_Y - Q / (2 * freq_purines * freq_pyrimidines)\n    else:\n        # When h_Y is very small, use a simplified form\n        w2 = (\n            1 - P2 - Q / (2 * freq_purines * freq_pyrimidines)\n            if freq_purines * freq_pyrimidines &gt; 0\n            else 1\n        )\n\n    w3 = (\n        1 - Q / (2 * freq_pyrimidines * freq_purines)\n        if freq_purines * freq_pyrimidines &gt; 0\n        else 1\n    )\n\n    # Check for divergence\n    if w1 &lt;= 0 or w2 &lt;= 0 or w3 &lt;= 0:\n        raise ValueError(\n            f'Sequences too divergent for Tamura-Nei correction '\n            f'(P1={P1:.3f}, P2={P2:.3f}, Q={Q:.3f})'\n        )\n\n    # Calculate Tamura-Nei distance\n    if h_R &gt; epsilon and h_Y &gt; epsilon:\n        # Full Tamura-Nei formula\n        distance = (\n            -h_R * log(w1)\n            - h_Y * log(w2)\n            - (freq_purines * freq_pyrimidines - h_R * h_Y / (h_R + h_Y)) * log(w3)\n        )\n    else:\n        # Simplified form when heterozygosity is low\n        distance = -0.5 * log(w1 * w2 * w3)\n\n    return distance\n</code></pre>"},{"location":"api/core/distance/#pypopart.core.distance.calculate_distance_matrix","title":"calculate_distance_matrix","text":"<pre><code>calculate_distance_matrix(\n    alignment: Alignment,\n    distance_func: Optional[\n        Callable[[Sequence, Sequence], float]\n    ] = None,\n    **kwargs\n) -&gt; DistanceMatrix\n</code></pre> <p>Calculate pairwise distance matrix for alignment.</p> Source code in <code>src/pypopart/core/distance.py</code> <pre><code>def calculate_distance_matrix(\n    alignment: Alignment,\n    distance_func: Optional[Callable[[Sequence, Sequence], float]] = None,\n    **kwargs,\n) -&gt; DistanceMatrix:\n    \"\"\"Calculate pairwise distance matrix for alignment.\"\"\"\n    if distance_func is None:\n        distance_func = hamming_distance\n\n    n = len(alignment)\n    labels = alignment.sequence_ids\n    matrix = np.zeros((n, n))\n\n    sequences = list(alignment)\n    for i in range(n):\n        for j in range(i + 1, n):\n            try:\n                dist = distance_func(sequences[i], sequences[j], **kwargs)\n                matrix[i, j] = matrix[j, i] = dist\n            except ValueError:\n                matrix[i, j] = matrix[j, i] = np.inf\n\n    return DistanceMatrix(labels, matrix)\n</code></pre>"},{"location":"api/core/distance/#pypopart.core.distance.calculate_pairwise_distances","title":"calculate_pairwise_distances","text":"<pre><code>calculate_pairwise_distances(\n    alignment: Alignment,\n    method: str = \"hamming\",\n    ignore_gaps: bool = True,\n) -&gt; DistanceMatrix\n</code></pre> <p>Calculate pairwise distances using specified method.</p> Source code in <code>src/pypopart/core/distance.py</code> <pre><code>def calculate_pairwise_distances(\n    alignment: Alignment, method: str = 'hamming', ignore_gaps: bool = True\n) -&gt; DistanceMatrix:\n    \"\"\"Calculate pairwise distances using specified method.\"\"\"\n    method = method.lower()\n\n    if method == 'hamming':\n        distance_func = hamming_distance\n    elif method == 'p':\n        distance_func = p_distance\n    elif method in ('jc', 'jukes-cantor'):\n        distance_func = jukes_cantor_distance\n    elif method in ('k2p', 'kimura'):\n        distance_func = kimura_2p_distance\n    elif method in ('tn', 'tamura-nei'):\n        distance_func = tamura_nei_distance\n    else:\n        raise ValueError(f'Unknown distance method: {method}')\n\n    return calculate_distance_matrix(\n        alignment, distance_func=distance_func, ignore_gaps=ignore_gaps\n    )\n</code></pre>"},{"location":"api/core/haplotype/","title":"Haplotype Module","text":"<p>Haplotype identification and management.</p>"},{"location":"api/core/haplotype/#overview","title":"Overview","text":"<p>The <code>haplotype</code> module provides classes for identifying and working with unique haplotypes in sequence data.</p>"},{"location":"api/core/haplotype/#classes","title":"Classes","text":""},{"location":"api/core/haplotype/#pypopart.core.haplotype","title":"pypopart.core.haplotype","text":"<p>Haplotype representation and management for PyPopART.</p> <p>Haplotypes represent unique sequence variants with associated frequency and population information.</p>"},{"location":"api/core/haplotype/#pypopart.core.haplotype.HaplotypeFrequency","title":"HaplotypeFrequency  <code>dataclass</code>","text":"<p>Frequency information for a haplotype across populations.</p> Source code in <code>src/pypopart/core/haplotype.py</code> <pre><code>@dataclass\nclass HaplotypeFrequency:\n    \"\"\"Frequency information for a haplotype across populations.\"\"\"\n\n    total: int\n    by_population: Dict[str, int]\n</code></pre>"},{"location":"api/core/haplotype/#pypopart.core.haplotype.Haplotype","title":"Haplotype","text":"<p>Represents a unique haplotype (sequence variant) with frequency information.</p> <p>A haplotype is a unique DNA sequence that may be shared by multiple individuals or samples. This class tracks the sequence, frequency, and population assignments.</p> Source code in <code>src/pypopart/core/haplotype.py</code> <pre><code>class Haplotype:\n    \"\"\"\n    Represents a unique haplotype (sequence variant) with frequency information.\n\n    A haplotype is a unique DNA sequence that may be shared by multiple\n    individuals or samples. This class tracks the sequence, frequency,\n    and population assignments.\n    \"\"\"\n\n    def __init__(\n        self,\n        sequence: Sequence,\n        sample_ids: Optional[List[str]] = None,\n        populations: Optional[Dict[str, str]] = None,\n    ):\n        \"\"\"\n        Initialize a haplotype.\n\n        Parameters\n        ----------\n        sequence :\n            The unique sequence for this haplotype.\n        sample_ids :\n            List of sample IDs sharing this haplotype.\n        populations :\n            Dictionary mapping sample_id -&gt; population/group.\n        \"\"\"\n        self.sequence = sequence\n        self._sample_ids: Set[str] = set(sample_ids) if sample_ids else set()\n        self._populations: Dict[str, str] = populations if populations else {}\n\n    @property\n    def id(self) -&gt; str:\n        \"\"\"Get haplotype ID (same as sequence ID).\"\"\"\n        return self.sequence.id\n\n    @property\n    def data(self) -&gt; str:\n        \"\"\"Get sequence data.\"\"\"\n        return self.sequence.data\n\n    @property\n    def frequency(self) -&gt; int:\n        \"\"\"Get total frequency (number of samples with this haplotype).\"\"\"\n        return len(self._sample_ids)\n\n    @property\n    def sample_ids(self) -&gt; List[str]:\n        \"\"\"Get list of sample IDs with this haplotype.\"\"\"\n        return sorted(self._sample_ids)\n\n    def add_sample(self, sample_id: str, population: Optional[str] = None) -&gt; None:\n        \"\"\"\n        Add a sample to this haplotype.\n\n        Parameters\n        ----------\n        sample_id :\n            Sample identifier.\n        population :\n            Optional population/group assignment.\n        \"\"\"\n        self._sample_ids.add(sample_id)\n        if population:\n            self._populations[sample_id] = population\n\n    def remove_sample(self, sample_id: str) -&gt; None:\n        \"\"\"\n        Remove a sample from this haplotype.\n\n        Parameters\n        ----------\n        sample_id :\n            Sample identifier.\n\n        Raises :\n        KeyError :\n            If sample not found.\n        \"\"\"\n        if sample_id not in self._sample_ids:\n            raise KeyError(f\"Sample '{sample_id}' not in haplotype\")\n\n        self._sample_ids.discard(sample_id)\n        self._populations.pop(sample_id, None)\n\n    def get_population(self, sample_id: str) -&gt; Optional[str]:\n        \"\"\"\n            Get population assignment for a sample.\n\n        Parameters\n        ----------\n            sample_id :\n                Sample identifier.\n\n        Returns\n        -------\n            Population name or None if not assigned.\n        \"\"\"\n        return self._populations.get(sample_id)\n\n    def get_populations(self) -&gt; Set[str]:\n        \"\"\"\n        Get set of all populations represented in this haplotype.\n\n        Returns\n        -------\n            Set of population names.\n        \"\"\"\n        return set(self._populations.values())\n\n    def get_frequency_by_population(self) -&gt; Dict[str, int]:\n        \"\"\"\n        Calculate frequency of this haplotype per population.\n\n        Returns\n        -------\n            Dictionary mapping population -&gt; count.\n        \"\"\"\n        freq_by_pop: Dict[str, int] = defaultdict(int)\n        for sample_id in self._sample_ids:\n            pop = self._populations.get(sample_id, 'Unassigned')\n            freq_by_pop[pop] += 1\n        return dict(freq_by_pop)\n\n    def get_frequency_info(self) -&gt; HaplotypeFrequency:\n        \"\"\"\n        Get comprehensive frequency information.\n\n        Returns\n        -------\n            HaplotypeFrequency object with total and per-population frequencies.\n        \"\"\"\n        return HaplotypeFrequency(\n            total=self.frequency, by_population=self.get_frequency_by_population()\n        )\n\n    def __len__(self) -&gt; int:\n        \"\"\"Return sequence length.\"\"\"\n        return len(self.sequence)\n\n    def __eq__(self, other: object) -&gt; bool:\n        \"\"\"Check equality based on sequence data.\"\"\"\n        if not isinstance(other, Haplotype):\n            return False\n        return self.sequence == other.sequence\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Hash based on sequence data.\"\"\"\n        return hash(self.sequence)\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return string representation.\"\"\"\n        return f'Haplotype {self.id}: {self.frequency} samples, {len(self.get_populations())} populations'\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Detailed representation.\"\"\"\n        return f\"Haplotype(id='{self.id}', frequency={self.frequency}, populations={len(self.get_populations())})\"\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Convert haplotype to dictionary representation.\n\n        Returns\n        -------\n            Dictionary with haplotype data.\n        \"\"\"\n        return {\n            'id': self.id,\n            'sequence': self.sequence.to_dict(),\n            'frequency': self.frequency,\n            'sample_ids': self.sample_ids,\n            'populations': self._populations,\n            'frequency_by_population': self.get_frequency_by_population(),\n        }\n\n    @classmethod\n    def from_dict(cls, data: Dict[str, Any]) -&gt; 'Haplotype':\n        \"\"\"\n            Create haplotype from dictionary.\n\n        Parameters\n        ----------\n            data :\n                Dictionary with haplotype information.\n\n        Returns\n        -------\n            New Haplotype object.\n        \"\"\"\n        sequence = Sequence.from_dict(data['sequence'])\n        return cls(\n            sequence=sequence,\n            sample_ids=data.get('sample_ids', []),\n            populations=data.get('populations', {}),\n        )\n</code></pre>"},{"location":"api/core/haplotype/#pypopart.core.haplotype.Haplotype.id","title":"id  <code>property</code>","text":"<pre><code>id: str\n</code></pre> <p>Get haplotype ID (same as sequence ID).</p>"},{"location":"api/core/haplotype/#pypopart.core.haplotype.Haplotype.data","title":"data  <code>property</code>","text":"<pre><code>data: str\n</code></pre> <p>Get sequence data.</p>"},{"location":"api/core/haplotype/#pypopart.core.haplotype.Haplotype.frequency","title":"frequency  <code>property</code>","text":"<pre><code>frequency: int\n</code></pre> <p>Get total frequency (number of samples with this haplotype).</p>"},{"location":"api/core/haplotype/#pypopart.core.haplotype.Haplotype.sample_ids","title":"sample_ids  <code>property</code>","text":"<pre><code>sample_ids: List[str]\n</code></pre> <p>Get list of sample IDs with this haplotype.</p>"},{"location":"api/core/haplotype/#pypopart.core.haplotype.Haplotype.__init__","title":"__init__","text":"<pre><code>__init__(\n    sequence: Sequence,\n    sample_ids: Optional[List[str]] = None,\n    populations: Optional[Dict[str, str]] = None,\n)\n</code></pre> <p>Initialize a haplotype.</p> <p>Parameters:</p> Name Type Description Default <code>sequence</code> <code>Sequence</code> <p>The unique sequence for this haplotype.</p> required <code>sample_ids</code> <code>Optional[List[str]]</code> <p>List of sample IDs sharing this haplotype.</p> <code>None</code> <code>populations</code> <code>Optional[Dict[str, str]]</code> <p>Dictionary mapping sample_id -&gt; population/group.</p> <code>None</code> Source code in <code>src/pypopart/core/haplotype.py</code> <pre><code>def __init__(\n    self,\n    sequence: Sequence,\n    sample_ids: Optional[List[str]] = None,\n    populations: Optional[Dict[str, str]] = None,\n):\n    \"\"\"\n    Initialize a haplotype.\n\n    Parameters\n    ----------\n    sequence :\n        The unique sequence for this haplotype.\n    sample_ids :\n        List of sample IDs sharing this haplotype.\n    populations :\n        Dictionary mapping sample_id -&gt; population/group.\n    \"\"\"\n    self.sequence = sequence\n    self._sample_ids: Set[str] = set(sample_ids) if sample_ids else set()\n    self._populations: Dict[str, str] = populations if populations else {}\n</code></pre>"},{"location":"api/core/haplotype/#pypopart.core.haplotype.Haplotype.add_sample","title":"add_sample","text":"<pre><code>add_sample(\n    sample_id: str, population: Optional[str] = None\n) -&gt; None\n</code></pre> <p>Add a sample to this haplotype.</p> <p>Parameters:</p> Name Type Description Default <code>sample_id</code> <code>str</code> <p>Sample identifier.</p> required <code>population</code> <code>Optional[str]</code> <p>Optional population/group assignment.</p> <code>None</code> Source code in <code>src/pypopart/core/haplotype.py</code> <pre><code>def add_sample(self, sample_id: str, population: Optional[str] = None) -&gt; None:\n    \"\"\"\n    Add a sample to this haplotype.\n\n    Parameters\n    ----------\n    sample_id :\n        Sample identifier.\n    population :\n        Optional population/group assignment.\n    \"\"\"\n    self._sample_ids.add(sample_id)\n    if population:\n        self._populations[sample_id] = population\n</code></pre>"},{"location":"api/core/haplotype/#pypopart.core.haplotype.Haplotype.remove_sample","title":"remove_sample","text":"<pre><code>remove_sample(sample_id: str) -&gt; None\n</code></pre> <p>Remove a sample from this haplotype.</p> <p>Parameters:</p> Name Type Description Default <code>sample_id</code> <code>str</code> <p>Sample identifier.</p> required <code>Raises</code> required <code>KeyError</code> <p>If sample not found.</p> required Source code in <code>src/pypopart/core/haplotype.py</code> <pre><code>def remove_sample(self, sample_id: str) -&gt; None:\n    \"\"\"\n    Remove a sample from this haplotype.\n\n    Parameters\n    ----------\n    sample_id :\n        Sample identifier.\n\n    Raises :\n    KeyError :\n        If sample not found.\n    \"\"\"\n    if sample_id not in self._sample_ids:\n        raise KeyError(f\"Sample '{sample_id}' not in haplotype\")\n\n    self._sample_ids.discard(sample_id)\n    self._populations.pop(sample_id, None)\n</code></pre>"},{"location":"api/core/haplotype/#pypopart.core.haplotype.Haplotype.get_population","title":"get_population","text":"<pre><code>get_population(sample_id: str) -&gt; Optional[str]\n</code></pre> <pre><code>Get population assignment for a sample.\n</code></pre> <p>Returns:</p> Type Description <code>    Population name or None if not assigned.</code> Source code in <code>src/pypopart/core/haplotype.py</code> <pre><code>def get_population(self, sample_id: str) -&gt; Optional[str]:\n    \"\"\"\n        Get population assignment for a sample.\n\n    Parameters\n    ----------\n        sample_id :\n            Sample identifier.\n\n    Returns\n    -------\n        Population name or None if not assigned.\n    \"\"\"\n    return self._populations.get(sample_id)\n</code></pre>"},{"location":"api/core/haplotype/#pypopart.core.haplotype.Haplotype.get_populations","title":"get_populations","text":"<pre><code>get_populations() -&gt; Set[str]\n</code></pre> <p>Get set of all populations represented in this haplotype.</p> <p>Returns:</p> Type Description <code>    Set of population names.</code> Source code in <code>src/pypopart/core/haplotype.py</code> <pre><code>def get_populations(self) -&gt; Set[str]:\n    \"\"\"\n    Get set of all populations represented in this haplotype.\n\n    Returns\n    -------\n        Set of population names.\n    \"\"\"\n    return set(self._populations.values())\n</code></pre>"},{"location":"api/core/haplotype/#pypopart.core.haplotype.Haplotype.get_frequency_by_population","title":"get_frequency_by_population","text":"<pre><code>get_frequency_by_population() -&gt; Dict[str, int]\n</code></pre> <p>Calculate frequency of this haplotype per population.</p> <p>Returns:</p> Type Description <code>    Dictionary mapping population -&gt; count.</code> Source code in <code>src/pypopart/core/haplotype.py</code> <pre><code>def get_frequency_by_population(self) -&gt; Dict[str, int]:\n    \"\"\"\n    Calculate frequency of this haplotype per population.\n\n    Returns\n    -------\n        Dictionary mapping population -&gt; count.\n    \"\"\"\n    freq_by_pop: Dict[str, int] = defaultdict(int)\n    for sample_id in self._sample_ids:\n        pop = self._populations.get(sample_id, 'Unassigned')\n        freq_by_pop[pop] += 1\n    return dict(freq_by_pop)\n</code></pre>"},{"location":"api/core/haplotype/#pypopart.core.haplotype.Haplotype.get_frequency_info","title":"get_frequency_info","text":"<pre><code>get_frequency_info() -&gt; HaplotypeFrequency\n</code></pre> <p>Get comprehensive frequency information.</p> <p>Returns:</p> Type Description <code>    HaplotypeFrequency object with total and per-population frequencies.</code> Source code in <code>src/pypopart/core/haplotype.py</code> <pre><code>def get_frequency_info(self) -&gt; HaplotypeFrequency:\n    \"\"\"\n    Get comprehensive frequency information.\n\n    Returns\n    -------\n        HaplotypeFrequency object with total and per-population frequencies.\n    \"\"\"\n    return HaplotypeFrequency(\n        total=self.frequency, by_population=self.get_frequency_by_population()\n    )\n</code></pre>"},{"location":"api/core/haplotype/#pypopart.core.haplotype.Haplotype.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>Return sequence length.</p> Source code in <code>src/pypopart/core/haplotype.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Return sequence length.\"\"\"\n    return len(self.sequence)\n</code></pre>"},{"location":"api/core/haplotype/#pypopart.core.haplotype.Haplotype.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Check equality based on sequence data.</p> Source code in <code>src/pypopart/core/haplotype.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Check equality based on sequence data.\"\"\"\n    if not isinstance(other, Haplotype):\n        return False\n    return self.sequence == other.sequence\n</code></pre>"},{"location":"api/core/haplotype/#pypopart.core.haplotype.Haplotype.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Hash based on sequence data.</p> Source code in <code>src/pypopart/core/haplotype.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Hash based on sequence data.\"\"\"\n    return hash(self.sequence)\n</code></pre>"},{"location":"api/core/haplotype/#pypopart.core.haplotype.Haplotype.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return string representation.</p> Source code in <code>src/pypopart/core/haplotype.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return string representation.\"\"\"\n    return f'Haplotype {self.id}: {self.frequency} samples, {len(self.get_populations())} populations'\n</code></pre>"},{"location":"api/core/haplotype/#pypopart.core.haplotype.Haplotype.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Detailed representation.</p> Source code in <code>src/pypopart/core/haplotype.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Detailed representation.\"\"\"\n    return f\"Haplotype(id='{self.id}', frequency={self.frequency}, populations={len(self.get_populations())})\"\n</code></pre>"},{"location":"api/core/haplotype/#pypopart.core.haplotype.Haplotype.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; Dict[str, Any]\n</code></pre> <p>Convert haplotype to dictionary representation.</p> <p>Returns:</p> Type Description <code>    Dictionary with haplotype data.</code> Source code in <code>src/pypopart/core/haplotype.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Convert haplotype to dictionary representation.\n\n    Returns\n    -------\n        Dictionary with haplotype data.\n    \"\"\"\n    return {\n        'id': self.id,\n        'sequence': self.sequence.to_dict(),\n        'frequency': self.frequency,\n        'sample_ids': self.sample_ids,\n        'populations': self._populations,\n        'frequency_by_population': self.get_frequency_by_population(),\n    }\n</code></pre>"},{"location":"api/core/haplotype/#pypopart.core.haplotype.Haplotype.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: Dict[str, Any]) -&gt; Haplotype\n</code></pre> <pre><code>Create haplotype from dictionary.\n</code></pre> <p>Returns:</p> Type Description <code>    New Haplotype object.</code> Source code in <code>src/pypopart/core/haplotype.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: Dict[str, Any]) -&gt; 'Haplotype':\n    \"\"\"\n        Create haplotype from dictionary.\n\n    Parameters\n    ----------\n        data :\n            Dictionary with haplotype information.\n\n    Returns\n    -------\n        New Haplotype object.\n    \"\"\"\n    sequence = Sequence.from_dict(data['sequence'])\n    return cls(\n        sequence=sequence,\n        sample_ids=data.get('sample_ids', []),\n        populations=data.get('populations', {}),\n    )\n</code></pre>"},{"location":"api/core/haplotype/#pypopart.core.haplotype.identify_haplotypes_from_alignment","title":"identify_haplotypes_from_alignment","text":"<pre><code>identify_haplotypes_from_alignment(\n    alignment: Alignment,\n    population_map: Optional[Dict[str, str]] = None,\n) -&gt; List[Haplotype]\n</code></pre> <p>Identify unique haplotypes from an alignment.</p> <p>Groups sequences by unique sequence data (ignoring gaps) and creates Haplotype objects with frequency information.</p> <p>Args:     alignment: Multiple sequence alignment     population_map: Optional dictionary mapping sequence_id -&gt; population</p> <p>Returns:</p> Type Description <code>    List of Haplotype objects.</code> Source code in <code>src/pypopart/core/haplotype.py</code> <pre><code>def identify_haplotypes_from_alignment(\n    alignment: 'Alignment', population_map: Optional[Dict[str, str]] = None\n) -&gt; List[Haplotype]:\n    \"\"\"\n    Identify unique haplotypes from an alignment.\n\n    Groups sequences by unique sequence data (ignoring gaps) and creates\n    Haplotype objects with frequency information.\n\n    Args:\n        alignment: Multiple sequence alignment\n        population_map: Optional dictionary mapping sequence_id -&gt; population\n\n    Returns\n    -------\n        List of Haplotype objects.\n    \"\"\"\n    # Group sequences by unique haplotype\n    haplotype_map: Dict[str, List[str]] = {}\n    sequence_map: Dict[str, Sequence] = {}\n\n    for seq in alignment:\n        # Use ungapped sequence as haplotype key\n        ungapped = seq.remove_gaps()\n        key = ungapped.data\n\n        if key not in haplotype_map:\n            haplotype_map[key] = []\n            sequence_map[key] = ungapped\n\n        haplotype_map[key].append(seq.id)\n\n    # Create Haplotype objects\n    haplotypes = []\n    for i, (key, sample_ids) in enumerate(sorted(haplotype_map.items()), start=1):\n        sequence = sequence_map[key]\n        # Give haplotype a numbered ID\n        haplotype_seq = Sequence(\n            id=f'H{i}',\n            data=sequence.data,\n            metadata=sequence.metadata.copy(),\n            description=f'Haplotype {i} (n={len(sample_ids)})',\n        )\n\n        # Map samples to populations if provided\n        populations = {}\n        if population_map:\n            for sample_id in sample_ids:\n                if sample_id in population_map:\n                    populations[sample_id] = population_map[sample_id]\n\n        haplotype = Haplotype(\n            sequence=haplotype_seq, sample_ids=sample_ids, populations=populations\n        )\n        haplotypes.append(haplotype)\n\n    return haplotypes\n</code></pre>"},{"location":"api/core/haplotype/#pypopart.core.haplotype.calculate_haplotype_diversity","title":"calculate_haplotype_diversity","text":"<pre><code>calculate_haplotype_diversity(\n    haplotypes: List[Haplotype],\n) -&gt; Dict[str, float]\n</code></pre> <p>Calculate haplotype diversity metrics.</p> <p>Args:     haplotypes: List of Haplotype objects</p> <p>Returns:</p> Type Description <code>    Dictionary with diversity metrics:.</code> <ul> <li>num_haplotypes: Number of unique haplotypes</li> <li>total_samples: Total number of samples</li> <li>haplotype_diversity: Gene diversity (Nei 1987)</li> <li>singleton_count: Number of haplotypes with frequency 1</li> </ul> Source code in <code>src/pypopart/core/haplotype.py</code> <pre><code>def calculate_haplotype_diversity(haplotypes: List[Haplotype]) -&gt; Dict[str, float]:\n    \"\"\"\n    Calculate haplotype diversity metrics.\n\n    Args:\n        haplotypes: List of Haplotype objects\n\n    Returns\n    -------\n        Dictionary with diversity metrics:.\n        - num_haplotypes: Number of unique haplotypes\n        - total_samples: Total number of samples\n        - haplotype_diversity: Gene diversity (Nei 1987)\n        - singleton_count: Number of haplotypes with frequency 1\n    \"\"\"\n    total_samples = sum(h.frequency for h in haplotypes)\n    num_haplotypes = len(haplotypes)\n\n    if total_samples == 0:\n        return {\n            'num_haplotypes': 0,\n            'total_samples': 0,\n            'haplotype_diversity': 0.0,\n            'singleton_count': 0,\n        }\n\n    # Calculate haplotype diversity (gene diversity)\n    # H = (n / (n-1)) * (1 - \u03a3(pi^2))\n    # where pi is the frequency of haplotype i\n    freq_sum_squared = sum((h.frequency / total_samples) ** 2 for h in haplotypes)\n\n    if total_samples &gt; 1:\n        haplotype_diversity = (total_samples / (total_samples - 1)) * (\n            1 - freq_sum_squared\n        )\n    else:\n        haplotype_diversity = 0.0\n\n    # Count singletons (haplotypes appearing only once)\n    singleton_count = sum(1 for h in haplotypes if h.frequency == 1)\n\n    return {\n        'num_haplotypes': num_haplotypes,\n        'total_samples': total_samples,\n        'haplotype_diversity': haplotype_diversity,\n        'singleton_count': singleton_count,\n    }\n</code></pre>"},{"location":"api/core/network/","title":"Network Module","text":"<p>Haplotype network representation and manipulation.</p>"},{"location":"api/core/network/#overview","title":"Overview","text":"<p>The <code>graph</code> module provides network data structures built on NetworkX.</p>"},{"location":"api/core/network/#classes","title":"Classes","text":""},{"location":"api/core/network/#pypopart.core.graph","title":"pypopart.core.graph","text":"<p>Haplotype network representation and analysis for PyPopART.</p> <p>Provides the HaplotypeNetwork class for building and analyzing haplotype networks from DNA sequence data.</p>"},{"location":"api/core/network/#pypopart.core.graph.NetworkStats","title":"NetworkStats  <code>dataclass</code>","text":"<p>Statistics about a haplotype network.</p> Source code in <code>src/pypopart/core/graph.py</code> <pre><code>@dataclass\nclass NetworkStats:\n    \"\"\"Statistics about a haplotype network.\"\"\"\n\n    num_nodes: int\n    num_edges: int\n    num_haplotypes: int\n    num_median_vectors: int\n    total_samples: int\n    diameter: int\n    avg_degree: float\n    num_components: int\n</code></pre>"},{"location":"api/core/network/#pypopart.core.graph.HaplotypeNetwork","title":"HaplotypeNetwork","text":"<p>Represents a haplotype network using NetworkX.</p> <p>A haplotype network is a graph where nodes represent unique haplotypes (or inferred median vectors) and edges represent mutational relationships. Node sizes typically reflect haplotype frequencies, and edge weights represent genetic distances.</p> Source code in <code>src/pypopart/core/graph.py</code> <pre><code>class HaplotypeNetwork:\n    \"\"\"\n    Represents a haplotype network using NetworkX.\n\n    A haplotype network is a graph where nodes represent unique haplotypes\n    (or inferred median vectors) and edges represent mutational relationships.\n    Node sizes typically reflect haplotype frequencies, and edge weights\n    represent genetic distances.\n    \"\"\"\n\n    def __init__(self, name: Optional[str] = None):\n        \"\"\"\n        Initialize an empty haplotype network.\n\n        Parameters\n        ----------\n        name :\n            Optional name for the network.\n        \"\"\"\n        self.name = name or 'HaplotypeNetwork'\n        self._graph = nx.Graph()\n        self._haplotype_map: Dict[str, Haplotype] = {}\n        self._median_vectors: Set[str] = set()\n        self.metadata: Dict[str, Any] = {}\n\n    @classmethod\n    def from_serialized(cls, network_data: Dict) -&gt; 'HaplotypeNetwork':\n        \"\"\"\n        Reconstruct a HaplotypeNetwork from serialized data.\n\n        Parameters\n        ----------\n        network_data :\n            Dictionary containing serialized network data with 'nodes' and 'edges'.\n\n        Returns\n        -------\n            Reconstructed HaplotypeNetwork object.\n        \"\"\"\n        network = cls()\n\n        # Reconstruct haplotypes from nodes\n        for node in network_data.get('nodes', []):\n            node_id = node['id']\n            sequence_data = node.get('sequence', '')\n            is_median = node.get('is_median', False)\n            sample_ids = node.get('sample_ids', node.get('samples', []))\n\n            # Create a Sequence object\n            seq = Sequence(id=node_id, data=sequence_data)\n\n            # Create a Haplotype object\n            haplotype = Haplotype(sequence=seq, sample_ids=sample_ids)\n\n            # Add to network\n            network.add_haplotype(haplotype, median_vector=is_median)\n\n        # Add edges\n        for edge in network_data.get('edges', []):\n            source = edge['source']\n            target = edge['target']\n            weight = edge.get('weight', 1.0)\n            distance = edge.get('distance', 0)\n            network.add_edge(source, target, distance=distance, weight=weight)\n\n        return network\n\n    @property\n    def graph(self) -&gt; nx.Graph:\n        \"\"\"Get the underlying NetworkX graph.\"\"\"\n        return self._graph\n\n    def add_haplotype(self, haplotype: Haplotype, median_vector: bool = False) -&gt; None:\n        \"\"\"\n        Add a haplotype as a node to the network.\n\n        Parameters\n        ----------\n        haplotype :\n            Haplotype object to add.\n        median_vector :\n            Whether this is an inferred median vector.\n        \"\"\"\n        node_id = haplotype.id\n\n        if node_id in self._graph:\n            raise ValueError(f\"Node '{node_id}' already exists in network\")\n\n        # Store haplotype reference\n        self._haplotype_map[node_id] = haplotype\n\n        # Track median vectors\n        if median_vector:\n            self._median_vectors.add(node_id)\n\n        # Add node with attributes\n        self._graph.add_node(\n            node_id,\n            haplotype=haplotype,\n            frequency=haplotype.frequency,\n            sequence=haplotype.data,\n            median_vector=median_vector,\n            sample_ids=haplotype.sample_ids,\n            populations=list(haplotype.get_populations()),\n        )\n\n    def remove_haplotype(self, haplotype_id: str) -&gt; None:\n        \"\"\"\n        Remove a haplotype node from the network.\n\n        Parameters\n        ----------\n        haplotype_id :\n            ID of haplotype to remove.\n\n        Raises :\n        KeyError :\n            If haplotype not found.\n        \"\"\"\n        if haplotype_id not in self._graph:\n            raise KeyError(f\"Haplotype '{haplotype_id}' not found in network\")\n\n        self._graph.remove_node(haplotype_id)\n        self._haplotype_map.pop(haplotype_id, None)\n        self._median_vectors.discard(haplotype_id)\n\n    def add_edge(\n        self,\n        source: str,\n        target: str,\n        distance: int = 0,\n        weight: float = 1.0,\n        **attributes,\n    ) -&gt; None:\n        \"\"\"\n        Add an edge between two haplotypes.\n\n        Parameters\n        ----------\n        source :\n            Source haplotype ID.\n        target :\n            Target haplotype ID.\n        distance :\n            Genetic distance (weight).\n        **attributes :\n            Additional edge attributes.\n        \"\"\"\n        if source not in self._graph:\n            raise KeyError(f\"Source node '{source}' not found in network\")\n        if target not in self._graph:\n            raise KeyError(f\"Target node '{target}' not found in network\")\n\n        self._graph.add_edge(\n            source, target, weight=weight, distance=distance, **attributes\n        )\n\n    def remove_edge(self, source: str, target: str) -&gt; None:\n        \"\"\"\n        Remove an edge from the network.\n\n        Parameters\n        ----------\n        source :\n            Source haplotype ID.\n        target :\n            Target haplotype ID.\n\n        Raises :\n        KeyError :\n            If edge not found.\n        \"\"\"\n        if not self._graph.has_edge(source, target):\n            raise KeyError(f'Edge ({source}, {target}) not found in network')\n\n        self._graph.remove_edge(source, target)\n\n    def get_haplotype(self, haplotype_id: str) -&gt; Haplotype:\n        \"\"\"\n            Get haplotype by ID.\n\n        Parameters\n        ----------\n            haplotype_id :\n                Haplotype identifier.\n\n        Returns\n        -------\n            Haplotype object.\n\n            Raises :\n            KeyError :\n                If haplotype not found.\n        \"\"\"\n        if haplotype_id not in self._haplotype_map:\n            raise KeyError(f\"Haplotype '{haplotype_id}' not found in network\")\n\n        return self._haplotype_map[haplotype_id]\n\n    def has_node(self, haplotype_id: str) -&gt; bool:\n        \"\"\"\n            Check if node exists in network.\n\n        Parameters\n        ----------\n            haplotype_id :\n                Haplotype identifier.\n\n        Returns\n        -------\n            True if node exists.\n        \"\"\"\n        return haplotype_id in self._graph\n\n    def has_edge(self, source: str, target: str) -&gt; bool:\n        \"\"\"\n            Check if edge exists in network.\n\n        Parameters\n        ----------\n            source :\n                Source haplotype ID.\n            target :\n                Target haplotype ID.\n\n        Returns\n        -------\n            True if edge exists.\n        \"\"\"\n        return self._graph.has_edge(source, target)\n\n    def get_edge_distance(self, source: str, target: str) -&gt; float:\n        \"\"\"\n            Get distance for an edge.\n\n        Parameters\n        ----------\n            source :\n                Source haplotype ID.\n            target :\n                Target haplotype ID.\n\n        Returns\n        -------\n            Edge distance.\n\n            Raises :\n            KeyError :\n                If edge not found.\n        \"\"\"\n        if not self.has_edge(source, target):\n            raise KeyError(f'Edge ({source}, {target}) not found')\n\n        return self._graph[source][target]['distance']\n\n    def get_neighbors(self, haplotype_id: str) -&gt; List[str]:\n        \"\"\"\n            Get neighboring haplotype IDs.\n\n        Parameters\n        ----------\n            haplotype_id :\n                Haplotype identifier.\n\n        Returns\n        -------\n            List of neighbor IDs.\n\n            Raises :\n            KeyError :\n                If haplotype not found.\n        \"\"\"\n        if not self.has_node(haplotype_id):\n            raise KeyError(f\"Haplotype '{haplotype_id}' not found\")\n\n        return list(self._graph.neighbors(haplotype_id))\n\n    def get_degree(self, haplotype_id: str) -&gt; int:\n        \"\"\"\n            Get degree (number of connections) for a node.\n\n        Parameters\n        ----------\n            haplotype_id :\n                Haplotype identifier.\n\n        Returns\n        -------\n            Node degree.\n        \"\"\"\n        if not self.has_node(haplotype_id):\n            raise KeyError(f\"Haplotype '{haplotype_id}' not found\")\n\n        return self._graph.degree[haplotype_id]\n\n    @property\n    def num_nodes(self) -&gt; int:\n        \"\"\"Get number of nodes in network.\"\"\"\n        return self._graph.number_of_nodes()\n\n    @property\n    def num_edges(self) -&gt; int:\n        \"\"\"Get number of edges in network.\"\"\"\n        return self._graph.number_of_edges()\n\n    @property\n    def nodes(self) -&gt; List[str]:\n        \"\"\"Get list of node IDs.\"\"\"\n        return list(self._graph.nodes())\n\n    @property\n    def edges(self) -&gt; List[Tuple[str, str]]:\n        \"\"\"Get list of edges as (source, target) tuples.\"\"\"\n        return list(self._graph.edges())\n\n    @property\n    def haplotypes(self) -&gt; List[Haplotype]:\n        \"\"\"Get list of all haplotypes (excluding median vectors).\"\"\"\n        return [\n            hap\n            for hap_id, hap in self._haplotype_map.items()\n            if hap_id not in self._median_vectors\n        ]\n\n    @property\n    def median_vector_ids(self) -&gt; List[str]:\n        \"\"\"Get list of median vector node IDs.\"\"\"\n        return sorted(self._median_vectors)\n\n    def is_median_vector(self, node_id: str) -&gt; bool:\n        \"\"\"\n            Check if a node is a median vector.\n\n        Parameters\n        ----------\n            node_id :\n                Node identifier.\n\n        Returns\n        -------\n            True if node is a median vector.\n        \"\"\"\n        return node_id in self._median_vectors\n\n    def is_connected(self) -&gt; bool:\n        \"\"\"\n        Check if network is fully connected.\n\n        Returns\n        -------\n            True if all nodes are in one connected component.\n        \"\"\"\n        return nx.is_connected(self._graph)\n\n    def get_connected_components(self) -&gt; List[Set[str]]:\n        \"\"\"\n        Get connected components of the network.\n\n        Returns\n        -------\n            List of sets, each containing node IDs in a component.\n        \"\"\"\n        return [set(component) for component in nx.connected_components(self._graph)]\n\n    def calculate_diameter(self) -&gt; int:\n        \"\"\"\n        Calculate network diameter (longest shortest path).\n\n        Returns\n        -------\n            Network diameter, or -1 if not connected.\n        \"\"\"\n        if not self.is_connected():\n            return -1\n\n        return nx.diameter(self._graph)\n\n    def get_shortest_path(self, source: str, target: str) -&gt; List[str]:\n        \"\"\"\n            Find shortest path between two nodes.\n\n        Parameters\n        ----------\n            source :\n                Source node ID.\n            target :\n                Target node ID.\n\n        Returns\n        -------\n            List of node IDs in the shortest path.\n\n            Raises :\n                nx.NetworkXNoPath: If no path exists\n        \"\"\"\n        return nx.shortest_path(self._graph, source, target)\n\n    def get_shortest_path_length(self, source: str, target: str) -&gt; int:\n        \"\"\"\n            Get length of shortest path between two nodes.\n\n        Parameters\n        ----------\n            source :\n                Source node ID.\n            target :\n                Target node ID.\n\n        Returns\n        -------\n            Number of edges in shortest path.\n\n            Raises :\n                nx.NetworkXNoPath: If no path exists\n        \"\"\"\n        return nx.shortest_path_length(self._graph, source, target)\n\n    def calculate_centrality(self) -&gt; Dict[str, float]:\n        \"\"\"\n        Calculate betweenness centrality for all nodes.\n\n        Returns\n        -------\n            Dictionary mapping node ID to centrality score.\n        \"\"\"\n        return nx.betweenness_centrality(self._graph)\n\n    def get_total_samples(self) -&gt; int:\n        \"\"\"\n        Get total number of samples represented in the network.\n\n        Returns\n        -------\n            Total sample count.\n        \"\"\"\n        return sum(hap.frequency for hap in self._haplotype_map.values())\n\n    def calculate_stats(self) -&gt; NetworkStats:\n        \"\"\"\n        Calculate comprehensive network statistics.\n\n        Returns\n        -------\n            NetworkStats object with network metrics.\n        \"\"\"\n        num_nodes = self.num_nodes\n        num_edges = self.num_edges\n        num_haplotypes = len(self.haplotypes)\n        num_median = len(self._median_vectors)\n        total_samples = self.get_total_samples()\n\n        # Calculate diameter (handle disconnected networks)\n        try:\n            diameter = self.calculate_diameter()\n        except Exception:\n            diameter = -1\n\n        # Calculate average degree\n        if num_nodes &gt; 0:\n            avg_degree = (2 * num_edges) / num_nodes\n        else:\n            avg_degree = 0.0\n\n        # Count connected components\n        num_components = nx.number_connected_components(self._graph)\n\n        return NetworkStats(\n            num_nodes=num_nodes,\n            num_edges=num_edges,\n            num_haplotypes=num_haplotypes,\n            num_median_vectors=num_median,\n            total_samples=total_samples,\n            diameter=diameter,\n            avg_degree=avg_degree,\n            num_components=num_components,\n        )\n\n    def validate(self) -&gt; None:\n        \"\"\"\n        Validate network structure.\n\n        Raises\n        ------\n            ValueError: If network is invalid\n        \"\"\"\n        # Check all nodes have haplotypes\n        for node_id in self._graph.nodes():\n            if node_id not in self._haplotype_map:\n                raise ValueError(f\"Node '{node_id}' missing haplotype reference\")\n\n        # Check all edges have valid endpoints\n        for source, target in self._graph.edges():\n            if source not in self._graph:\n                raise ValueError(f\"Edge references non-existent source '{source}'\")\n            if target not in self._graph:\n                raise ValueError(f\"Edge references non-existent target '{target}'\")\n\n        # Check edge distances are non-negative\n        for source, target, data in self._graph.edges(data=True):\n            distance = data.get('distance', 0)\n            if distance &lt; 0:\n                raise ValueError(\n                    f'Edge ({source}, {target}) has negative distance {distance}'\n                )\n\n    def to_networkx(self) -&gt; nx.Graph:\n        \"\"\"\n        Get the underlying NetworkX graph.\n\n        Returns\n        -------\n            NetworkX Graph object.\n        \"\"\"\n        return self._graph.copy()\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Convert network to dictionary representation.\n\n        Returns\n        -------\n            Dictionary with network data.\n        \"\"\"\n        nodes_data = []\n        for node_id in self._graph.nodes():\n            hap = self._haplotype_map[node_id]\n            nodes_data.append(\n                {\n                    'id': node_id,\n                    'frequency': hap.frequency,\n                    'sequence': hap.data,\n                    'median_vector': self.is_median_vector(node_id),\n                    'sample_ids': hap.sample_ids,\n                    'populations': list(hap.get_populations()),\n                }\n            )\n\n        edges_data = []\n        for source, target, data in self._graph.edges(data=True):\n            edges_data.append(\n                {'source': source, 'target': target, 'distance': data['distance']}\n            )\n\n        return {\n            'name': self.name,\n            'nodes': nodes_data,\n            'edges': edges_data,\n            'metadata': self.metadata,\n        }\n\n    def __len__(self) -&gt; int:\n        \"\"\"Return number of nodes in network.\"\"\"\n        return self.num_nodes\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return string representation.\"\"\"\n        stats = self.calculate_stats()\n        return (\n            f'{self.name}: {stats.num_haplotypes} haplotypes, '\n            f'{stats.num_median_vectors} median vectors, '\n            f'{stats.num_edges} edges'\n        )\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Detailed representation.\"\"\"\n        return f'HaplotypeNetwork(nodes={self.num_nodes}, edges={self.num_edges})'\n</code></pre>"},{"location":"api/core/network/#pypopart.core.graph.HaplotypeNetwork.graph","title":"graph  <code>property</code>","text":"<pre><code>graph: Graph\n</code></pre> <p>Get the underlying NetworkX graph.</p>"},{"location":"api/core/network/#pypopart.core.graph.HaplotypeNetwork.num_nodes","title":"num_nodes  <code>property</code>","text":"<pre><code>num_nodes: int\n</code></pre> <p>Get number of nodes in network.</p>"},{"location":"api/core/network/#pypopart.core.graph.HaplotypeNetwork.num_edges","title":"num_edges  <code>property</code>","text":"<pre><code>num_edges: int\n</code></pre> <p>Get number of edges in network.</p>"},{"location":"api/core/network/#pypopart.core.graph.HaplotypeNetwork.nodes","title":"nodes  <code>property</code>","text":"<pre><code>nodes: List[str]\n</code></pre> <p>Get list of node IDs.</p>"},{"location":"api/core/network/#pypopart.core.graph.HaplotypeNetwork.edges","title":"edges  <code>property</code>","text":"<pre><code>edges: List[Tuple[str, str]]\n</code></pre> <p>Get list of edges as (source, target) tuples.</p>"},{"location":"api/core/network/#pypopart.core.graph.HaplotypeNetwork.haplotypes","title":"haplotypes  <code>property</code>","text":"<pre><code>haplotypes: List[Haplotype]\n</code></pre> <p>Get list of all haplotypes (excluding median vectors).</p>"},{"location":"api/core/network/#pypopart.core.graph.HaplotypeNetwork.median_vector_ids","title":"median_vector_ids  <code>property</code>","text":"<pre><code>median_vector_ids: List[str]\n</code></pre> <p>Get list of median vector node IDs.</p>"},{"location":"api/core/network/#pypopart.core.graph.HaplotypeNetwork.__init__","title":"__init__","text":"<pre><code>__init__(name: Optional[str] = None)\n</code></pre> <p>Initialize an empty haplotype network.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>Optional name for the network.</p> <code>None</code> Source code in <code>src/pypopart/core/graph.py</code> <pre><code>def __init__(self, name: Optional[str] = None):\n    \"\"\"\n    Initialize an empty haplotype network.\n\n    Parameters\n    ----------\n    name :\n        Optional name for the network.\n    \"\"\"\n    self.name = name or 'HaplotypeNetwork'\n    self._graph = nx.Graph()\n    self._haplotype_map: Dict[str, Haplotype] = {}\n    self._median_vectors: Set[str] = set()\n    self.metadata: Dict[str, Any] = {}\n</code></pre>"},{"location":"api/core/network/#pypopart.core.graph.HaplotypeNetwork.from_serialized","title":"from_serialized  <code>classmethod</code>","text":"<pre><code>from_serialized(network_data: Dict) -&gt; HaplotypeNetwork\n</code></pre> <p>Reconstruct a HaplotypeNetwork from serialized data.</p> <p>Parameters:</p> Name Type Description Default <code>network_data</code> <code>Dict</code> <p>Dictionary containing serialized network data with 'nodes' and 'edges'.</p> required <p>Returns:</p> Type Description <code>    Reconstructed HaplotypeNetwork object.</code> Source code in <code>src/pypopart/core/graph.py</code> <pre><code>@classmethod\ndef from_serialized(cls, network_data: Dict) -&gt; 'HaplotypeNetwork':\n    \"\"\"\n    Reconstruct a HaplotypeNetwork from serialized data.\n\n    Parameters\n    ----------\n    network_data :\n        Dictionary containing serialized network data with 'nodes' and 'edges'.\n\n    Returns\n    -------\n        Reconstructed HaplotypeNetwork object.\n    \"\"\"\n    network = cls()\n\n    # Reconstruct haplotypes from nodes\n    for node in network_data.get('nodes', []):\n        node_id = node['id']\n        sequence_data = node.get('sequence', '')\n        is_median = node.get('is_median', False)\n        sample_ids = node.get('sample_ids', node.get('samples', []))\n\n        # Create a Sequence object\n        seq = Sequence(id=node_id, data=sequence_data)\n\n        # Create a Haplotype object\n        haplotype = Haplotype(sequence=seq, sample_ids=sample_ids)\n\n        # Add to network\n        network.add_haplotype(haplotype, median_vector=is_median)\n\n    # Add edges\n    for edge in network_data.get('edges', []):\n        source = edge['source']\n        target = edge['target']\n        weight = edge.get('weight', 1.0)\n        distance = edge.get('distance', 0)\n        network.add_edge(source, target, distance=distance, weight=weight)\n\n    return network\n</code></pre>"},{"location":"api/core/network/#pypopart.core.graph.HaplotypeNetwork.add_haplotype","title":"add_haplotype","text":"<pre><code>add_haplotype(\n    haplotype: Haplotype, median_vector: bool = False\n) -&gt; None\n</code></pre> <p>Add a haplotype as a node to the network.</p> <p>Parameters:</p> Name Type Description Default <code>haplotype</code> <code>Haplotype</code> <p>Haplotype object to add.</p> required <code>median_vector</code> <code>bool</code> <p>Whether this is an inferred median vector.</p> <code>False</code> Source code in <code>src/pypopart/core/graph.py</code> <pre><code>def add_haplotype(self, haplotype: Haplotype, median_vector: bool = False) -&gt; None:\n    \"\"\"\n    Add a haplotype as a node to the network.\n\n    Parameters\n    ----------\n    haplotype :\n        Haplotype object to add.\n    median_vector :\n        Whether this is an inferred median vector.\n    \"\"\"\n    node_id = haplotype.id\n\n    if node_id in self._graph:\n        raise ValueError(f\"Node '{node_id}' already exists in network\")\n\n    # Store haplotype reference\n    self._haplotype_map[node_id] = haplotype\n\n    # Track median vectors\n    if median_vector:\n        self._median_vectors.add(node_id)\n\n    # Add node with attributes\n    self._graph.add_node(\n        node_id,\n        haplotype=haplotype,\n        frequency=haplotype.frequency,\n        sequence=haplotype.data,\n        median_vector=median_vector,\n        sample_ids=haplotype.sample_ids,\n        populations=list(haplotype.get_populations()),\n    )\n</code></pre>"},{"location":"api/core/network/#pypopart.core.graph.HaplotypeNetwork.remove_haplotype","title":"remove_haplotype","text":"<pre><code>remove_haplotype(haplotype_id: str) -&gt; None\n</code></pre> <p>Remove a haplotype node from the network.</p> <p>Parameters:</p> Name Type Description Default <code>haplotype_id</code> <code>str</code> <p>ID of haplotype to remove.</p> required <code>Raises</code> required <code>KeyError</code> <p>If haplotype not found.</p> required Source code in <code>src/pypopart/core/graph.py</code> <pre><code>def remove_haplotype(self, haplotype_id: str) -&gt; None:\n    \"\"\"\n    Remove a haplotype node from the network.\n\n    Parameters\n    ----------\n    haplotype_id :\n        ID of haplotype to remove.\n\n    Raises :\n    KeyError :\n        If haplotype not found.\n    \"\"\"\n    if haplotype_id not in self._graph:\n        raise KeyError(f\"Haplotype '{haplotype_id}' not found in network\")\n\n    self._graph.remove_node(haplotype_id)\n    self._haplotype_map.pop(haplotype_id, None)\n    self._median_vectors.discard(haplotype_id)\n</code></pre>"},{"location":"api/core/network/#pypopart.core.graph.HaplotypeNetwork.add_edge","title":"add_edge","text":"<pre><code>add_edge(\n    source: str,\n    target: str,\n    distance: int = 0,\n    weight: float = 1.0,\n    **attributes\n) -&gt; None\n</code></pre> <p>Add an edge between two haplotypes.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Source haplotype ID.</p> required <code>target</code> <code>str</code> <p>Target haplotype ID.</p> required <code>distance</code> <code>int</code> <p>Genetic distance (weight).</p> <code>0</code> <code>**attributes</code> <p>Additional edge attributes.</p> <code>{}</code> Source code in <code>src/pypopart/core/graph.py</code> <pre><code>def add_edge(\n    self,\n    source: str,\n    target: str,\n    distance: int = 0,\n    weight: float = 1.0,\n    **attributes,\n) -&gt; None:\n    \"\"\"\n    Add an edge between two haplotypes.\n\n    Parameters\n    ----------\n    source :\n        Source haplotype ID.\n    target :\n        Target haplotype ID.\n    distance :\n        Genetic distance (weight).\n    **attributes :\n        Additional edge attributes.\n    \"\"\"\n    if source not in self._graph:\n        raise KeyError(f\"Source node '{source}' not found in network\")\n    if target not in self._graph:\n        raise KeyError(f\"Target node '{target}' not found in network\")\n\n    self._graph.add_edge(\n        source, target, weight=weight, distance=distance, **attributes\n    )\n</code></pre>"},{"location":"api/core/network/#pypopart.core.graph.HaplotypeNetwork.remove_edge","title":"remove_edge","text":"<pre><code>remove_edge(source: str, target: str) -&gt; None\n</code></pre> <p>Remove an edge from the network.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Source haplotype ID.</p> required <code>target</code> <code>str</code> <p>Target haplotype ID.</p> required <code>Raises</code> required <code>KeyError</code> <p>If edge not found.</p> required Source code in <code>src/pypopart/core/graph.py</code> <pre><code>def remove_edge(self, source: str, target: str) -&gt; None:\n    \"\"\"\n    Remove an edge from the network.\n\n    Parameters\n    ----------\n    source :\n        Source haplotype ID.\n    target :\n        Target haplotype ID.\n\n    Raises :\n    KeyError :\n        If edge not found.\n    \"\"\"\n    if not self._graph.has_edge(source, target):\n        raise KeyError(f'Edge ({source}, {target}) not found in network')\n\n    self._graph.remove_edge(source, target)\n</code></pre>"},{"location":"api/core/network/#pypopart.core.graph.HaplotypeNetwork.get_haplotype","title":"get_haplotype","text":"<pre><code>get_haplotype(haplotype_id: str) -&gt; Haplotype\n</code></pre> <pre><code>Get haplotype by ID.\n</code></pre> <p>Returns:</p> Type Description <code>    Haplotype object.</code> <p>Raises : KeyError :     If haplotype not found.</p> Source code in <code>src/pypopart/core/graph.py</code> <pre><code>def get_haplotype(self, haplotype_id: str) -&gt; Haplotype:\n    \"\"\"\n        Get haplotype by ID.\n\n    Parameters\n    ----------\n        haplotype_id :\n            Haplotype identifier.\n\n    Returns\n    -------\n        Haplotype object.\n\n        Raises :\n        KeyError :\n            If haplotype not found.\n    \"\"\"\n    if haplotype_id not in self._haplotype_map:\n        raise KeyError(f\"Haplotype '{haplotype_id}' not found in network\")\n\n    return self._haplotype_map[haplotype_id]\n</code></pre>"},{"location":"api/core/network/#pypopart.core.graph.HaplotypeNetwork.has_node","title":"has_node","text":"<pre><code>has_node(haplotype_id: str) -&gt; bool\n</code></pre> <pre><code>Check if node exists in network.\n</code></pre> <p>Returns:</p> Type Description <code>    True if node exists.</code> Source code in <code>src/pypopart/core/graph.py</code> <pre><code>def has_node(self, haplotype_id: str) -&gt; bool:\n    \"\"\"\n        Check if node exists in network.\n\n    Parameters\n    ----------\n        haplotype_id :\n            Haplotype identifier.\n\n    Returns\n    -------\n        True if node exists.\n    \"\"\"\n    return haplotype_id in self._graph\n</code></pre>"},{"location":"api/core/network/#pypopart.core.graph.HaplotypeNetwork.has_edge","title":"has_edge","text":"<pre><code>has_edge(source: str, target: str) -&gt; bool\n</code></pre> <pre><code>Check if edge exists in network.\n</code></pre> <p>Returns:</p> Type Description <code>    True if edge exists.</code> Source code in <code>src/pypopart/core/graph.py</code> <pre><code>def has_edge(self, source: str, target: str) -&gt; bool:\n    \"\"\"\n        Check if edge exists in network.\n\n    Parameters\n    ----------\n        source :\n            Source haplotype ID.\n        target :\n            Target haplotype ID.\n\n    Returns\n    -------\n        True if edge exists.\n    \"\"\"\n    return self._graph.has_edge(source, target)\n</code></pre>"},{"location":"api/core/network/#pypopart.core.graph.HaplotypeNetwork.get_edge_distance","title":"get_edge_distance","text":"<pre><code>get_edge_distance(source: str, target: str) -&gt; float\n</code></pre> <pre><code>Get distance for an edge.\n</code></pre> <p>Returns:</p> Type Description <code>    Edge distance.</code> <p>Raises : KeyError :     If edge not found.</p> Source code in <code>src/pypopart/core/graph.py</code> <pre><code>def get_edge_distance(self, source: str, target: str) -&gt; float:\n    \"\"\"\n        Get distance for an edge.\n\n    Parameters\n    ----------\n        source :\n            Source haplotype ID.\n        target :\n            Target haplotype ID.\n\n    Returns\n    -------\n        Edge distance.\n\n        Raises :\n        KeyError :\n            If edge not found.\n    \"\"\"\n    if not self.has_edge(source, target):\n        raise KeyError(f'Edge ({source}, {target}) not found')\n\n    return self._graph[source][target]['distance']\n</code></pre>"},{"location":"api/core/network/#pypopart.core.graph.HaplotypeNetwork.get_neighbors","title":"get_neighbors","text":"<pre><code>get_neighbors(haplotype_id: str) -&gt; List[str]\n</code></pre> <pre><code>Get neighboring haplotype IDs.\n</code></pre> <p>Returns:</p> Type Description <code>    List of neighbor IDs.</code> <p>Raises : KeyError :     If haplotype not found.</p> Source code in <code>src/pypopart/core/graph.py</code> <pre><code>def get_neighbors(self, haplotype_id: str) -&gt; List[str]:\n    \"\"\"\n        Get neighboring haplotype IDs.\n\n    Parameters\n    ----------\n        haplotype_id :\n            Haplotype identifier.\n\n    Returns\n    -------\n        List of neighbor IDs.\n\n        Raises :\n        KeyError :\n            If haplotype not found.\n    \"\"\"\n    if not self.has_node(haplotype_id):\n        raise KeyError(f\"Haplotype '{haplotype_id}' not found\")\n\n    return list(self._graph.neighbors(haplotype_id))\n</code></pre>"},{"location":"api/core/network/#pypopart.core.graph.HaplotypeNetwork.get_degree","title":"get_degree","text":"<pre><code>get_degree(haplotype_id: str) -&gt; int\n</code></pre> <pre><code>Get degree (number of connections) for a node.\n</code></pre> <p>Returns:</p> Type Description <code>    Node degree.</code> Source code in <code>src/pypopart/core/graph.py</code> <pre><code>def get_degree(self, haplotype_id: str) -&gt; int:\n    \"\"\"\n        Get degree (number of connections) for a node.\n\n    Parameters\n    ----------\n        haplotype_id :\n            Haplotype identifier.\n\n    Returns\n    -------\n        Node degree.\n    \"\"\"\n    if not self.has_node(haplotype_id):\n        raise KeyError(f\"Haplotype '{haplotype_id}' not found\")\n\n    return self._graph.degree[haplotype_id]\n</code></pre>"},{"location":"api/core/network/#pypopart.core.graph.HaplotypeNetwork.is_median_vector","title":"is_median_vector","text":"<pre><code>is_median_vector(node_id: str) -&gt; bool\n</code></pre> <pre><code>Check if a node is a median vector.\n</code></pre> <p>Returns:</p> Type Description <code>    True if node is a median vector.</code> Source code in <code>src/pypopart/core/graph.py</code> <pre><code>def is_median_vector(self, node_id: str) -&gt; bool:\n    \"\"\"\n        Check if a node is a median vector.\n\n    Parameters\n    ----------\n        node_id :\n            Node identifier.\n\n    Returns\n    -------\n        True if node is a median vector.\n    \"\"\"\n    return node_id in self._median_vectors\n</code></pre>"},{"location":"api/core/network/#pypopart.core.graph.HaplotypeNetwork.is_connected","title":"is_connected","text":"<pre><code>is_connected() -&gt; bool\n</code></pre> <p>Check if network is fully connected.</p> <p>Returns:</p> Type Description <code>    True if all nodes are in one connected component.</code> Source code in <code>src/pypopart/core/graph.py</code> <pre><code>def is_connected(self) -&gt; bool:\n    \"\"\"\n    Check if network is fully connected.\n\n    Returns\n    -------\n        True if all nodes are in one connected component.\n    \"\"\"\n    return nx.is_connected(self._graph)\n</code></pre>"},{"location":"api/core/network/#pypopart.core.graph.HaplotypeNetwork.get_connected_components","title":"get_connected_components","text":"<pre><code>get_connected_components() -&gt; List[Set[str]]\n</code></pre> <p>Get connected components of the network.</p> <p>Returns:</p> Type Description <code>    List of sets, each containing node IDs in a component.</code> Source code in <code>src/pypopart/core/graph.py</code> <pre><code>def get_connected_components(self) -&gt; List[Set[str]]:\n    \"\"\"\n    Get connected components of the network.\n\n    Returns\n    -------\n        List of sets, each containing node IDs in a component.\n    \"\"\"\n    return [set(component) for component in nx.connected_components(self._graph)]\n</code></pre>"},{"location":"api/core/network/#pypopart.core.graph.HaplotypeNetwork.calculate_diameter","title":"calculate_diameter","text":"<pre><code>calculate_diameter() -&gt; int\n</code></pre> <p>Calculate network diameter (longest shortest path).</p> <p>Returns:</p> Type Description <code>    Network diameter, or -1 if not connected.</code> Source code in <code>src/pypopart/core/graph.py</code> <pre><code>def calculate_diameter(self) -&gt; int:\n    \"\"\"\n    Calculate network diameter (longest shortest path).\n\n    Returns\n    -------\n        Network diameter, or -1 if not connected.\n    \"\"\"\n    if not self.is_connected():\n        return -1\n\n    return nx.diameter(self._graph)\n</code></pre>"},{"location":"api/core/network/#pypopart.core.graph.HaplotypeNetwork.get_shortest_path","title":"get_shortest_path","text":"<pre><code>get_shortest_path(source: str, target: str) -&gt; List[str]\n</code></pre> <pre><code>Find shortest path between two nodes.\n</code></pre> <p>Returns:</p> Type Description <code>    List of node IDs in the shortest path.</code> <p>Raises :     nx.NetworkXNoPath: If no path exists</p> Source code in <code>src/pypopart/core/graph.py</code> <pre><code>def get_shortest_path(self, source: str, target: str) -&gt; List[str]:\n    \"\"\"\n        Find shortest path between two nodes.\n\n    Parameters\n    ----------\n        source :\n            Source node ID.\n        target :\n            Target node ID.\n\n    Returns\n    -------\n        List of node IDs in the shortest path.\n\n        Raises :\n            nx.NetworkXNoPath: If no path exists\n    \"\"\"\n    return nx.shortest_path(self._graph, source, target)\n</code></pre>"},{"location":"api/core/network/#pypopart.core.graph.HaplotypeNetwork.get_shortest_path_length","title":"get_shortest_path_length","text":"<pre><code>get_shortest_path_length(source: str, target: str) -&gt; int\n</code></pre> <pre><code>Get length of shortest path between two nodes.\n</code></pre> <p>Returns:</p> Type Description <code>    Number of edges in shortest path.</code> <p>Raises :     nx.NetworkXNoPath: If no path exists</p> Source code in <code>src/pypopart/core/graph.py</code> <pre><code>def get_shortest_path_length(self, source: str, target: str) -&gt; int:\n    \"\"\"\n        Get length of shortest path between two nodes.\n\n    Parameters\n    ----------\n        source :\n            Source node ID.\n        target :\n            Target node ID.\n\n    Returns\n    -------\n        Number of edges in shortest path.\n\n        Raises :\n            nx.NetworkXNoPath: If no path exists\n    \"\"\"\n    return nx.shortest_path_length(self._graph, source, target)\n</code></pre>"},{"location":"api/core/network/#pypopart.core.graph.HaplotypeNetwork.calculate_centrality","title":"calculate_centrality","text":"<pre><code>calculate_centrality() -&gt; Dict[str, float]\n</code></pre> <p>Calculate betweenness centrality for all nodes.</p> <p>Returns:</p> Type Description <code>    Dictionary mapping node ID to centrality score.</code> Source code in <code>src/pypopart/core/graph.py</code> <pre><code>def calculate_centrality(self) -&gt; Dict[str, float]:\n    \"\"\"\n    Calculate betweenness centrality for all nodes.\n\n    Returns\n    -------\n        Dictionary mapping node ID to centrality score.\n    \"\"\"\n    return nx.betweenness_centrality(self._graph)\n</code></pre>"},{"location":"api/core/network/#pypopart.core.graph.HaplotypeNetwork.get_total_samples","title":"get_total_samples","text":"<pre><code>get_total_samples() -&gt; int\n</code></pre> <p>Get total number of samples represented in the network.</p> <p>Returns:</p> Type Description <code>    Total sample count.</code> Source code in <code>src/pypopart/core/graph.py</code> <pre><code>def get_total_samples(self) -&gt; int:\n    \"\"\"\n    Get total number of samples represented in the network.\n\n    Returns\n    -------\n        Total sample count.\n    \"\"\"\n    return sum(hap.frequency for hap in self._haplotype_map.values())\n</code></pre>"},{"location":"api/core/network/#pypopart.core.graph.HaplotypeNetwork.calculate_stats","title":"calculate_stats","text":"<pre><code>calculate_stats() -&gt; NetworkStats\n</code></pre> <p>Calculate comprehensive network statistics.</p> <p>Returns:</p> Type Description <code>    NetworkStats object with network metrics.</code> Source code in <code>src/pypopart/core/graph.py</code> <pre><code>def calculate_stats(self) -&gt; NetworkStats:\n    \"\"\"\n    Calculate comprehensive network statistics.\n\n    Returns\n    -------\n        NetworkStats object with network metrics.\n    \"\"\"\n    num_nodes = self.num_nodes\n    num_edges = self.num_edges\n    num_haplotypes = len(self.haplotypes)\n    num_median = len(self._median_vectors)\n    total_samples = self.get_total_samples()\n\n    # Calculate diameter (handle disconnected networks)\n    try:\n        diameter = self.calculate_diameter()\n    except Exception:\n        diameter = -1\n\n    # Calculate average degree\n    if num_nodes &gt; 0:\n        avg_degree = (2 * num_edges) / num_nodes\n    else:\n        avg_degree = 0.0\n\n    # Count connected components\n    num_components = nx.number_connected_components(self._graph)\n\n    return NetworkStats(\n        num_nodes=num_nodes,\n        num_edges=num_edges,\n        num_haplotypes=num_haplotypes,\n        num_median_vectors=num_median,\n        total_samples=total_samples,\n        diameter=diameter,\n        avg_degree=avg_degree,\n        num_components=num_components,\n    )\n</code></pre>"},{"location":"api/core/network/#pypopart.core.graph.HaplotypeNetwork.validate","title":"validate","text":"<pre><code>validate() -&gt; None\n</code></pre> <p>Validate network structure.</p> <p>Raises:</p> Type Description <code>    ValueError: If network is invalid</code> Source code in <code>src/pypopart/core/graph.py</code> <pre><code>def validate(self) -&gt; None:\n    \"\"\"\n    Validate network structure.\n\n    Raises\n    ------\n        ValueError: If network is invalid\n    \"\"\"\n    # Check all nodes have haplotypes\n    for node_id in self._graph.nodes():\n        if node_id not in self._haplotype_map:\n            raise ValueError(f\"Node '{node_id}' missing haplotype reference\")\n\n    # Check all edges have valid endpoints\n    for source, target in self._graph.edges():\n        if source not in self._graph:\n            raise ValueError(f\"Edge references non-existent source '{source}'\")\n        if target not in self._graph:\n            raise ValueError(f\"Edge references non-existent target '{target}'\")\n\n    # Check edge distances are non-negative\n    for source, target, data in self._graph.edges(data=True):\n        distance = data.get('distance', 0)\n        if distance &lt; 0:\n            raise ValueError(\n                f'Edge ({source}, {target}) has negative distance {distance}'\n            )\n</code></pre>"},{"location":"api/core/network/#pypopart.core.graph.HaplotypeNetwork.to_networkx","title":"to_networkx","text":"<pre><code>to_networkx() -&gt; nx.Graph\n</code></pre> <p>Get the underlying NetworkX graph.</p> <p>Returns:</p> Type Description <code>    NetworkX Graph object.</code> Source code in <code>src/pypopart/core/graph.py</code> <pre><code>def to_networkx(self) -&gt; nx.Graph:\n    \"\"\"\n    Get the underlying NetworkX graph.\n\n    Returns\n    -------\n        NetworkX Graph object.\n    \"\"\"\n    return self._graph.copy()\n</code></pre>"},{"location":"api/core/network/#pypopart.core.graph.HaplotypeNetwork.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; Dict[str, Any]\n</code></pre> <p>Convert network to dictionary representation.</p> <p>Returns:</p> Type Description <code>    Dictionary with network data.</code> Source code in <code>src/pypopart/core/graph.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Convert network to dictionary representation.\n\n    Returns\n    -------\n        Dictionary with network data.\n    \"\"\"\n    nodes_data = []\n    for node_id in self._graph.nodes():\n        hap = self._haplotype_map[node_id]\n        nodes_data.append(\n            {\n                'id': node_id,\n                'frequency': hap.frequency,\n                'sequence': hap.data,\n                'median_vector': self.is_median_vector(node_id),\n                'sample_ids': hap.sample_ids,\n                'populations': list(hap.get_populations()),\n            }\n        )\n\n    edges_data = []\n    for source, target, data in self._graph.edges(data=True):\n        edges_data.append(\n            {'source': source, 'target': target, 'distance': data['distance']}\n        )\n\n    return {\n        'name': self.name,\n        'nodes': nodes_data,\n        'edges': edges_data,\n        'metadata': self.metadata,\n    }\n</code></pre>"},{"location":"api/core/network/#pypopart.core.graph.HaplotypeNetwork.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>Return number of nodes in network.</p> Source code in <code>src/pypopart/core/graph.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Return number of nodes in network.\"\"\"\n    return self.num_nodes\n</code></pre>"},{"location":"api/core/network/#pypopart.core.graph.HaplotypeNetwork.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return string representation.</p> Source code in <code>src/pypopart/core/graph.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return string representation.\"\"\"\n    stats = self.calculate_stats()\n    return (\n        f'{self.name}: {stats.num_haplotypes} haplotypes, '\n        f'{stats.num_median_vectors} median vectors, '\n        f'{stats.num_edges} edges'\n    )\n</code></pre>"},{"location":"api/core/network/#pypopart.core.graph.HaplotypeNetwork.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Detailed representation.</p> Source code in <code>src/pypopart/core/graph.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Detailed representation.\"\"\"\n    return f'HaplotypeNetwork(nodes={self.num_nodes}, edges={self.num_edges})'\n</code></pre>"},{"location":"api/core/sequence/","title":"Sequence Module","text":"<p>Core sequence handling and manipulation.</p>"},{"location":"api/core/sequence/#overview","title":"Overview","text":"<p>The <code>sequence</code> module provides the <code>Sequence</code> class for representing individual DNA/protein sequences.</p>"},{"location":"api/core/sequence/#classes","title":"Classes","text":""},{"location":"api/core/sequence/#pypopart.core.sequence","title":"pypopart.core.sequence","text":"<p>DNA sequence representation and manipulation for PyPopART.</p>"},{"location":"api/core/sequence/#pypopart.core.sequence.Sequence","title":"Sequence","text":"<p>Represents a DNA sequence with metadata.</p> <p>Supports IUPAC nucleotide codes including ambiguous characters.</p> Source code in <code>src/pypopart/core/sequence.py</code> <pre><code>class Sequence:\n    \"\"\"\n    Represents a DNA sequence with metadata.\n\n    Supports IUPAC nucleotide codes including ambiguous characters.\n    \"\"\"\n\n    # IUPAC nucleotide codes (uppercase)\n    VALID_CHARS = set('ACGTRYSWKMBDHVN-?')\n\n    # Reverse complement mapping\n    COMPLEMENT = {\n        'A': 'T',\n        'T': 'A',\n        'C': 'G',\n        'G': 'C',\n        'R': 'Y',\n        'Y': 'R',\n        'S': 'S',\n        'W': 'W',\n        'K': 'M',\n        'M': 'K',\n        'B': 'V',\n        'V': 'B',\n        'D': 'H',\n        'H': 'D',\n        'N': 'N',\n        '-': '-',\n        '?': '?',\n    }\n\n    def __init__(\n        self,\n        id: str,\n        data: str,\n        metadata: Optional[Dict[str, Any]] = None,\n        description: Optional[str] = None,\n    ):\n        \"\"\"\n        Initialize a sequence.\n\n        Parameters\n        ----------\n        id :\n            Sequence identifier.\n        data :\n            DNA sequence string.\n        metadata :\n            Optional metadata dictionary.\n        description :\n            Optional sequence description.\n\n        Raises :\n        ValueError :\n            If sequence contains invalid characters.\n        \"\"\"\n        self.id = id\n        self.data = data.strip().upper()\n        self.metadata = metadata if metadata is not None else {}\n        self.description = description\n\n        # Validate sequence\n        self._validate()\n\n    def _validate(self) -&gt; None:\n        \"\"\"\n        Validate sequence data contains only valid IUPAC characters.\n\n        Raises\n        ------\n            ValueError: If invalid characters found\n        \"\"\"\n        invalid = set(self.data) - self.VALID_CHARS\n        if invalid:\n            raise ValueError(f'Invalid characters in sequence: {sorted(invalid)}')\n\n    def __len__(self) -&gt; int:\n        \"\"\"Return sequence length.\"\"\"\n        return len(self.data)\n\n    def __eq__(self, other: object) -&gt; bool:\n        \"\"\"Check equality based on sequence data.\"\"\"\n        if not isinstance(other, Sequence):\n            return False\n        return self.data == other.data\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Hash based on sequence data for use in sets/dicts.\"\"\"\n        return hash(self.data)\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return FASTA format string representation.\"\"\"\n        header = f'&gt;{self.id}'\n        if self.description:\n            header += f' {self.description}'\n        return f'{header}\\n{self.data}'\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return detailed representation.\"\"\"\n        return (\n            f\"Sequence(id='{self.id}', length={len(self)}, data='{self.data[:20]}...')\"\n        )\n\n    def reverse_complement(self) -&gt; 'Sequence':\n        \"\"\"\n        Calculate reverse complement of sequence.\n\n        Returns\n        -------\n            New Sequence object with reverse complement.\n        \"\"\"\n        rev_comp_data = ''.join(self.COMPLEMENT[base] for base in reversed(self.data))\n        return Sequence(\n            id=f'{self.id}_rev_comp',\n            data=rev_comp_data,\n            metadata=self.metadata.copy(),\n            description=f'Reverse complement of {self.id}',\n        )\n\n    def gc_content(self) -&gt; float:\n        \"\"\"\n        Calculate GC content as fraction (0.0-1.0).\n\n        Ignores gaps (-) and ambiguous characters (N, ?).\n\n        Returns\n        -------\n            GC content fraction.\n        \"\"\"\n        # Count G, C, and S (which represents G or C)\n        gc_count = sum(1 for base in self.data if base in 'GCS')\n        # Count only ACGT bases (exclude gaps, ambiguous chars)\n        total_count = sum(1 for base in self.data if base in 'ACGT')\n\n        if total_count == 0:\n            return 0.0\n        return gc_count / total_count\n\n    def count_gaps(self) -&gt; int:\n        \"\"\"\n        Count number of gap characters.\n\n        Returns\n        -------\n            Number of gaps.\n        \"\"\"\n        return self.data.count('-')\n\n    def count_ambiguous(self) -&gt; int:\n        \"\"\"\n        Count number of ambiguous characters (N and ?).\n\n        Returns\n        -------\n            Number of ambiguous characters.\n        \"\"\"\n        return sum(1 for base in self.data if base in 'N?')\n\n    def remove_gaps(self) -&gt; 'Sequence':\n        \"\"\"\n        Create new sequence with gaps removed.\n\n        Returns\n        -------\n            New Sequence object without gaps.\n        \"\"\"\n        ungapped_data = self.data.replace('-', '')\n        return Sequence(\n            id=self.id,\n            data=ungapped_data,\n            metadata=self.metadata.copy(),\n            description=self.description,\n        )\n\n    def slice(self, start: int, end: Optional[int] = None) -&gt; 'Sequence':\n        \"\"\"\n            Extract a slice of the sequence.\n\n        Parameters\n        ----------\n            start :\n                Start position (0-based, inclusive).\n            end :\n                End position (0-based, exclusive), None for end of sequence.\n\n        Returns\n        -------\n            New Sequence object with sliced data.\n        \"\"\"\n        sliced_data = self.data[start:end]\n        slice_desc = f'slice[{start}:{end if end else \"end\"}]'\n        return Sequence(\n            id=f'{self.id}_{slice_desc}',\n            data=sliced_data,\n            metadata=self.metadata.copy(),\n            description=f'Slice {slice_desc} of {self.id}',\n        )\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Convert sequence to dictionary representation.\n\n        Returns\n        -------\n            Dictionary with sequence data and statistics.\n        \"\"\"\n        return {\n            'id': self.id,\n            'data': self.data,\n            'metadata': self.metadata,\n            'description': self.description,\n            'length': len(self),\n            'gc_content': self.gc_content(),\n            'gaps': self.count_gaps(),\n            'ambiguous': self.count_ambiguous(),\n        }\n\n    @classmethod\n    def from_dict(cls, data: Dict[str, Any]) -&gt; 'Sequence':\n        \"\"\"\n            Create sequence from dictionary.\n\n        Parameters\n        ----------\n            data :\n                Dictionary with sequence information.\n\n        Returns\n        -------\n            New Sequence object.\n        \"\"\"\n        return cls(\n            id=data['id'],\n            data=data['data'],\n            metadata=data.get('metadata', {}),\n            description=data.get('description'),\n        )\n</code></pre>"},{"location":"api/core/sequence/#pypopart.core.sequence.Sequence.__init__","title":"__init__","text":"<pre><code>__init__(\n    id: str,\n    data: str,\n    metadata: Optional[Dict[str, Any]] = None,\n    description: Optional[str] = None,\n)\n</code></pre> <p>Initialize a sequence.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Sequence identifier.</p> required <code>data</code> <code>str</code> <p>DNA sequence string.</p> required <code>metadata</code> <code>Optional[Dict[str, Any]]</code> <p>Optional metadata dictionary.</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>Optional sequence description.</p> <code>None</code> <code>Raises</code> required <code>ValueError</code> <p>If sequence contains invalid characters.</p> required Source code in <code>src/pypopart/core/sequence.py</code> <pre><code>def __init__(\n    self,\n    id: str,\n    data: str,\n    metadata: Optional[Dict[str, Any]] = None,\n    description: Optional[str] = None,\n):\n    \"\"\"\n    Initialize a sequence.\n\n    Parameters\n    ----------\n    id :\n        Sequence identifier.\n    data :\n        DNA sequence string.\n    metadata :\n        Optional metadata dictionary.\n    description :\n        Optional sequence description.\n\n    Raises :\n    ValueError :\n        If sequence contains invalid characters.\n    \"\"\"\n    self.id = id\n    self.data = data.strip().upper()\n    self.metadata = metadata if metadata is not None else {}\n    self.description = description\n\n    # Validate sequence\n    self._validate()\n</code></pre>"},{"location":"api/core/sequence/#pypopart.core.sequence.Sequence.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>Return sequence length.</p> Source code in <code>src/pypopart/core/sequence.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Return sequence length.\"\"\"\n    return len(self.data)\n</code></pre>"},{"location":"api/core/sequence/#pypopart.core.sequence.Sequence.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Check equality based on sequence data.</p> Source code in <code>src/pypopart/core/sequence.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Check equality based on sequence data.\"\"\"\n    if not isinstance(other, Sequence):\n        return False\n    return self.data == other.data\n</code></pre>"},{"location":"api/core/sequence/#pypopart.core.sequence.Sequence.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Hash based on sequence data for use in sets/dicts.</p> Source code in <code>src/pypopart/core/sequence.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Hash based on sequence data for use in sets/dicts.\"\"\"\n    return hash(self.data)\n</code></pre>"},{"location":"api/core/sequence/#pypopart.core.sequence.Sequence.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return FASTA format string representation.</p> Source code in <code>src/pypopart/core/sequence.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return FASTA format string representation.\"\"\"\n    header = f'&gt;{self.id}'\n    if self.description:\n        header += f' {self.description}'\n    return f'{header}\\n{self.data}'\n</code></pre>"},{"location":"api/core/sequence/#pypopart.core.sequence.Sequence.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return detailed representation.</p> Source code in <code>src/pypopart/core/sequence.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return detailed representation.\"\"\"\n    return (\n        f\"Sequence(id='{self.id}', length={len(self)}, data='{self.data[:20]}...')\"\n    )\n</code></pre>"},{"location":"api/core/sequence/#pypopart.core.sequence.Sequence.reverse_complement","title":"reverse_complement","text":"<pre><code>reverse_complement() -&gt; Sequence\n</code></pre> <p>Calculate reverse complement of sequence.</p> <p>Returns:</p> Type Description <code>    New Sequence object with reverse complement.</code> Source code in <code>src/pypopart/core/sequence.py</code> <pre><code>def reverse_complement(self) -&gt; 'Sequence':\n    \"\"\"\n    Calculate reverse complement of sequence.\n\n    Returns\n    -------\n        New Sequence object with reverse complement.\n    \"\"\"\n    rev_comp_data = ''.join(self.COMPLEMENT[base] for base in reversed(self.data))\n    return Sequence(\n        id=f'{self.id}_rev_comp',\n        data=rev_comp_data,\n        metadata=self.metadata.copy(),\n        description=f'Reverse complement of {self.id}',\n    )\n</code></pre>"},{"location":"api/core/sequence/#pypopart.core.sequence.Sequence.gc_content","title":"gc_content","text":"<pre><code>gc_content() -&gt; float\n</code></pre> <p>Calculate GC content as fraction (0.0-1.0).</p> <p>Ignores gaps (-) and ambiguous characters (N, ?).</p> <p>Returns:</p> Type Description <code>    GC content fraction.</code> Source code in <code>src/pypopart/core/sequence.py</code> <pre><code>def gc_content(self) -&gt; float:\n    \"\"\"\n    Calculate GC content as fraction (0.0-1.0).\n\n    Ignores gaps (-) and ambiguous characters (N, ?).\n\n    Returns\n    -------\n        GC content fraction.\n    \"\"\"\n    # Count G, C, and S (which represents G or C)\n    gc_count = sum(1 for base in self.data if base in 'GCS')\n    # Count only ACGT bases (exclude gaps, ambiguous chars)\n    total_count = sum(1 for base in self.data if base in 'ACGT')\n\n    if total_count == 0:\n        return 0.0\n    return gc_count / total_count\n</code></pre>"},{"location":"api/core/sequence/#pypopart.core.sequence.Sequence.count_gaps","title":"count_gaps","text":"<pre><code>count_gaps() -&gt; int\n</code></pre> <p>Count number of gap characters.</p> <p>Returns:</p> Type Description <code>    Number of gaps.</code> Source code in <code>src/pypopart/core/sequence.py</code> <pre><code>def count_gaps(self) -&gt; int:\n    \"\"\"\n    Count number of gap characters.\n\n    Returns\n    -------\n        Number of gaps.\n    \"\"\"\n    return self.data.count('-')\n</code></pre>"},{"location":"api/core/sequence/#pypopart.core.sequence.Sequence.count_ambiguous","title":"count_ambiguous","text":"<pre><code>count_ambiguous() -&gt; int\n</code></pre> <p>Count number of ambiguous characters (N and ?).</p> <p>Returns:</p> Type Description <code>    Number of ambiguous characters.</code> Source code in <code>src/pypopart/core/sequence.py</code> <pre><code>def count_ambiguous(self) -&gt; int:\n    \"\"\"\n    Count number of ambiguous characters (N and ?).\n\n    Returns\n    -------\n        Number of ambiguous characters.\n    \"\"\"\n    return sum(1 for base in self.data if base in 'N?')\n</code></pre>"},{"location":"api/core/sequence/#pypopart.core.sequence.Sequence.remove_gaps","title":"remove_gaps","text":"<pre><code>remove_gaps() -&gt; Sequence\n</code></pre> <p>Create new sequence with gaps removed.</p> <p>Returns:</p> Type Description <code>    New Sequence object without gaps.</code> Source code in <code>src/pypopart/core/sequence.py</code> <pre><code>def remove_gaps(self) -&gt; 'Sequence':\n    \"\"\"\n    Create new sequence with gaps removed.\n\n    Returns\n    -------\n        New Sequence object without gaps.\n    \"\"\"\n    ungapped_data = self.data.replace('-', '')\n    return Sequence(\n        id=self.id,\n        data=ungapped_data,\n        metadata=self.metadata.copy(),\n        description=self.description,\n    )\n</code></pre>"},{"location":"api/core/sequence/#pypopart.core.sequence.Sequence.slice","title":"slice","text":"<pre><code>slice(start: int, end: Optional[int] = None) -&gt; Sequence\n</code></pre> <pre><code>Extract a slice of the sequence.\n</code></pre> <p>Returns:</p> Type Description <code>    New Sequence object with sliced data.</code> Source code in <code>src/pypopart/core/sequence.py</code> <pre><code>def slice(self, start: int, end: Optional[int] = None) -&gt; 'Sequence':\n    \"\"\"\n        Extract a slice of the sequence.\n\n    Parameters\n    ----------\n        start :\n            Start position (0-based, inclusive).\n        end :\n            End position (0-based, exclusive), None for end of sequence.\n\n    Returns\n    -------\n        New Sequence object with sliced data.\n    \"\"\"\n    sliced_data = self.data[start:end]\n    slice_desc = f'slice[{start}:{end if end else \"end\"}]'\n    return Sequence(\n        id=f'{self.id}_{slice_desc}',\n        data=sliced_data,\n        metadata=self.metadata.copy(),\n        description=f'Slice {slice_desc} of {self.id}',\n    )\n</code></pre>"},{"location":"api/core/sequence/#pypopart.core.sequence.Sequence.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; Dict[str, Any]\n</code></pre> <p>Convert sequence to dictionary representation.</p> <p>Returns:</p> Type Description <code>    Dictionary with sequence data and statistics.</code> Source code in <code>src/pypopart/core/sequence.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Convert sequence to dictionary representation.\n\n    Returns\n    -------\n        Dictionary with sequence data and statistics.\n    \"\"\"\n    return {\n        'id': self.id,\n        'data': self.data,\n        'metadata': self.metadata,\n        'description': self.description,\n        'length': len(self),\n        'gc_content': self.gc_content(),\n        'gaps': self.count_gaps(),\n        'ambiguous': self.count_ambiguous(),\n    }\n</code></pre>"},{"location":"api/core/sequence/#pypopart.core.sequence.Sequence.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: Dict[str, Any]) -&gt; Sequence\n</code></pre> <pre><code>Create sequence from dictionary.\n</code></pre> <p>Returns:</p> Type Description <code>    New Sequence object.</code> Source code in <code>src/pypopart/core/sequence.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: Dict[str, Any]) -&gt; 'Sequence':\n    \"\"\"\n        Create sequence from dictionary.\n\n    Parameters\n    ----------\n        data :\n            Dictionary with sequence information.\n\n    Returns\n    -------\n        New Sequence object.\n    \"\"\"\n    return cls(\n        id=data['id'],\n        data=data['data'],\n        metadata=data.get('metadata', {}),\n        description=data.get('description'),\n    )\n</code></pre>"},{"location":"api/io/metadata/","title":"Metadata Handling","text":"<p>Sequence metadata and trait management.</p>"},{"location":"api/io/metadata/#overview","title":"Overview","text":"<p>The <code>metadata</code> module handles associated information for sequences:</p> <ul> <li>Population assignments</li> <li>Geographic locations</li> <li>Temporal data</li> <li>Custom traits</li> </ul>"},{"location":"api/io/metadata/#modules","title":"Modules","text":""},{"location":"api/io/metadata/#pypopart.io.metadata","title":"pypopart.io.metadata","text":"<p>Metadata file reader and writer for PyPopART.</p> <p>Handles CSV-based metadata/traits files that can be linked to sequences. Includes support for geographic coordinates (latitude/longitude).</p>"},{"location":"api/io/metadata/#pypopart.io.metadata.MetadataReader","title":"MetadataReader","text":"<p>Reader for CSV-based metadata files.</p> Source code in <code>src/pypopart/io/metadata.py</code> <pre><code>class MetadataReader:\n    \"\"\"Reader for CSV-based metadata files.\"\"\"\n\n    def __init__(\n        self,\n        filepath: Union[str, Path],\n        id_column: str = 'id',\n        delimiter: str = ',',\n        validate: bool = True,\n    ):\n        \"\"\"\n        Initialize metadata reader.\n\n        Parameters\n        ----------\n        filepath :\n            Path to metadata CSV file.\n        id_column :\n            Name of column containing sequence IDs.\n        delimiter :\n            CSV delimiter character.\n        validate :\n            Whether to validate metadata.\n        \"\"\"\n        self.filepath = Path(filepath)\n        self.id_column = id_column\n        self.delimiter = delimiter\n        self.validate = validate\n\n        if not self.filepath.exists():\n            raise FileNotFoundError(f'File not found: {filepath}')\n\n    def _open_file(self) -&gt; TextIO:\n        \"\"\"Open file handling gzip compression.\"\"\"\n        if self.filepath.suffix == '.gz':\n            return gzip.open(self.filepath, 'rt')\n        else:\n            return open(self.filepath, 'r', encoding='utf-8')\n\n    def read_metadata(self) -&gt; Dict[str, Dict[str, str]]:\n        \"\"\"\n        Read metadata from CSV file.\n\n        Returns\n        -------\n            Dictionary mapping sequence IDs to metadata dictionaries.\n        \"\"\"\n        metadata = {}\n\n        with self._open_file() as handle:\n            reader = csv.DictReader(handle, delimiter=self.delimiter)\n\n            if self.id_column not in reader.fieldnames:\n                raise ValueError(\n                    f\"ID column '{self.id_column}' not found in CSV. \"\n                    f'Available columns: {reader.fieldnames}'\n                )\n\n            for row in reader:\n                seq_id = row[self.id_column]\n\n                # Remove ID column from metadata\n                row_metadata = {k: v for k, v in row.items() if k != self.id_column}\n\n                if seq_id in metadata and self.validate:\n                    raise ValueError(f'Duplicate sequence ID in metadata: {seq_id}')\n\n                metadata[seq_id] = row_metadata\n\n        return metadata\n\n    def apply_to_alignment(self, alignment: Alignment) -&gt; None:\n        \"\"\"\n        Apply metadata to sequences in alignment.\n\n        Parameters\n        ----------\n        alignment :\n            Alignment object to update.\n        \"\"\"\n        metadata = self.read_metadata()\n\n        missing_ids = []\n        for seq in alignment:\n            if seq.id in metadata:\n                # Update sequence metadata\n                seq.metadata.update(metadata[seq.id])\n            elif self.validate:\n                missing_ids.append(seq.id)\n\n        if missing_ids and self.validate:\n            raise ValueError(\n                f'Metadata missing for {len(missing_ids)} sequences: '\n                f'{\", \".join(missing_ids[:5])}{\"...\" if len(missing_ids) &gt; 5 else \"\"}'\n            )\n</code></pre>"},{"location":"api/io/metadata/#pypopart.io.metadata.MetadataReader.__init__","title":"__init__","text":"<pre><code>__init__(\n    filepath: Union[str, Path],\n    id_column: str = \"id\",\n    delimiter: str = \",\",\n    validate: bool = True,\n)\n</code></pre> <p>Initialize metadata reader.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>Union[str, Path]</code> <p>Path to metadata CSV file.</p> required <code>id_column</code> <code>str</code> <p>Name of column containing sequence IDs.</p> <code>'id'</code> <code>delimiter</code> <code>str</code> <p>CSV delimiter character.</p> <code>','</code> <code>validate</code> <code>bool</code> <p>Whether to validate metadata.</p> <code>True</code> Source code in <code>src/pypopart/io/metadata.py</code> <pre><code>def __init__(\n    self,\n    filepath: Union[str, Path],\n    id_column: str = 'id',\n    delimiter: str = ',',\n    validate: bool = True,\n):\n    \"\"\"\n    Initialize metadata reader.\n\n    Parameters\n    ----------\n    filepath :\n        Path to metadata CSV file.\n    id_column :\n        Name of column containing sequence IDs.\n    delimiter :\n        CSV delimiter character.\n    validate :\n        Whether to validate metadata.\n    \"\"\"\n    self.filepath = Path(filepath)\n    self.id_column = id_column\n    self.delimiter = delimiter\n    self.validate = validate\n\n    if not self.filepath.exists():\n        raise FileNotFoundError(f'File not found: {filepath}')\n</code></pre>"},{"location":"api/io/metadata/#pypopart.io.metadata.MetadataReader.read_metadata","title":"read_metadata","text":"<pre><code>read_metadata() -&gt; Dict[str, Dict[str, str]]\n</code></pre> <p>Read metadata from CSV file.</p> <p>Returns:</p> Type Description <code>    Dictionary mapping sequence IDs to metadata dictionaries.</code> Source code in <code>src/pypopart/io/metadata.py</code> <pre><code>def read_metadata(self) -&gt; Dict[str, Dict[str, str]]:\n    \"\"\"\n    Read metadata from CSV file.\n\n    Returns\n    -------\n        Dictionary mapping sequence IDs to metadata dictionaries.\n    \"\"\"\n    metadata = {}\n\n    with self._open_file() as handle:\n        reader = csv.DictReader(handle, delimiter=self.delimiter)\n\n        if self.id_column not in reader.fieldnames:\n            raise ValueError(\n                f\"ID column '{self.id_column}' not found in CSV. \"\n                f'Available columns: {reader.fieldnames}'\n            )\n\n        for row in reader:\n            seq_id = row[self.id_column]\n\n            # Remove ID column from metadata\n            row_metadata = {k: v for k, v in row.items() if k != self.id_column}\n\n            if seq_id in metadata and self.validate:\n                raise ValueError(f'Duplicate sequence ID in metadata: {seq_id}')\n\n            metadata[seq_id] = row_metadata\n\n    return metadata\n</code></pre>"},{"location":"api/io/metadata/#pypopart.io.metadata.MetadataReader.apply_to_alignment","title":"apply_to_alignment","text":"<pre><code>apply_to_alignment(alignment: Alignment) -&gt; None\n</code></pre> <p>Apply metadata to sequences in alignment.</p> <p>Parameters:</p> Name Type Description Default <code>alignment</code> <code>Alignment</code> <p>Alignment object to update.</p> required Source code in <code>src/pypopart/io/metadata.py</code> <pre><code>def apply_to_alignment(self, alignment: Alignment) -&gt; None:\n    \"\"\"\n    Apply metadata to sequences in alignment.\n\n    Parameters\n    ----------\n    alignment :\n        Alignment object to update.\n    \"\"\"\n    metadata = self.read_metadata()\n\n    missing_ids = []\n    for seq in alignment:\n        if seq.id in metadata:\n            # Update sequence metadata\n            seq.metadata.update(metadata[seq.id])\n        elif self.validate:\n            missing_ids.append(seq.id)\n\n    if missing_ids and self.validate:\n        raise ValueError(\n            f'Metadata missing for {len(missing_ids)} sequences: '\n            f'{\", \".join(missing_ids[:5])}{\"...\" if len(missing_ids) &gt; 5 else \"\"}'\n        )\n</code></pre>"},{"location":"api/io/metadata/#pypopart.io.metadata.MetadataWriter","title":"MetadataWriter","text":"<p>Writer for CSV-based metadata files.</p> Source code in <code>src/pypopart/io/metadata.py</code> <pre><code>class MetadataWriter:\n    \"\"\"Writer for CSV-based metadata files.\"\"\"\n\n    def __init__(\n        self,\n        filepath: Union[str, Path],\n        id_column: str = 'id',\n        delimiter: str = ',',\n        compress: Optional[str] = None,\n    ):\n        \"\"\"\n        Initialize metadata writer.\n\n        Parameters\n        ----------\n        filepath :\n            Output file path.\n        id_column :\n            Name of column for sequence IDs.\n        delimiter :\n            CSV delimiter character.\n        compress :\n            Compression format ('gzip' or None).\n        \"\"\"\n        self.filepath = Path(filepath)\n        self.id_column = id_column\n        self.delimiter = delimiter\n        self.compress = compress\n\n        if compress == 'gzip' and not str(self.filepath).endswith('.gz'):\n            self.filepath = Path(str(self.filepath) + '.gz')\n\n    def _open_file(self) -&gt; TextIO:\n        \"\"\"Open file for writing with optional compression.\"\"\"\n        if self.compress == 'gzip':\n            return gzip.open(self.filepath, 'wt', encoding='utf-8')\n        else:\n            return open(self.filepath, 'w', encoding='utf-8', newline='')\n\n    def write_metadata(\n        self,\n        metadata: Dict[str, Dict[str, str]],\n        trait_order: Optional[List[str]] = None,\n    ) -&gt; None:\n        \"\"\"\n        Write metadata to CSV file.\n\n        Parameters\n        ----------\n        metadata :\n            Dictionary mapping sequence IDs to metadata dictionaries.\n        trait_order :\n            Optional list specifying order of trait columns.\n        \"\"\"\n        if not metadata:\n            raise ValueError('No metadata to write')\n\n        # Determine all trait keys\n        all_traits = set()\n        for traits in metadata.values():\n            all_traits.update(traits.keys())\n\n        # Order traits\n        if trait_order:\n            # Use specified order, then add any remaining traits\n            fieldnames = [self.id_column] + trait_order\n            remaining = sorted(all_traits - set(trait_order))\n            fieldnames.extend(remaining)\n        else:\n            fieldnames = [self.id_column] + sorted(all_traits)\n\n        with self._open_file() as handle:\n            writer = csv.DictWriter(\n                handle,\n                fieldnames=fieldnames,\n                delimiter=self.delimiter,\n                extrasaction='ignore',\n            )\n\n            writer.writeheader()\n\n            for seq_id, traits in sorted(metadata.items()):\n                row = {self.id_column: seq_id}\n                row.update(traits)\n                writer.writerow(row)\n\n    def write_from_alignment(\n        self, alignment: Alignment, trait_order: Optional[List[str]] = None\n    ) -&gt; None:\n        \"\"\"\n        Extract and write metadata from alignment.\n\n        Parameters\n        ----------\n        alignment :\n            Alignment object.\n        trait_order :\n            Optional list specifying order of trait columns.\n        \"\"\"\n        metadata = {}\n\n        for seq in alignment:\n            if seq.metadata:\n                metadata[seq.id] = seq.metadata\n\n        if not metadata:\n            raise ValueError('No metadata found in alignment')\n\n        self.write_metadata(metadata, trait_order)\n</code></pre>"},{"location":"api/io/metadata/#pypopart.io.metadata.MetadataWriter.__init__","title":"__init__","text":"<pre><code>__init__(\n    filepath: Union[str, Path],\n    id_column: str = \"id\",\n    delimiter: str = \",\",\n    compress: Optional[str] = None,\n)\n</code></pre> <p>Initialize metadata writer.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>Union[str, Path]</code> <p>Output file path.</p> required <code>id_column</code> <code>str</code> <p>Name of column for sequence IDs.</p> <code>'id'</code> <code>delimiter</code> <code>str</code> <p>CSV delimiter character.</p> <code>','</code> <code>compress</code> <code>Optional[str]</code> <p>Compression format ('gzip' or None).</p> <code>None</code> Source code in <code>src/pypopart/io/metadata.py</code> <pre><code>def __init__(\n    self,\n    filepath: Union[str, Path],\n    id_column: str = 'id',\n    delimiter: str = ',',\n    compress: Optional[str] = None,\n):\n    \"\"\"\n    Initialize metadata writer.\n\n    Parameters\n    ----------\n    filepath :\n        Output file path.\n    id_column :\n        Name of column for sequence IDs.\n    delimiter :\n        CSV delimiter character.\n    compress :\n        Compression format ('gzip' or None).\n    \"\"\"\n    self.filepath = Path(filepath)\n    self.id_column = id_column\n    self.delimiter = delimiter\n    self.compress = compress\n\n    if compress == 'gzip' and not str(self.filepath).endswith('.gz'):\n        self.filepath = Path(str(self.filepath) + '.gz')\n</code></pre>"},{"location":"api/io/metadata/#pypopart.io.metadata.MetadataWriter.write_metadata","title":"write_metadata","text":"<pre><code>write_metadata(\n    metadata: Dict[str, Dict[str, str]],\n    trait_order: Optional[List[str]] = None,\n) -&gt; None\n</code></pre> <p>Write metadata to CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>metadata</code> <code>Dict[str, Dict[str, str]]</code> <p>Dictionary mapping sequence IDs to metadata dictionaries.</p> required <code>trait_order</code> <code>Optional[List[str]]</code> <p>Optional list specifying order of trait columns.</p> <code>None</code> Source code in <code>src/pypopart/io/metadata.py</code> <pre><code>def write_metadata(\n    self,\n    metadata: Dict[str, Dict[str, str]],\n    trait_order: Optional[List[str]] = None,\n) -&gt; None:\n    \"\"\"\n    Write metadata to CSV file.\n\n    Parameters\n    ----------\n    metadata :\n        Dictionary mapping sequence IDs to metadata dictionaries.\n    trait_order :\n        Optional list specifying order of trait columns.\n    \"\"\"\n    if not metadata:\n        raise ValueError('No metadata to write')\n\n    # Determine all trait keys\n    all_traits = set()\n    for traits in metadata.values():\n        all_traits.update(traits.keys())\n\n    # Order traits\n    if trait_order:\n        # Use specified order, then add any remaining traits\n        fieldnames = [self.id_column] + trait_order\n        remaining = sorted(all_traits - set(trait_order))\n        fieldnames.extend(remaining)\n    else:\n        fieldnames = [self.id_column] + sorted(all_traits)\n\n    with self._open_file() as handle:\n        writer = csv.DictWriter(\n            handle,\n            fieldnames=fieldnames,\n            delimiter=self.delimiter,\n            extrasaction='ignore',\n        )\n\n        writer.writeheader()\n\n        for seq_id, traits in sorted(metadata.items()):\n            row = {self.id_column: seq_id}\n            row.update(traits)\n            writer.writerow(row)\n</code></pre>"},{"location":"api/io/metadata/#pypopart.io.metadata.MetadataWriter.write_from_alignment","title":"write_from_alignment","text":"<pre><code>write_from_alignment(\n    alignment: Alignment,\n    trait_order: Optional[List[str]] = None,\n) -&gt; None\n</code></pre> <p>Extract and write metadata from alignment.</p> <p>Parameters:</p> Name Type Description Default <code>alignment</code> <code>Alignment</code> <p>Alignment object.</p> required <code>trait_order</code> <code>Optional[List[str]]</code> <p>Optional list specifying order of trait columns.</p> <code>None</code> Source code in <code>src/pypopart/io/metadata.py</code> <pre><code>def write_from_alignment(\n    self, alignment: Alignment, trait_order: Optional[List[str]] = None\n) -&gt; None:\n    \"\"\"\n    Extract and write metadata from alignment.\n\n    Parameters\n    ----------\n    alignment :\n        Alignment object.\n    trait_order :\n        Optional list specifying order of trait columns.\n    \"\"\"\n    metadata = {}\n\n    for seq in alignment:\n        if seq.metadata:\n            metadata[seq.id] = seq.metadata\n\n    if not metadata:\n        raise ValueError('No metadata found in alignment')\n\n    self.write_metadata(metadata, trait_order)\n</code></pre>"},{"location":"api/io/metadata/#pypopart.io.metadata.parse_coordinate","title":"parse_coordinate","text":"<pre><code>parse_coordinate(value: str) -&gt; float\n</code></pre> <p>Parse a coordinate string to a float.</p> <p>Handles various formats: - Decimal degrees: \"45.5\", \"-123.4\" - With degree symbol: \"45.5\u00b0\", \"-123.4\u00b0\"</p> <p>Args:     value: Coordinate string</p> <p>Returns:</p> Type Description <code>    Coordinate as float.</code> <p>Raises:</p> Type Description <code>    ValueError: If coordinate cannot be parsed</code> Source code in <code>src/pypopart/io/metadata.py</code> <pre><code>def parse_coordinate(value: str) -&gt; float:\n    \"\"\"\n    Parse a coordinate string to a float.\n\n    Handles various formats:\n    - Decimal degrees: \"45.5\", \"-123.4\"\n    - With degree symbol: \"45.5\u00b0\", \"-123.4\u00b0\"\n\n    Args:\n        value: Coordinate string\n\n    Returns\n    -------\n        Coordinate as float.\n\n    Raises\n    ------\n        ValueError: If coordinate cannot be parsed\n    \"\"\"\n    try:\n        # Remove degree symbol and whitespace\n        cleaned = value.strip().replace('\u00b0', '').replace(' ', '')\n        return float(cleaned)\n    except (ValueError, AttributeError) as e:\n        raise ValueError(f'Invalid coordinate value: {value}') from e\n</code></pre>"},{"location":"api/io/metadata/#pypopart.io.metadata.validate_latitude","title":"validate_latitude","text":"<pre><code>validate_latitude(lat: float) -&gt; None\n</code></pre> <p>Validate latitude value.</p> <p>Args:     lat: Latitude value</p> <p>Raises:</p> Type Description <code>    ValueError: If latitude is out of range [-90, 90]</code> Source code in <code>src/pypopart/io/metadata.py</code> <pre><code>def validate_latitude(lat: float) -&gt; None:\n    \"\"\"\n    Validate latitude value.\n\n    Args:\n        lat: Latitude value\n\n    Raises\n    ------\n        ValueError: If latitude is out of range [-90, 90]\n    \"\"\"\n    if not -90 &lt;= lat &lt;= 90:\n        raise ValueError(f'Latitude must be between -90 and 90, got {lat}')\n</code></pre>"},{"location":"api/io/metadata/#pypopart.io.metadata.validate_longitude","title":"validate_longitude","text":"<pre><code>validate_longitude(lon: float) -&gt; None\n</code></pre> <p>Validate longitude value.</p> <p>Args:     lon: Longitude value</p> <p>Raises:</p> Type Description <code>    ValueError: If longitude is out of range [-180, 180]</code> Source code in <code>src/pypopart/io/metadata.py</code> <pre><code>def validate_longitude(lon: float) -&gt; None:\n    \"\"\"\n    Validate longitude value.\n\n    Args:\n        lon: Longitude value\n\n    Raises\n    ------\n        ValueError: If longitude is out of range [-180, 180]\n    \"\"\"\n    if not -180 &lt;= lon &lt;= 180:\n        raise ValueError(f'Longitude must be between -180 and 180, got {lon}')\n</code></pre>"},{"location":"api/io/metadata/#pypopart.io.metadata.extract_coordinates","title":"extract_coordinates","text":"<pre><code>extract_coordinates(\n    metadata: Dict[str, str],\n    lat_column: str = \"latitude\",\n    lon_column: str = \"longitude\",\n    validate: bool = True,\n) -&gt; Optional[Tuple[float, float]]\n</code></pre> <p>Extract and validate geographic coordinates from metadata.</p> <p>Args:     metadata: Metadata dictionary     lat_column: Name of latitude column     lon_column: Name of longitude column     validate: Whether to validate coordinate ranges</p> <p>Returns:</p> Type Description <code>    Tuple of (latitude, longitude) or None if coordinates not present.</code> <p>Raises:</p> Type Description <code>    ValueError: If coordinates are invalid</code> Source code in <code>src/pypopart/io/metadata.py</code> <pre><code>def extract_coordinates(\n    metadata: Dict[str, str],\n    lat_column: str = 'latitude',\n    lon_column: str = 'longitude',\n    validate: bool = True,\n) -&gt; Optional[Tuple[float, float]]:\n    \"\"\"\n    Extract and validate geographic coordinates from metadata.\n\n    Args:\n        metadata: Metadata dictionary\n        lat_column: Name of latitude column\n        lon_column: Name of longitude column\n        validate: Whether to validate coordinate ranges\n\n    Returns\n    -------\n        Tuple of (latitude, longitude) or None if coordinates not present.\n\n    Raises\n    ------\n        ValueError: If coordinates are invalid\n    \"\"\"\n    if lat_column not in metadata or lon_column not in metadata:\n        return None\n\n    lat = parse_coordinate(metadata[lat_column])\n    lon = parse_coordinate(metadata[lon_column])\n\n    if validate:\n        validate_latitude(lat)\n        validate_longitude(lon)\n\n    return (lat, lon)\n</code></pre>"},{"location":"api/io/readers/","title":"File Readers","text":"<p>Input file parsers for various sequence formats.</p>"},{"location":"api/io/readers/#overview","title":"Overview","text":"<p>PyPopART supports multiple sequence file formats:</p> <ul> <li>FASTA: Most common format</li> <li>NEXUS: With metadata support</li> <li>PHYLIP: Sequential and interleaved</li> <li>GenBank: Full GenBank entries</li> </ul>"},{"location":"api/io/readers/#modules","title":"Modules","text":""},{"location":"api/io/readers/#pypopart.io.fasta","title":"pypopart.io.fasta","text":"<p>FASTA file format reader and writer for PyPopART.</p>"},{"location":"api/io/readers/#pypopart.io.fasta.FastaReader","title":"FastaReader","text":"<p>Reader for FASTA format sequence files.</p> <p>Supports plain text, gzip, and zip compressed files.</p> Source code in <code>src/pypopart/io/fasta.py</code> <pre><code>class FastaReader:\n    \"\"\"\n    Reader for FASTA format sequence files.\n\n    Supports plain text, gzip, and zip compressed files.\n    \"\"\"\n\n    def __init__(self, filepath: Union[str, Path], validate: bool = True):\n        \"\"\"\n        Initialize FASTA reader.\n\n        Parameters\n        ----------\n        filepath :\n            Path to FASTA file.\n        validate :\n            Whether to validate sequences.\n        \"\"\"\n        self.filepath = Path(filepath)\n        self.validate = validate\n\n        if not self.filepath.exists():\n            raise FileNotFoundError(f'File not found: {filepath}')\n\n    def _open_file(self) -&gt; TextIO:\n        \"\"\"\n        Open file handling compression automatically.\n\n        Returns\n        -------\n            File handle.\n        \"\"\"\n        if self.filepath.suffix == '.gz':\n            return gzip.open(self.filepath, 'rt')\n        elif self.filepath.suffix == '.zip':\n            with zipfile.ZipFile(self.filepath) as zf:\n                # Assume first file in zip is the FASTA\n                names = zf.namelist()\n                if not names:\n                    raise ValueError('Empty zip file')\n                return zf.open(names[0], 'r')\n        else:\n            return open(self.filepath, 'r')\n\n    def read_sequences(self, progress_callback=None) -&gt; Iterator[Sequence]:\n        \"\"\"\n        Read sequences from FASTA file.\n\n        Parameters\n        ----------\n        progress_callback :\n            Optional callback function(current, total).\n\n        Yields :\n            Sequence objects.\n        \"\"\"\n        count = 0\n        with self._open_file() as handle:\n            for record in SeqIO.parse(handle, 'fasta'):\n                # Extract metadata from description\n                metadata = {}\n                if '|' in record.description:\n                    # Parse pipe-separated metadata\n                    parts = record.description.split('|')\n                    if len(parts) &gt; 1:\n                        for part in parts[1:]:\n                            if '=' in part:\n                                key, value = part.split('=', 1)\n                                metadata[key.strip()] = value.strip()\n\n                seq = Sequence(\n                    id=record.id,\n                    data=str(record.seq).upper(),\n                    description=record.description,\n                    metadata=metadata,\n                )\n\n                # Validation happens automatically in Sequence.__init__\n\n                count += 1\n                if progress_callback:\n                    progress_callback(count, None)\n\n                yield seq\n\n    def read_alignment(self, progress_callback=None) -&gt; Alignment:\n        \"\"\"\n            Read alignment from FASTA file.\n\n        Parameters\n        ----------\n            progress_callback :\n                Optional callback function(current, total).\n\n        Returns\n        -------\n            Alignment object.\n        \"\"\"\n        sequences = list(self.read_sequences(progress_callback))\n        alignment = Alignment(sequences)\n\n        if self.validate:\n            alignment.validate()\n\n        return alignment\n</code></pre>"},{"location":"api/io/readers/#pypopart.io.fasta.FastaReader.__init__","title":"__init__","text":"<pre><code>__init__(filepath: Union[str, Path], validate: bool = True)\n</code></pre> <p>Initialize FASTA reader.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>Union[str, Path]</code> <p>Path to FASTA file.</p> required <code>validate</code> <code>bool</code> <p>Whether to validate sequences.</p> <code>True</code> Source code in <code>src/pypopart/io/fasta.py</code> <pre><code>def __init__(self, filepath: Union[str, Path], validate: bool = True):\n    \"\"\"\n    Initialize FASTA reader.\n\n    Parameters\n    ----------\n    filepath :\n        Path to FASTA file.\n    validate :\n        Whether to validate sequences.\n    \"\"\"\n    self.filepath = Path(filepath)\n    self.validate = validate\n\n    if not self.filepath.exists():\n        raise FileNotFoundError(f'File not found: {filepath}')\n</code></pre>"},{"location":"api/io/readers/#pypopart.io.fasta.FastaReader.read_sequences","title":"read_sequences","text":"<pre><code>read_sequences(\n    progress_callback=None,\n) -&gt; Iterator[Sequence]\n</code></pre> <p>Read sequences from FASTA file.</p> <p>Parameters:</p> Name Type Description Default <code>progress_callback</code> <p>Optional callback function(current, total).</p> <code>None</code> <code>Yields</code> <p>Sequence objects.</p> required Source code in <code>src/pypopart/io/fasta.py</code> <pre><code>def read_sequences(self, progress_callback=None) -&gt; Iterator[Sequence]:\n    \"\"\"\n    Read sequences from FASTA file.\n\n    Parameters\n    ----------\n    progress_callback :\n        Optional callback function(current, total).\n\n    Yields :\n        Sequence objects.\n    \"\"\"\n    count = 0\n    with self._open_file() as handle:\n        for record in SeqIO.parse(handle, 'fasta'):\n            # Extract metadata from description\n            metadata = {}\n            if '|' in record.description:\n                # Parse pipe-separated metadata\n                parts = record.description.split('|')\n                if len(parts) &gt; 1:\n                    for part in parts[1:]:\n                        if '=' in part:\n                            key, value = part.split('=', 1)\n                            metadata[key.strip()] = value.strip()\n\n            seq = Sequence(\n                id=record.id,\n                data=str(record.seq).upper(),\n                description=record.description,\n                metadata=metadata,\n            )\n\n            # Validation happens automatically in Sequence.__init__\n\n            count += 1\n            if progress_callback:\n                progress_callback(count, None)\n\n            yield seq\n</code></pre>"},{"location":"api/io/readers/#pypopart.io.fasta.FastaReader.read_alignment","title":"read_alignment","text":"<pre><code>read_alignment(progress_callback=None) -&gt; Alignment\n</code></pre> <pre><code>Read alignment from FASTA file.\n</code></pre> <p>Returns:</p> Type Description <code>    Alignment object.</code> Source code in <code>src/pypopart/io/fasta.py</code> <pre><code>def read_alignment(self, progress_callback=None) -&gt; Alignment:\n    \"\"\"\n        Read alignment from FASTA file.\n\n    Parameters\n    ----------\n        progress_callback :\n            Optional callback function(current, total).\n\n    Returns\n    -------\n        Alignment object.\n    \"\"\"\n    sequences = list(self.read_sequences(progress_callback))\n    alignment = Alignment(sequences)\n\n    if self.validate:\n        alignment.validate()\n\n    return alignment\n</code></pre>"},{"location":"api/io/readers/#pypopart.io.fasta.FastaWriter","title":"FastaWriter","text":"<p>Writer for FASTA format sequence files.</p> Source code in <code>src/pypopart/io/fasta.py</code> <pre><code>class FastaWriter:\n    \"\"\"Writer for FASTA format sequence files.\"\"\"\n\n    def __init__(\n        self,\n        filepath: Union[str, Path],\n        line_length: int = 80,\n        compress: Optional[str] = None,\n    ):\n        \"\"\"\n        Initialize FASTA writer.\n\n        Parameters\n        ----------\n        filepath :\n            Output file path.\n        line_length :\n            Maximum line length for sequences (0 for no wrapping).\n        compress :\n            Compression format ('gzip' or None).\n        \"\"\"\n        self.filepath = Path(filepath)\n        self.line_length = line_length\n        self.compress = compress\n\n        # Add compression extension if needed\n        if compress == 'gzip' and not str(self.filepath).endswith('.gz'):\n            self.filepath = Path(str(self.filepath) + '.gz')\n\n    def _open_file(self) -&gt; TextIO:\n        \"\"\"\n        Open file for writing with optional compression.\n\n        Returns\n        -------\n            File handle.\n        \"\"\"\n        if self.compress == 'gzip':\n            return gzip.open(self.filepath, 'wt')\n        else:\n            return open(self.filepath, 'w')\n\n    def write_sequences(\n        self, sequences: Iterator[Sequence], progress_callback=None\n    ) -&gt; int:\n        \"\"\"\n            Write sequences to FASTA file.\n\n        Parameters\n        ----------\n            sequences :\n                Iterable of Sequence objects.\n            progress_callback :\n                Optional callback function(current, total).\n\n        Returns\n        -------\n            Number of sequences written.\n        \"\"\"\n        count = 0\n\n        with self._open_file() as handle:\n            for seq in sequences:\n                # Build header\n                header = f'&gt;{seq.id}'\n                if seq.description and seq.description != seq.id:\n                    header = f'&gt;{seq.description}'\n\n                # Add metadata to header\n                if seq.metadata:\n                    metadata_str = '|'.join(f'{k}={v}' for k, v in seq.metadata.items())\n                    header += f'|{metadata_str}'\n\n                handle.write(header + '\\n')\n\n                # Write sequence data with line wrapping\n                if self.line_length &gt; 0:\n                    for i in range(0, len(seq.data), self.line_length):\n                        handle.write(seq.data[i : i + self.line_length] + '\\n')\n                else:\n                    handle.write(seq.data + '\\n')\n\n                count += 1\n                if progress_callback:\n                    progress_callback(count, None)\n\n        return count\n\n    def write_alignment(self, alignment: Alignment, progress_callback=None) -&gt; int:\n        \"\"\"\n            Write alignment to FASTA file.\n\n        Parameters\n        ----------\n            alignment :\n                Alignment object.\n            progress_callback :\n                Optional callback function(current, total).\n\n        Returns\n        -------\n            Number of sequences written.\n        \"\"\"\n        return self.write_sequences(iter(alignment), progress_callback)\n</code></pre>"},{"location":"api/io/readers/#pypopart.io.fasta.FastaWriter.__init__","title":"__init__","text":"<pre><code>__init__(\n    filepath: Union[str, Path],\n    line_length: int = 80,\n    compress: Optional[str] = None,\n)\n</code></pre> <p>Initialize FASTA writer.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>Union[str, Path]</code> <p>Output file path.</p> required <code>line_length</code> <code>int</code> <p>Maximum line length for sequences (0 for no wrapping).</p> <code>80</code> <code>compress</code> <code>Optional[str]</code> <p>Compression format ('gzip' or None).</p> <code>None</code> Source code in <code>src/pypopart/io/fasta.py</code> <pre><code>def __init__(\n    self,\n    filepath: Union[str, Path],\n    line_length: int = 80,\n    compress: Optional[str] = None,\n):\n    \"\"\"\n    Initialize FASTA writer.\n\n    Parameters\n    ----------\n    filepath :\n        Output file path.\n    line_length :\n        Maximum line length for sequences (0 for no wrapping).\n    compress :\n        Compression format ('gzip' or None).\n    \"\"\"\n    self.filepath = Path(filepath)\n    self.line_length = line_length\n    self.compress = compress\n\n    # Add compression extension if needed\n    if compress == 'gzip' and not str(self.filepath).endswith('.gz'):\n        self.filepath = Path(str(self.filepath) + '.gz')\n</code></pre>"},{"location":"api/io/readers/#pypopart.io.fasta.FastaWriter.write_sequences","title":"write_sequences","text":"<pre><code>write_sequences(\n    sequences: Iterator[Sequence], progress_callback=None\n) -&gt; int\n</code></pre> <pre><code>Write sequences to FASTA file.\n</code></pre> <p>Returns:</p> Type Description <code>    Number of sequences written.</code> Source code in <code>src/pypopart/io/fasta.py</code> <pre><code>def write_sequences(\n    self, sequences: Iterator[Sequence], progress_callback=None\n) -&gt; int:\n    \"\"\"\n        Write sequences to FASTA file.\n\n    Parameters\n    ----------\n        sequences :\n            Iterable of Sequence objects.\n        progress_callback :\n            Optional callback function(current, total).\n\n    Returns\n    -------\n        Number of sequences written.\n    \"\"\"\n    count = 0\n\n    with self._open_file() as handle:\n        for seq in sequences:\n            # Build header\n            header = f'&gt;{seq.id}'\n            if seq.description and seq.description != seq.id:\n                header = f'&gt;{seq.description}'\n\n            # Add metadata to header\n            if seq.metadata:\n                metadata_str = '|'.join(f'{k}={v}' for k, v in seq.metadata.items())\n                header += f'|{metadata_str}'\n\n            handle.write(header + '\\n')\n\n            # Write sequence data with line wrapping\n            if self.line_length &gt; 0:\n                for i in range(0, len(seq.data), self.line_length):\n                    handle.write(seq.data[i : i + self.line_length] + '\\n')\n            else:\n                handle.write(seq.data + '\\n')\n\n            count += 1\n            if progress_callback:\n                progress_callback(count, None)\n\n    return count\n</code></pre>"},{"location":"api/io/readers/#pypopart.io.fasta.FastaWriter.write_alignment","title":"write_alignment","text":"<pre><code>write_alignment(\n    alignment: Alignment, progress_callback=None\n) -&gt; int\n</code></pre> <pre><code>Write alignment to FASTA file.\n</code></pre> <p>Returns:</p> Type Description <code>    Number of sequences written.</code> Source code in <code>src/pypopart/io/fasta.py</code> <pre><code>def write_alignment(self, alignment: Alignment, progress_callback=None) -&gt; int:\n    \"\"\"\n        Write alignment to FASTA file.\n\n    Parameters\n    ----------\n        alignment :\n            Alignment object.\n        progress_callback :\n            Optional callback function(current, total).\n\n    Returns\n    -------\n        Number of sequences written.\n    \"\"\"\n    return self.write_sequences(iter(alignment), progress_callback)\n</code></pre>"},{"location":"api/io/readers/#pypopart.io.nexus","title":"pypopart.io.nexus","text":"<p>NEXUS file format reader and writer for PyPopART.</p> <p>Supports PopART-style NEXUS files with traits blocks.</p>"},{"location":"api/io/readers/#pypopart.io.nexus.NexusReader","title":"NexusReader","text":"<p>Reader for NEXUS format files.</p> <p>Supports PopART-style NEXUS with traits blocks.</p> Source code in <code>src/pypopart/io/nexus.py</code> <pre><code>class NexusReader:\n    \"\"\"\n    Reader for NEXUS format files.\n\n    Supports PopART-style NEXUS with traits blocks.\n    \"\"\"\n\n    def __init__(self, filepath: Union[str, Path], validate: bool = True):\n        \"\"\"\n        Initialize NEXUS reader.\n\n        Parameters\n        ----------\n        filepath :\n            Path to NEXUS file.\n        validate :\n            Whether to validate sequences and alignment.\n        \"\"\"\n        self.filepath = Path(filepath)\n        self.validate = validate\n\n        if not self.filepath.exists():\n            raise FileNotFoundError(f'File not found: {filepath}')\n\n        self.traits = {}\n\n    def _open_file(self) -&gt; TextIO:\n        \"\"\"Open file handling gzip compression.\"\"\"\n        if self.filepath.suffix == '.gz':\n            return gzip.open(self.filepath, 'rt')\n        else:\n            return open(self.filepath, 'r')\n\n    def _parse_dimensions(self, content: str) -&gt; Tuple[int, int]:\n        \"\"\"\n            Parse DIMENSIONS block.\n\n        Parameters\n        ----------\n            content :\n                NEXUS file content.\n\n        Returns\n        -------\n            Tuple of (ntax, nchar).\n        \"\"\"\n        dimensions_match = re.search(\n            r'DIMENSIONS\\s+NTAX=(\\d+)\\s+NCHAR=(\\d+)', content, re.IGNORECASE\n        )\n\n        if dimensions_match:\n            ntax = int(dimensions_match.group(1))\n            nchar = int(dimensions_match.group(2))\n            return ntax, nchar\n\n        return 0, 0\n\n    def _parse_matrix(self, content: str) -&gt; Dict[str, str]:\n        \"\"\"\n            Parse MATRIX block.\n\n        Parameters\n        ----------\n            content :\n                NEXUS file content.\n\n        Returns\n        -------\n            Dictionary mapping sequence IDs to sequence data.\n        \"\"\"\n        sequences = {}\n\n        # Find MATRIX block\n        matrix_match = re.search(\n            r'MATRIX\\s+(.*?);\\s*END;', content, re.IGNORECASE | re.DOTALL\n        )\n\n        if not matrix_match:\n            raise ValueError('No MATRIX block found in NEXUS file')\n\n        matrix_content = matrix_match.group(1)\n\n        # Parse sequences (handle both interleaved and sequential formats)\n        current_id = None\n\n        for line in matrix_content.split('\\n'):\n            line = line.strip()\n            if not line:\n                continue\n\n            # Check if line starts with sequence ID\n            parts = line.split(None, 1)\n            if len(parts) == 2:\n                seq_id, seq_data = parts\n                seq_data = seq_data.replace(' ', '').replace('\\t', '')\n\n                if seq_id in sequences:\n                    # Interleaved format - append to existing sequence\n                    sequences[seq_id] += seq_data\n                else:\n                    # New sequence\n                    sequences[seq_id] = seq_data\n            elif len(parts) == 1:\n                # Continuation of previous sequence\n                seq_data = parts[0].replace(' ', '').replace('\\t', '')\n                if current_id:\n                    sequences[current_id] += seq_data\n\n        return sequences\n\n    def _parse_traits(self, content: str) -&gt; Dict[str, Dict[str, str]]:\n        \"\"\"\n            Parse TRAITS block (PopART extension).\n\n        Parameters\n        ----------\n            content :\n                NEXUS file content.\n\n        Returns\n        -------\n            Dictionary mapping sequence IDs to trait dictionaries.\n        \"\"\"\n        traits = {}\n\n        # Find TRAITS block\n        traits_match = re.search(\n            r'BEGIN TRAITS;(.*?)END;', content, re.IGNORECASE | re.DOTALL\n        )\n\n        if not traits_match:\n            return traits\n\n        traits_content = traits_match.group(1)\n\n        # Parse TRAITLABELS\n        labels_match = re.search(r'TRAITLABELS\\s+(.*?);', traits_content, re.IGNORECASE)\n\n        trait_labels = []\n        if labels_match:\n            trait_labels = labels_match.group(1).split()\n\n        # Parse MATRIX\n        matrix_match = re.search(\n            r'MATRIX\\s+(.*?);', traits_content, re.IGNORECASE | re.DOTALL\n        )\n\n        if matrix_match:\n            matrix_content = matrix_match.group(1)\n            for line in matrix_content.split('\\n'):\n                line = line.strip()\n                if not line:\n                    continue\n\n                parts = line.split()\n                if len(parts) &gt;= 2:\n                    seq_id = parts[0]\n                    trait_values = parts[1:]\n\n                    traits[seq_id] = {}\n                    for i, value in enumerate(trait_values):\n                        label = (\n                            trait_labels[i] if i &lt; len(trait_labels) else f'trait_{i}'\n                        )\n                        traits[seq_id][label] = value\n\n        return traits\n\n    def read_alignment(self, progress_callback=None) -&gt; Alignment:\n        \"\"\"\n            Read alignment from NEXUS file.\n\n        Parameters\n        ----------\n            progress_callback :\n                Optional callback function(current, total).\n\n        Returns\n        -------\n            Alignment object with metadata.\n        \"\"\"\n        with self._open_file() as handle:\n            content = handle.read()\n\n        # Parse dimensions\n        ntax, nchar = self._parse_dimensions(content)\n\n        # Parse sequences\n        seq_dict = self._parse_matrix(content)\n\n        # Parse traits\n        self.traits = self._parse_traits(content)\n\n        # Create Sequence objects\n        sequences = []\n        count = 0\n\n        for seq_id, seq_data in seq_dict.items():\n            metadata = self.traits.get(seq_id, {})\n\n            seq = Sequence(id=seq_id, data=seq_data.upper(), metadata=metadata)\n\n            # Validation happens automatically in Sequence.__init__\n\n            sequences.append(seq)\n\n            count += 1\n            if progress_callback:\n                progress_callback(count, ntax)\n\n        alignment = Alignment(sequences)\n\n        if self.validate:\n            alignment.validate()\n\n        return alignment\n\n    def get_traits(self) -&gt; Dict[str, Dict[str, str]]:\n        \"\"\"\n        Get parsed traits/metadata.\n\n        Returns\n        -------\n            Dictionary mapping sequence IDs to trait dictionaries.\n        \"\"\"\n        return self.traits\n</code></pre>"},{"location":"api/io/readers/#pypopart.io.nexus.NexusReader.__init__","title":"__init__","text":"<pre><code>__init__(filepath: Union[str, Path], validate: bool = True)\n</code></pre> <p>Initialize NEXUS reader.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>Union[str, Path]</code> <p>Path to NEXUS file.</p> required <code>validate</code> <code>bool</code> <p>Whether to validate sequences and alignment.</p> <code>True</code> Source code in <code>src/pypopart/io/nexus.py</code> <pre><code>def __init__(self, filepath: Union[str, Path], validate: bool = True):\n    \"\"\"\n    Initialize NEXUS reader.\n\n    Parameters\n    ----------\n    filepath :\n        Path to NEXUS file.\n    validate :\n        Whether to validate sequences and alignment.\n    \"\"\"\n    self.filepath = Path(filepath)\n    self.validate = validate\n\n    if not self.filepath.exists():\n        raise FileNotFoundError(f'File not found: {filepath}')\n\n    self.traits = {}\n</code></pre>"},{"location":"api/io/readers/#pypopart.io.nexus.NexusReader.read_alignment","title":"read_alignment","text":"<pre><code>read_alignment(progress_callback=None) -&gt; Alignment\n</code></pre> <pre><code>Read alignment from NEXUS file.\n</code></pre> <p>Returns:</p> Type Description <code>    Alignment object with metadata.</code> Source code in <code>src/pypopart/io/nexus.py</code> <pre><code>def read_alignment(self, progress_callback=None) -&gt; Alignment:\n    \"\"\"\n        Read alignment from NEXUS file.\n\n    Parameters\n    ----------\n        progress_callback :\n            Optional callback function(current, total).\n\n    Returns\n    -------\n        Alignment object with metadata.\n    \"\"\"\n    with self._open_file() as handle:\n        content = handle.read()\n\n    # Parse dimensions\n    ntax, nchar = self._parse_dimensions(content)\n\n    # Parse sequences\n    seq_dict = self._parse_matrix(content)\n\n    # Parse traits\n    self.traits = self._parse_traits(content)\n\n    # Create Sequence objects\n    sequences = []\n    count = 0\n\n    for seq_id, seq_data in seq_dict.items():\n        metadata = self.traits.get(seq_id, {})\n\n        seq = Sequence(id=seq_id, data=seq_data.upper(), metadata=metadata)\n\n        # Validation happens automatically in Sequence.__init__\n\n        sequences.append(seq)\n\n        count += 1\n        if progress_callback:\n            progress_callback(count, ntax)\n\n    alignment = Alignment(sequences)\n\n    if self.validate:\n        alignment.validate()\n\n    return alignment\n</code></pre>"},{"location":"api/io/readers/#pypopart.io.nexus.NexusReader.get_traits","title":"get_traits","text":"<pre><code>get_traits() -&gt; Dict[str, Dict[str, str]]\n</code></pre> <p>Get parsed traits/metadata.</p> <p>Returns:</p> Type Description <code>    Dictionary mapping sequence IDs to trait dictionaries.</code> Source code in <code>src/pypopart/io/nexus.py</code> <pre><code>def get_traits(self) -&gt; Dict[str, Dict[str, str]]:\n    \"\"\"\n    Get parsed traits/metadata.\n\n    Returns\n    -------\n        Dictionary mapping sequence IDs to trait dictionaries.\n    \"\"\"\n    return self.traits\n</code></pre>"},{"location":"api/io/readers/#pypopart.io.nexus.NexusWriter","title":"NexusWriter","text":"<p>Writer for NEXUS format files.</p> <p>Supports PopART-style NEXUS with traits blocks.</p> Source code in <code>src/pypopart/io/nexus.py</code> <pre><code>class NexusWriter:\n    \"\"\"\n    Writer for NEXUS format files.\n\n    Supports PopART-style NEXUS with traits blocks.\n    \"\"\"\n\n    def __init__(\n        self,\n        filepath: Union[str, Path],\n        interleaved: bool = False,\n        compress: Optional[str] = None,\n    ):\n        \"\"\"\n        Initialize NEXUS writer.\n\n        Parameters\n        ----------\n        filepath :\n            Output file path.\n        interleaved :\n            Whether to write in interleaved format.\n        compress :\n            Compression format ('gzip' or None).\n        \"\"\"\n        self.filepath = Path(filepath)\n        self.interleaved = interleaved\n        self.compress = compress\n\n        if compress == 'gzip' and not str(self.filepath).endswith('.gz'):\n            self.filepath = Path(str(self.filepath) + '.gz')\n\n    def _open_file(self) -&gt; TextIO:\n        \"\"\"Open file for writing with optional compression.\"\"\"\n        if self.compress == 'gzip':\n            return gzip.open(self.filepath, 'wt')\n        else:\n            return open(self.filepath, 'w')\n\n    def write_alignment(\n        self, alignment: Alignment, include_traits: bool = True, progress_callback=None\n    ) -&gt; None:\n        \"\"\"\n        Write alignment to NEXUS file.\n\n        Parameters\n        ----------\n        alignment :\n            Alignment object.\n        include_traits :\n            Whether to include traits block.\n        progress_callback :\n            Optional callback function(current, total).\n        \"\"\"\n        with self._open_file() as handle:\n            # Write header\n            handle.write('#NEXUS\\n\\n')\n\n            # Write DATA block\n            handle.write('BEGIN DATA;\\n')\n            handle.write(\n                f'  DIMENSIONS NTAX={len(alignment)} NCHAR={alignment.length};\\n'\n            )\n            handle.write('  FORMAT DATATYPE=DNA MISSING=? GAP=-;\\n')\n            handle.write('  MATRIX\\n')\n\n            # Write sequences\n            count = 0\n            for seq in alignment:\n                # Pad ID to align sequences\n                padded_id = seq.id.ljust(20)\n                handle.write(f'    {padded_id} {seq.data}\\n')\n\n                count += 1\n                if progress_callback:\n                    progress_callback(count, len(alignment))\n\n            handle.write('  ;\\n')\n            handle.write('END;\\n')\n\n            # Write TRAITS block if requested and metadata exists\n            if include_traits:\n                # Collect all trait keys\n                all_traits = set()\n                for seq in alignment:\n                    all_traits.update(seq.metadata.keys())\n\n                if all_traits:\n                    handle.write('\\n')\n                    handle.write('BEGIN TRAITS;\\n')\n                    handle.write('  DIMENSIONS NTRAITS={};\\n'.format(len(all_traits)))\n\n                    # Write trait labels\n                    trait_list = sorted(all_traits)\n                    handle.write('  TRAITLABELS {};\\n'.format(' '.join(trait_list)))\n\n                    # Write trait matrix\n                    handle.write('  MATRIX\\n')\n                    for seq in alignment:\n                        padded_id = seq.id.ljust(20)\n                        trait_values = [\n                            str(seq.metadata.get(trait, '?')) for trait in trait_list\n                        ]\n                        handle.write(f'    {padded_id} {\" \".join(trait_values)}\\n')\n\n                    handle.write('  ;\\n')\n                    handle.write('END;\\n')\n</code></pre>"},{"location":"api/io/readers/#pypopart.io.nexus.NexusWriter.__init__","title":"__init__","text":"<pre><code>__init__(\n    filepath: Union[str, Path],\n    interleaved: bool = False,\n    compress: Optional[str] = None,\n)\n</code></pre> <p>Initialize NEXUS writer.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>Union[str, Path]</code> <p>Output file path.</p> required <code>interleaved</code> <code>bool</code> <p>Whether to write in interleaved format.</p> <code>False</code> <code>compress</code> <code>Optional[str]</code> <p>Compression format ('gzip' or None).</p> <code>None</code> Source code in <code>src/pypopart/io/nexus.py</code> <pre><code>def __init__(\n    self,\n    filepath: Union[str, Path],\n    interleaved: bool = False,\n    compress: Optional[str] = None,\n):\n    \"\"\"\n    Initialize NEXUS writer.\n\n    Parameters\n    ----------\n    filepath :\n        Output file path.\n    interleaved :\n        Whether to write in interleaved format.\n    compress :\n        Compression format ('gzip' or None).\n    \"\"\"\n    self.filepath = Path(filepath)\n    self.interleaved = interleaved\n    self.compress = compress\n\n    if compress == 'gzip' and not str(self.filepath).endswith('.gz'):\n        self.filepath = Path(str(self.filepath) + '.gz')\n</code></pre>"},{"location":"api/io/readers/#pypopart.io.nexus.NexusWriter.write_alignment","title":"write_alignment","text":"<pre><code>write_alignment(\n    alignment: Alignment,\n    include_traits: bool = True,\n    progress_callback=None,\n) -&gt; None\n</code></pre> <p>Write alignment to NEXUS file.</p> <p>Parameters:</p> Name Type Description Default <code>alignment</code> <code>Alignment</code> <p>Alignment object.</p> required <code>include_traits</code> <code>bool</code> <p>Whether to include traits block.</p> <code>True</code> <code>progress_callback</code> <p>Optional callback function(current, total).</p> <code>None</code> Source code in <code>src/pypopart/io/nexus.py</code> <pre><code>def write_alignment(\n    self, alignment: Alignment, include_traits: bool = True, progress_callback=None\n) -&gt; None:\n    \"\"\"\n    Write alignment to NEXUS file.\n\n    Parameters\n    ----------\n    alignment :\n        Alignment object.\n    include_traits :\n        Whether to include traits block.\n    progress_callback :\n        Optional callback function(current, total).\n    \"\"\"\n    with self._open_file() as handle:\n        # Write header\n        handle.write('#NEXUS\\n\\n')\n\n        # Write DATA block\n        handle.write('BEGIN DATA;\\n')\n        handle.write(\n            f'  DIMENSIONS NTAX={len(alignment)} NCHAR={alignment.length};\\n'\n        )\n        handle.write('  FORMAT DATATYPE=DNA MISSING=? GAP=-;\\n')\n        handle.write('  MATRIX\\n')\n\n        # Write sequences\n        count = 0\n        for seq in alignment:\n            # Pad ID to align sequences\n            padded_id = seq.id.ljust(20)\n            handle.write(f'    {padded_id} {seq.data}\\n')\n\n            count += 1\n            if progress_callback:\n                progress_callback(count, len(alignment))\n\n        handle.write('  ;\\n')\n        handle.write('END;\\n')\n\n        # Write TRAITS block if requested and metadata exists\n        if include_traits:\n            # Collect all trait keys\n            all_traits = set()\n            for seq in alignment:\n                all_traits.update(seq.metadata.keys())\n\n            if all_traits:\n                handle.write('\\n')\n                handle.write('BEGIN TRAITS;\\n')\n                handle.write('  DIMENSIONS NTRAITS={};\\n'.format(len(all_traits)))\n\n                # Write trait labels\n                trait_list = sorted(all_traits)\n                handle.write('  TRAITLABELS {};\\n'.format(' '.join(trait_list)))\n\n                # Write trait matrix\n                handle.write('  MATRIX\\n')\n                for seq in alignment:\n                    padded_id = seq.id.ljust(20)\n                    trait_values = [\n                        str(seq.metadata.get(trait, '?')) for trait in trait_list\n                    ]\n                    handle.write(f'    {padded_id} {\" \".join(trait_values)}\\n')\n\n                handle.write('  ;\\n')\n                handle.write('END;\\n')\n</code></pre>"},{"location":"api/io/readers/#pypopart.io.phylip","title":"pypopart.io.phylip","text":"<p>PHYLIP file format reader and writer for PyPopART.</p>"},{"location":"api/io/readers/#pypopart.io.phylip.PhylipReader","title":"PhylipReader","text":"<p>Reader for PHYLIP format sequence files.</p> <p>Supports both sequential and interleaved formats.</p> Source code in <code>src/pypopart/io/phylip.py</code> <pre><code>class PhylipReader:\n    \"\"\"\n    Reader for PHYLIP format sequence files.\n\n    Supports both sequential and interleaved formats.\n    \"\"\"\n\n    def __init__(\n        self, filepath: Union[str, Path], strict: bool = False, validate: bool = True\n    ):\n        \"\"\"\n        Initialize PHYLIP reader.\n\n        Parameters\n        ----------\n        filepath :\n            Path to PHYLIP file.\n        strict :\n            Whether to use strict format (10-char IDs).\n        validate :\n            Whether to validate sequences and alignment.\n        \"\"\"\n        self.filepath = Path(filepath)\n        self.strict = strict\n        self.validate = validate\n\n        if not self.filepath.exists():\n            raise FileNotFoundError(f'File not found: {filepath}')\n\n    def _open_file(self) -&gt; TextIO:\n        \"\"\"Open file handling gzip compression.\"\"\"\n        if self.filepath.suffix == '.gz':\n            return gzip.open(self.filepath, 'rt')\n        else:\n            return open(self.filepath, 'r')\n\n    def read_alignment(self, progress_callback=None) -&gt; Alignment:\n        \"\"\"\n            Read alignment from PHYLIP file.\n\n        Parameters\n        ----------\n            progress_callback :\n                Optional callback function(current, total).\n\n        Returns\n        -------\n            Alignment object.\n        \"\"\"\n        with self._open_file() as handle:\n            lines = [line.rstrip() for line in handle if line.strip()]\n\n        if not lines:\n            raise ValueError('Empty PHYLIP file')\n\n        # Parse header\n        header_parts = lines[0].split()\n        if len(header_parts) != 2:\n            raise ValueError('Invalid PHYLIP header format')\n\n        ntax = int(header_parts[0])\n        nchar = int(header_parts[1])\n\n        # Parse sequences\n        sequences = {}\n        current_line = 1\n\n        # First pass: read sequence IDs and initial data\n        for _i in range(ntax):\n            if current_line &gt;= len(lines):\n                raise ValueError(f'Unexpected end of file (expected {ntax} sequences)')\n\n            line = lines[current_line]\n\n            if self.strict:\n                # Strict format: first 10 characters are ID\n                seq_id = line[:10].strip()\n                seq_data = line[10:].replace(' ', '').replace('\\t', '')\n            else:\n                # Relaxed format: ID separated by whitespace\n                parts = line.split(None, 1)\n                if len(parts) &lt; 1:\n                    raise ValueError(f'Invalid sequence line: {line}')\n\n                seq_id = parts[0]\n                seq_data = (\n                    parts[1].replace(' ', '').replace('\\t', '')\n                    if len(parts) &gt; 1\n                    else ''\n                )\n\n            sequences[seq_id] = seq_data\n            current_line += 1\n\n        # Check if interleaved (more lines after initial block)\n        if current_line &lt; len(lines):\n            # Interleaved format: read additional blocks\n            seq_ids = list(sequences.keys())\n\n            while current_line &lt; len(lines):\n                for seq_id in seq_ids:\n                    if current_line &gt;= len(lines):\n                        break\n\n                    line = lines[current_line].replace(' ', '').replace('\\t', '')\n                    sequences[seq_id] += line\n                    current_line += 1\n\n        # Create Sequence objects\n        seq_list = []\n        count = 0\n\n        for seq_id, seq_data in sequences.items():\n            if len(seq_data) != nchar:\n                raise ValueError(\n                    f\"Sequence {seq_id} length {len(seq_data)} doesn't match expected {nchar}\"\n                )\n\n            seq = Sequence(id=seq_id, data=seq_data.upper())\n\n            # Validation happens automatically in Sequence.__init__\n\n            seq_list.append(seq)\n\n            count += 1\n            if progress_callback:\n                progress_callback(count, ntax)\n\n        alignment = Alignment(seq_list)\n\n        if self.validate:\n            alignment.validate()\n\n        return alignment\n</code></pre>"},{"location":"api/io/readers/#pypopart.io.phylip.PhylipReader.__init__","title":"__init__","text":"<pre><code>__init__(\n    filepath: Union[str, Path],\n    strict: bool = False,\n    validate: bool = True,\n)\n</code></pre> <p>Initialize PHYLIP reader.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>Union[str, Path]</code> <p>Path to PHYLIP file.</p> required <code>strict</code> <code>bool</code> <p>Whether to use strict format (10-char IDs).</p> <code>False</code> <code>validate</code> <code>bool</code> <p>Whether to validate sequences and alignment.</p> <code>True</code> Source code in <code>src/pypopart/io/phylip.py</code> <pre><code>def __init__(\n    self, filepath: Union[str, Path], strict: bool = False, validate: bool = True\n):\n    \"\"\"\n    Initialize PHYLIP reader.\n\n    Parameters\n    ----------\n    filepath :\n        Path to PHYLIP file.\n    strict :\n        Whether to use strict format (10-char IDs).\n    validate :\n        Whether to validate sequences and alignment.\n    \"\"\"\n    self.filepath = Path(filepath)\n    self.strict = strict\n    self.validate = validate\n\n    if not self.filepath.exists():\n        raise FileNotFoundError(f'File not found: {filepath}')\n</code></pre>"},{"location":"api/io/readers/#pypopart.io.phylip.PhylipReader.read_alignment","title":"read_alignment","text":"<pre><code>read_alignment(progress_callback=None) -&gt; Alignment\n</code></pre> <pre><code>Read alignment from PHYLIP file.\n</code></pre> <p>Returns:</p> Type Description <code>    Alignment object.</code> Source code in <code>src/pypopart/io/phylip.py</code> <pre><code>def read_alignment(self, progress_callback=None) -&gt; Alignment:\n    \"\"\"\n        Read alignment from PHYLIP file.\n\n    Parameters\n    ----------\n        progress_callback :\n            Optional callback function(current, total).\n\n    Returns\n    -------\n        Alignment object.\n    \"\"\"\n    with self._open_file() as handle:\n        lines = [line.rstrip() for line in handle if line.strip()]\n\n    if not lines:\n        raise ValueError('Empty PHYLIP file')\n\n    # Parse header\n    header_parts = lines[0].split()\n    if len(header_parts) != 2:\n        raise ValueError('Invalid PHYLIP header format')\n\n    ntax = int(header_parts[0])\n    nchar = int(header_parts[1])\n\n    # Parse sequences\n    sequences = {}\n    current_line = 1\n\n    # First pass: read sequence IDs and initial data\n    for _i in range(ntax):\n        if current_line &gt;= len(lines):\n            raise ValueError(f'Unexpected end of file (expected {ntax} sequences)')\n\n        line = lines[current_line]\n\n        if self.strict:\n            # Strict format: first 10 characters are ID\n            seq_id = line[:10].strip()\n            seq_data = line[10:].replace(' ', '').replace('\\t', '')\n        else:\n            # Relaxed format: ID separated by whitespace\n            parts = line.split(None, 1)\n            if len(parts) &lt; 1:\n                raise ValueError(f'Invalid sequence line: {line}')\n\n            seq_id = parts[0]\n            seq_data = (\n                parts[1].replace(' ', '').replace('\\t', '')\n                if len(parts) &gt; 1\n                else ''\n            )\n\n        sequences[seq_id] = seq_data\n        current_line += 1\n\n    # Check if interleaved (more lines after initial block)\n    if current_line &lt; len(lines):\n        # Interleaved format: read additional blocks\n        seq_ids = list(sequences.keys())\n\n        while current_line &lt; len(lines):\n            for seq_id in seq_ids:\n                if current_line &gt;= len(lines):\n                    break\n\n                line = lines[current_line].replace(' ', '').replace('\\t', '')\n                sequences[seq_id] += line\n                current_line += 1\n\n    # Create Sequence objects\n    seq_list = []\n    count = 0\n\n    for seq_id, seq_data in sequences.items():\n        if len(seq_data) != nchar:\n            raise ValueError(\n                f\"Sequence {seq_id} length {len(seq_data)} doesn't match expected {nchar}\"\n            )\n\n        seq = Sequence(id=seq_id, data=seq_data.upper())\n\n        # Validation happens automatically in Sequence.__init__\n\n        seq_list.append(seq)\n\n        count += 1\n        if progress_callback:\n            progress_callback(count, ntax)\n\n    alignment = Alignment(seq_list)\n\n    if self.validate:\n        alignment.validate()\n\n    return alignment\n</code></pre>"},{"location":"api/io/readers/#pypopart.io.phylip.PhylipWriter","title":"PhylipWriter","text":"<p>Writer for PHYLIP format sequence files.</p> Source code in <code>src/pypopart/io/phylip.py</code> <pre><code>class PhylipWriter:\n    \"\"\"Writer for PHYLIP format sequence files.\"\"\"\n\n    def __init__(\n        self,\n        filepath: Union[str, Path],\n        strict: bool = False,\n        interleaved: bool = False,\n        line_length: int = 60,\n        compress: Optional[str] = None,\n    ):\n        \"\"\"\n        Initialize PHYLIP writer.\n\n        Parameters\n        ----------\n        filepath :\n            Output file path.\n        strict :\n            Whether to use strict format (10-char IDs).\n        interleaved :\n            Whether to write in interleaved format.\n        line_length :\n            Line length for interleaved format.\n        compress :\n            Compression format ('gzip' or None).\n        \"\"\"\n        self.filepath = Path(filepath)\n        self.strict = strict\n        self.interleaved = interleaved\n        self.line_length = line_length\n        self.compress = compress\n\n        if compress == 'gzip' and not str(self.filepath).endswith('.gz'):\n            self.filepath = Path(str(self.filepath) + '.gz')\n\n    def _open_file(self) -&gt; TextIO:\n        \"\"\"Open file for writing with optional compression.\"\"\"\n        if self.compress == 'gzip':\n            return gzip.open(self.filepath, 'wt')\n        else:\n            return open(self.filepath, 'w')\n\n    def write_alignment(self, alignment: Alignment, progress_callback=None) -&gt; None:\n        \"\"\"\n        Write alignment to PHYLIP file.\n\n        Parameters\n        ----------\n        alignment :\n            Alignment object.\n        progress_callback :\n            Optional callback function(current, total).\n        \"\"\"\n        with self._open_file() as handle:\n            # Write header\n            handle.write(f' {len(alignment)} {alignment.length}\\n')\n\n            if self.interleaved:\n                # Interleaved format\n                num_blocks = (\n                    alignment.length + self.line_length - 1\n                ) // self.line_length\n\n                for block in range(num_blocks):\n                    start = block * self.line_length\n                    end = min(start + self.line_length, alignment.length)\n\n                    for i, seq in enumerate(alignment):\n                        if block == 0:\n                            # First block: include ID\n                            if self.strict:\n                                seq_id = seq.id[:10].ljust(10)\n                            else:\n                                seq_id = seq.id.ljust(20)\n                            handle.write(f'{seq_id} {seq.data[start:end]}\\n')\n                        else:\n                            # Subsequent blocks: just sequence data\n                            handle.write(f'{seq.data[start:end]}\\n')\n\n                        if progress_callback:\n                            progress_callback(i + 1, len(alignment))\n\n                    # Blank line between blocks\n                    if block &lt; num_blocks - 1:\n                        handle.write('\\n')\n            else:\n                # Sequential format\n                for i, seq in enumerate(alignment):\n                    if self.strict:\n                        seq_id = seq.id[:10].ljust(10)\n                    else:\n                        seq_id = seq.id.ljust(20)\n\n                    handle.write(f'{seq_id} {seq.data}\\n')\n\n                    if progress_callback:\n                        progress_callback(i + 1, len(alignment))\n</code></pre>"},{"location":"api/io/readers/#pypopart.io.phylip.PhylipWriter.__init__","title":"__init__","text":"<pre><code>__init__(\n    filepath: Union[str, Path],\n    strict: bool = False,\n    interleaved: bool = False,\n    line_length: int = 60,\n    compress: Optional[str] = None,\n)\n</code></pre> <p>Initialize PHYLIP writer.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>Union[str, Path]</code> <p>Output file path.</p> required <code>strict</code> <code>bool</code> <p>Whether to use strict format (10-char IDs).</p> <code>False</code> <code>interleaved</code> <code>bool</code> <p>Whether to write in interleaved format.</p> <code>False</code> <code>line_length</code> <code>int</code> <p>Line length for interleaved format.</p> <code>60</code> <code>compress</code> <code>Optional[str]</code> <p>Compression format ('gzip' or None).</p> <code>None</code> Source code in <code>src/pypopart/io/phylip.py</code> <pre><code>def __init__(\n    self,\n    filepath: Union[str, Path],\n    strict: bool = False,\n    interleaved: bool = False,\n    line_length: int = 60,\n    compress: Optional[str] = None,\n):\n    \"\"\"\n    Initialize PHYLIP writer.\n\n    Parameters\n    ----------\n    filepath :\n        Output file path.\n    strict :\n        Whether to use strict format (10-char IDs).\n    interleaved :\n        Whether to write in interleaved format.\n    line_length :\n        Line length for interleaved format.\n    compress :\n        Compression format ('gzip' or None).\n    \"\"\"\n    self.filepath = Path(filepath)\n    self.strict = strict\n    self.interleaved = interleaved\n    self.line_length = line_length\n    self.compress = compress\n\n    if compress == 'gzip' and not str(self.filepath).endswith('.gz'):\n        self.filepath = Path(str(self.filepath) + '.gz')\n</code></pre>"},{"location":"api/io/readers/#pypopart.io.phylip.PhylipWriter.write_alignment","title":"write_alignment","text":"<pre><code>write_alignment(\n    alignment: Alignment, progress_callback=None\n) -&gt; None\n</code></pre> <p>Write alignment to PHYLIP file.</p> <p>Parameters:</p> Name Type Description Default <code>alignment</code> <code>Alignment</code> <p>Alignment object.</p> required <code>progress_callback</code> <p>Optional callback function(current, total).</p> <code>None</code> Source code in <code>src/pypopart/io/phylip.py</code> <pre><code>def write_alignment(self, alignment: Alignment, progress_callback=None) -&gt; None:\n    \"\"\"\n    Write alignment to PHYLIP file.\n\n    Parameters\n    ----------\n    alignment :\n        Alignment object.\n    progress_callback :\n        Optional callback function(current, total).\n    \"\"\"\n    with self._open_file() as handle:\n        # Write header\n        handle.write(f' {len(alignment)} {alignment.length}\\n')\n\n        if self.interleaved:\n            # Interleaved format\n            num_blocks = (\n                alignment.length + self.line_length - 1\n            ) // self.line_length\n\n            for block in range(num_blocks):\n                start = block * self.line_length\n                end = min(start + self.line_length, alignment.length)\n\n                for i, seq in enumerate(alignment):\n                    if block == 0:\n                        # First block: include ID\n                        if self.strict:\n                            seq_id = seq.id[:10].ljust(10)\n                        else:\n                            seq_id = seq.id.ljust(20)\n                        handle.write(f'{seq_id} {seq.data[start:end]}\\n')\n                    else:\n                        # Subsequent blocks: just sequence data\n                        handle.write(f'{seq.data[start:end]}\\n')\n\n                    if progress_callback:\n                        progress_callback(i + 1, len(alignment))\n\n                # Blank line between blocks\n                if block &lt; num_blocks - 1:\n                    handle.write('\\n')\n        else:\n            # Sequential format\n            for i, seq in enumerate(alignment):\n                if self.strict:\n                    seq_id = seq.id[:10].ljust(10)\n                else:\n                    seq_id = seq.id.ljust(20)\n\n                handle.write(f'{seq_id} {seq.data}\\n')\n\n                if progress_callback:\n                    progress_callback(i + 1, len(alignment))\n</code></pre>"},{"location":"api/io/readers/#pypopart.io.genbank","title":"pypopart.io.genbank","text":"<p>GenBank file format reader for PyPopART.</p>"},{"location":"api/io/readers/#pypopart.io.genbank.GenBankReader","title":"GenBankReader","text":"<p>Reader for GenBank format sequence files.</p> Source code in <code>src/pypopart/io/genbank.py</code> <pre><code>class GenBankReader:\n    \"\"\"Reader for GenBank format sequence files.\"\"\"\n\n    def __init__(self, filepath: Union[str, Path], validate: bool = True):\n        \"\"\"\n        Initialize GenBank reader.\n\n        Parameters\n        ----------\n        filepath :\n            Path to GenBank file.\n        validate :\n            Whether to validate sequences.\n        \"\"\"\n        self.filepath = Path(filepath)\n        self.validate = validate\n\n        if not self.filepath.exists():\n            raise FileNotFoundError(f'File not found: {filepath}')\n\n    def _open_file(self) -&gt; TextIO:\n        \"\"\"Open file handling gzip compression.\"\"\"\n        if self.filepath.suffix == '.gz':\n            return gzip.open(self.filepath, 'rt')\n        else:\n            return open(self.filepath, 'r')\n\n    def read_sequences(self, progress_callback=None) -&gt; Iterator[Sequence]:\n        \"\"\"\n        Read sequences from GenBank file.\n\n        Parameters\n        ----------\n        progress_callback :\n            Optional callback function(current, total).\n\n        Yields :\n            Sequence objects.\n        \"\"\"\n        count = 0\n        with self._open_file() as handle:\n            for record in SeqIO.parse(handle, 'genbank'):\n                # Extract metadata from annotations\n                metadata = {}\n\n                if record.annotations:\n                    # Add relevant annotations as metadata\n                    for key in ['organism', 'source', 'taxonomy', 'date']:\n                        if key in record.annotations:\n                            value = record.annotations[key]\n                            if isinstance(value, list):\n                                value = '; '.join(str(v) for v in value)\n                            metadata[key] = str(value)\n\n                # Add features as metadata if present\n                if record.features:\n                    feature_types = {f.type for f in record.features}\n                    metadata['features'] = ', '.join(feature_types)\n\n                seq = Sequence(\n                    id=record.id,\n                    data=str(record.seq).upper(),\n                    description=record.description,\n                    metadata=metadata,\n                )\n\n                # Validation happens automatically in Sequence.__init__\n\n                count += 1\n                if progress_callback:\n                    progress_callback(count, None)\n\n                yield seq\n</code></pre>"},{"location":"api/io/readers/#pypopart.io.genbank.GenBankReader.__init__","title":"__init__","text":"<pre><code>__init__(filepath: Union[str, Path], validate: bool = True)\n</code></pre> <p>Initialize GenBank reader.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>Union[str, Path]</code> <p>Path to GenBank file.</p> required <code>validate</code> <code>bool</code> <p>Whether to validate sequences.</p> <code>True</code> Source code in <code>src/pypopart/io/genbank.py</code> <pre><code>def __init__(self, filepath: Union[str, Path], validate: bool = True):\n    \"\"\"\n    Initialize GenBank reader.\n\n    Parameters\n    ----------\n    filepath :\n        Path to GenBank file.\n    validate :\n        Whether to validate sequences.\n    \"\"\"\n    self.filepath = Path(filepath)\n    self.validate = validate\n\n    if not self.filepath.exists():\n        raise FileNotFoundError(f'File not found: {filepath}')\n</code></pre>"},{"location":"api/io/readers/#pypopart.io.genbank.GenBankReader.read_sequences","title":"read_sequences","text":"<pre><code>read_sequences(\n    progress_callback=None,\n) -&gt; Iterator[Sequence]\n</code></pre> <p>Read sequences from GenBank file.</p> <p>Parameters:</p> Name Type Description Default <code>progress_callback</code> <p>Optional callback function(current, total).</p> <code>None</code> <code>Yields</code> <p>Sequence objects.</p> required Source code in <code>src/pypopart/io/genbank.py</code> <pre><code>def read_sequences(self, progress_callback=None) -&gt; Iterator[Sequence]:\n    \"\"\"\n    Read sequences from GenBank file.\n\n    Parameters\n    ----------\n    progress_callback :\n        Optional callback function(current, total).\n\n    Yields :\n        Sequence objects.\n    \"\"\"\n    count = 0\n    with self._open_file() as handle:\n        for record in SeqIO.parse(handle, 'genbank'):\n            # Extract metadata from annotations\n            metadata = {}\n\n            if record.annotations:\n                # Add relevant annotations as metadata\n                for key in ['organism', 'source', 'taxonomy', 'date']:\n                    if key in record.annotations:\n                        value = record.annotations[key]\n                        if isinstance(value, list):\n                            value = '; '.join(str(v) for v in value)\n                        metadata[key] = str(value)\n\n            # Add features as metadata if present\n            if record.features:\n                feature_types = {f.type for f in record.features}\n                metadata['features'] = ', '.join(feature_types)\n\n            seq = Sequence(\n                id=record.id,\n                data=str(record.seq).upper(),\n                description=record.description,\n                metadata=metadata,\n            )\n\n            # Validation happens automatically in Sequence.__init__\n\n            count += 1\n            if progress_callback:\n                progress_callback(count, None)\n\n            yield seq\n</code></pre>"},{"location":"api/io/writers/","title":"File Writers","text":"<p>Network export functionality for various formats.</p>"},{"location":"api/io/writers/#overview","title":"Overview","text":"<p>Export networks in multiple formats:</p> <ul> <li>NEXUS: Compatible with PopART</li> <li>GML: Graph Modeling Language</li> <li>GraphML: XML-based graph format</li> <li>JSON: JavaScript Object Notation</li> </ul>"},{"location":"api/io/writers/#modules","title":"Modules","text":""},{"location":"api/io/writers/#pypopart.io.network_export","title":"pypopart.io.network_export","text":"<p>Network export module for PyPopART.</p> <p>Provides exporters for various network file formats.</p>"},{"location":"api/io/writers/#pypopart.io.network_export.GraphMLExporter","title":"GraphMLExporter","text":"<p>Export haplotype networks to GraphML format.</p> Source code in <code>src/pypopart/io/network_export.py</code> <pre><code>class GraphMLExporter:\n    \"\"\"Export haplotype networks to GraphML format.\"\"\"\n\n    def __init__(self, filepath: Union[str, Path]):\n        \"\"\"\n        Initialize GraphML exporter.\n\n        Parameters\n        ----------\n        filepath :\n            Output file path.\n        \"\"\"\n        self.filepath = Path(filepath)\n\n    def export(self, network: HaplotypeNetwork) -&gt; None:\n        \"\"\"\n        Export network to GraphML format.\n\n        Parameters\n        ----------\n        network :\n            HaplotypeNetwork object.\n        \"\"\"\n        # Convert network to NetworkX graph if needed\n        graph = network.graph if hasattr(network, 'graph') else network\n\n        # Sanitize graph data for export (strict mode for GraphML)\n        sanitized_graph = _sanitize_graph_for_export(graph, format_type='graphml')\n\n        # Write to GraphML\n        nx.write_graphml(sanitized_graph, self.filepath)\n</code></pre>"},{"location":"api/io/writers/#pypopart.io.network_export.GraphMLExporter.__init__","title":"__init__","text":"<pre><code>__init__(filepath: Union[str, Path])\n</code></pre> <p>Initialize GraphML exporter.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>Union[str, Path]</code> <p>Output file path.</p> required Source code in <code>src/pypopart/io/network_export.py</code> <pre><code>def __init__(self, filepath: Union[str, Path]):\n    \"\"\"\n    Initialize GraphML exporter.\n\n    Parameters\n    ----------\n    filepath :\n        Output file path.\n    \"\"\"\n    self.filepath = Path(filepath)\n</code></pre>"},{"location":"api/io/writers/#pypopart.io.network_export.GraphMLExporter.export","title":"export","text":"<pre><code>export(network: HaplotypeNetwork) -&gt; None\n</code></pre> <p>Export network to GraphML format.</p> <p>Parameters:</p> Name Type Description Default <code>network</code> <code>HaplotypeNetwork</code> <p>HaplotypeNetwork object.</p> required Source code in <code>src/pypopart/io/network_export.py</code> <pre><code>def export(self, network: HaplotypeNetwork) -&gt; None:\n    \"\"\"\n    Export network to GraphML format.\n\n    Parameters\n    ----------\n    network :\n        HaplotypeNetwork object.\n    \"\"\"\n    # Convert network to NetworkX graph if needed\n    graph = network.graph if hasattr(network, 'graph') else network\n\n    # Sanitize graph data for export (strict mode for GraphML)\n    sanitized_graph = _sanitize_graph_for_export(graph, format_type='graphml')\n\n    # Write to GraphML\n    nx.write_graphml(sanitized_graph, self.filepath)\n</code></pre>"},{"location":"api/io/writers/#pypopart.io.network_export.GMLExporter","title":"GMLExporter","text":"<p>Export haplotype networks to GML format.</p> Source code in <code>src/pypopart/io/network_export.py</code> <pre><code>class GMLExporter:\n    \"\"\"Export haplotype networks to GML format.\"\"\"\n\n    def __init__(self, filepath: Union[str, Path]):\n        \"\"\"\n        Initialize GML exporter.\n\n        Parameters\n        ----------\n        filepath :\n            Output file path.\n        \"\"\"\n        self.filepath = Path(filepath)\n\n    def export(self, network: HaplotypeNetwork) -&gt; None:\n        \"\"\"\n        Export network to GML format.\n\n        Parameters\n        ----------\n        network :\n            HaplotypeNetwork object.\n        \"\"\"\n        graph = network.graph if hasattr(network, 'graph') else network\n\n        # Sanitize graph data for export (GML requires strings like GraphML)\n        sanitized_graph = _sanitize_graph_for_export(graph, format_type='graphml')\n\n        # Write to GML\n        nx.write_gml(sanitized_graph, self.filepath)\n</code></pre>"},{"location":"api/io/writers/#pypopart.io.network_export.GMLExporter.__init__","title":"__init__","text":"<pre><code>__init__(filepath: Union[str, Path])\n</code></pre> <p>Initialize GML exporter.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>Union[str, Path]</code> <p>Output file path.</p> required Source code in <code>src/pypopart/io/network_export.py</code> <pre><code>def __init__(self, filepath: Union[str, Path]):\n    \"\"\"\n    Initialize GML exporter.\n\n    Parameters\n    ----------\n    filepath :\n        Output file path.\n    \"\"\"\n    self.filepath = Path(filepath)\n</code></pre>"},{"location":"api/io/writers/#pypopart.io.network_export.GMLExporter.export","title":"export","text":"<pre><code>export(network: HaplotypeNetwork) -&gt; None\n</code></pre> <p>Export network to GML format.</p> <p>Parameters:</p> Name Type Description Default <code>network</code> <code>HaplotypeNetwork</code> <p>HaplotypeNetwork object.</p> required Source code in <code>src/pypopart/io/network_export.py</code> <pre><code>def export(self, network: HaplotypeNetwork) -&gt; None:\n    \"\"\"\n    Export network to GML format.\n\n    Parameters\n    ----------\n    network :\n        HaplotypeNetwork object.\n    \"\"\"\n    graph = network.graph if hasattr(network, 'graph') else network\n\n    # Sanitize graph data for export (GML requires strings like GraphML)\n    sanitized_graph = _sanitize_graph_for_export(graph, format_type='graphml')\n\n    # Write to GML\n    nx.write_gml(sanitized_graph, self.filepath)\n</code></pre>"},{"location":"api/io/writers/#pypopart.io.network_export.CytoscapeExporter","title":"CytoscapeExporter","text":"<p>Export haplotype networks to Cytoscape JSON format.</p> Source code in <code>src/pypopart/io/network_export.py</code> <pre><code>class CytoscapeExporter:\n    \"\"\"Export haplotype networks to Cytoscape JSON format.\"\"\"\n\n    def __init__(self, filepath: Union[str, Path]):\n        \"\"\"\n        Initialize Cytoscape exporter.\n\n        Parameters\n        ----------\n        filepath :\n            Output file path.\n        \"\"\"\n        self.filepath = Path(filepath)\n\n    def export(self, network: HaplotypeNetwork) -&gt; None:\n        \"\"\"\n        Export network to Cytoscape JSON format.\n\n        Parameters\n        ----------\n        network :\n            HaplotypeNetwork object.\n        \"\"\"\n        graph = network.graph if hasattr(network, 'graph') else network\n\n        # Sanitize graph data for export\n        sanitized_graph = _sanitize_graph_for_export(graph)\n\n        # Convert to Cytoscape JSON format\n        cytoscape_data = nx.cytoscape_data(sanitized_graph)\n\n        with open(self.filepath, 'w') as f:\n            json.dump(cytoscape_data, f, indent=2)\n</code></pre>"},{"location":"api/io/writers/#pypopart.io.network_export.CytoscapeExporter.__init__","title":"__init__","text":"<pre><code>__init__(filepath: Union[str, Path])\n</code></pre> <p>Initialize Cytoscape exporter.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>Union[str, Path]</code> <p>Output file path.</p> required Source code in <code>src/pypopart/io/network_export.py</code> <pre><code>def __init__(self, filepath: Union[str, Path]):\n    \"\"\"\n    Initialize Cytoscape exporter.\n\n    Parameters\n    ----------\n    filepath :\n        Output file path.\n    \"\"\"\n    self.filepath = Path(filepath)\n</code></pre>"},{"location":"api/io/writers/#pypopart.io.network_export.CytoscapeExporter.export","title":"export","text":"<pre><code>export(network: HaplotypeNetwork) -&gt; None\n</code></pre> <p>Export network to Cytoscape JSON format.</p> <p>Parameters:</p> Name Type Description Default <code>network</code> <code>HaplotypeNetwork</code> <p>HaplotypeNetwork object.</p> required Source code in <code>src/pypopart/io/network_export.py</code> <pre><code>def export(self, network: HaplotypeNetwork) -&gt; None:\n    \"\"\"\n    Export network to Cytoscape JSON format.\n\n    Parameters\n    ----------\n    network :\n        HaplotypeNetwork object.\n    \"\"\"\n    graph = network.graph if hasattr(network, 'graph') else network\n\n    # Sanitize graph data for export\n    sanitized_graph = _sanitize_graph_for_export(graph)\n\n    # Convert to Cytoscape JSON format\n    cytoscape_data = nx.cytoscape_data(sanitized_graph)\n\n    with open(self.filepath, 'w') as f:\n        json.dump(cytoscape_data, f, indent=2)\n</code></pre>"},{"location":"api/io/writers/#pypopart.io.network_export.JSONExporter","title":"JSONExporter","text":"<p>Export haplotype networks to JSON format.</p> Source code in <code>src/pypopart/io/network_export.py</code> <pre><code>class JSONExporter:\n    \"\"\"Export haplotype networks to JSON format.\"\"\"\n\n    def __init__(self, filepath: Union[str, Path]):\n        \"\"\"\n        Initialize JSON exporter.\n\n        Parameters\n        ----------\n        filepath :\n            Output file path.\n        \"\"\"\n        self.filepath = Path(filepath)\n\n    def export(self, network: HaplotypeNetwork, include_layout: bool = True) -&gt; None:\n        \"\"\"\n        Export network to JSON format.\n\n        Parameters\n        ----------\n        network :\n            HaplotypeNetwork object.\n        include_layout :\n            Whether to include node layout positions.\n        \"\"\"\n        graph = network.graph if hasattr(network, 'graph') else network\n\n        # Sanitize graph data for export\n        sanitized_graph = _sanitize_graph_for_export(graph)\n\n        # Build JSON structure\n        data = {'nodes': [], 'edges': [], 'metadata': {}}\n\n        # Add nodes\n        for node, attrs in sanitized_graph.nodes(data=True):\n            node_data = {'id': str(node), 'attributes': dict(attrs)}\n            data['nodes'].append(node_data)\n\n        # Add edges\n        for source, target, attrs in sanitized_graph.edges(data=True):\n            edge_data = {\n                'source': str(source),\n                'target': str(target),\n                'attributes': dict(attrs),\n            }\n            data['edges'].append(edge_data)\n\n        # Add graph metadata\n        if hasattr(sanitized_graph, 'graph'):\n            data['metadata'] = dict(sanitized_graph.graph)\n\n        with open(self.filepath, 'w') as f:\n            json.dump(data, f, indent=2)\n</code></pre>"},{"location":"api/io/writers/#pypopart.io.network_export.JSONExporter.__init__","title":"__init__","text":"<pre><code>__init__(filepath: Union[str, Path])\n</code></pre> <p>Initialize JSON exporter.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>Union[str, Path]</code> <p>Output file path.</p> required Source code in <code>src/pypopart/io/network_export.py</code> <pre><code>def __init__(self, filepath: Union[str, Path]):\n    \"\"\"\n    Initialize JSON exporter.\n\n    Parameters\n    ----------\n    filepath :\n        Output file path.\n    \"\"\"\n    self.filepath = Path(filepath)\n</code></pre>"},{"location":"api/io/writers/#pypopart.io.network_export.JSONExporter.export","title":"export","text":"<pre><code>export(\n    network: HaplotypeNetwork, include_layout: bool = True\n) -&gt; None\n</code></pre> <p>Export network to JSON format.</p> <p>Parameters:</p> Name Type Description Default <code>network</code> <code>HaplotypeNetwork</code> <p>HaplotypeNetwork object.</p> required <code>include_layout</code> <code>bool</code> <p>Whether to include node layout positions.</p> <code>True</code> Source code in <code>src/pypopart/io/network_export.py</code> <pre><code>def export(self, network: HaplotypeNetwork, include_layout: bool = True) -&gt; None:\n    \"\"\"\n    Export network to JSON format.\n\n    Parameters\n    ----------\n    network :\n        HaplotypeNetwork object.\n    include_layout :\n        Whether to include node layout positions.\n    \"\"\"\n    graph = network.graph if hasattr(network, 'graph') else network\n\n    # Sanitize graph data for export\n    sanitized_graph = _sanitize_graph_for_export(graph)\n\n    # Build JSON structure\n    data = {'nodes': [], 'edges': [], 'metadata': {}}\n\n    # Add nodes\n    for node, attrs in sanitized_graph.nodes(data=True):\n        node_data = {'id': str(node), 'attributes': dict(attrs)}\n        data['nodes'].append(node_data)\n\n    # Add edges\n    for source, target, attrs in sanitized_graph.edges(data=True):\n        edge_data = {\n            'source': str(source),\n            'target': str(target),\n            'attributes': dict(attrs),\n        }\n        data['edges'].append(edge_data)\n\n    # Add graph metadata\n    if hasattr(sanitized_graph, 'graph'):\n        data['metadata'] = dict(sanitized_graph.graph)\n\n    with open(self.filepath, 'w') as f:\n        json.dump(data, f, indent=2)\n</code></pre>"},{"location":"api/io/writers/#pypopart.io.network_export.CSVExporter","title":"CSVExporter","text":"<p>Export haplotype network statistics to CSV format.</p> Source code in <code>src/pypopart/io/network_export.py</code> <pre><code>class CSVExporter:\n    \"\"\"Export haplotype network statistics to CSV format.\"\"\"\n\n    def __init__(self, filepath: Union[str, Path]):\n        \"\"\"\n        Initialize CSV exporter.\n\n        Parameters\n        ----------\n        filepath :\n            Output file path.\n        \"\"\"\n        self.filepath = Path(filepath)\n\n    def export_nodes(self, network: HaplotypeNetwork) -&gt; None:\n        \"\"\"\n        Export node attributes to CSV.\n\n        Parameters\n        ----------\n        network :\n            HaplotypeNetwork object.\n        \"\"\"\n        graph = network.graph if hasattr(network, 'graph') else network\n\n        # Collect all attribute keys\n        all_keys = set()\n        for _node, attrs in graph.nodes(data=True):\n            all_keys.update(attrs.keys())\n\n        fieldnames = ['node_id'] + sorted(all_keys)\n\n        with open(self.filepath, 'w', newline='') as f:\n            writer = csv.DictWriter(f, fieldnames=fieldnames)\n            writer.writeheader()\n\n            for node, attrs in graph.nodes(data=True):\n                row = {'node_id': str(node)}\n                row.update(attrs)\n                writer.writerow(row)\n\n    def export_edges(self, network: HaplotypeNetwork) -&gt; None:\n        \"\"\"\n        Export edge attributes to CSV.\n\n        Parameters\n        ----------\n        network :\n            HaplotypeNetwork object.\n        \"\"\"\n        graph = network.graph if hasattr(network, 'graph') else network\n\n        # Collect all attribute keys\n        all_keys = set()\n        for _source, _target, attrs in graph.edges(data=True):\n            all_keys.update(attrs.keys())\n\n        fieldnames = ['source', 'target'] + sorted(all_keys)\n\n        with open(self.filepath, 'w', newline='') as f:\n            writer = csv.DictWriter(f, fieldnames=fieldnames)\n            writer.writeheader()\n\n            for source, target, attrs in graph.edges(data=True):\n                row = {'source': str(source), 'target': str(target)}\n                row.update(attrs)\n                writer.writerow(row)\n\n    def export_statistics(\n        self, network: HaplotypeNetwork, statistics: Dict[str, Any]\n    ) -&gt; None:\n        \"\"\"\n        Export network statistics to CSV.\n\n        Parameters\n        ----------\n        network :\n            HaplotypeNetwork object.\n        statistics :\n            Dictionary of statistics to export.\n        \"\"\"\n        with open(self.filepath, 'w', newline='') as f:\n            writer = csv.writer(f)\n            writer.writerow(['Statistic', 'Value'])\n\n            for key, value in sorted(statistics.items()):\n                writer.writerow([key, value])\n</code></pre>"},{"location":"api/io/writers/#pypopart.io.network_export.CSVExporter.__init__","title":"__init__","text":"<pre><code>__init__(filepath: Union[str, Path])\n</code></pre> <p>Initialize CSV exporter.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>Union[str, Path]</code> <p>Output file path.</p> required Source code in <code>src/pypopart/io/network_export.py</code> <pre><code>def __init__(self, filepath: Union[str, Path]):\n    \"\"\"\n    Initialize CSV exporter.\n\n    Parameters\n    ----------\n    filepath :\n        Output file path.\n    \"\"\"\n    self.filepath = Path(filepath)\n</code></pre>"},{"location":"api/io/writers/#pypopart.io.network_export.CSVExporter.export_nodes","title":"export_nodes","text":"<pre><code>export_nodes(network: HaplotypeNetwork) -&gt; None\n</code></pre> <p>Export node attributes to CSV.</p> <p>Parameters:</p> Name Type Description Default <code>network</code> <code>HaplotypeNetwork</code> <p>HaplotypeNetwork object.</p> required Source code in <code>src/pypopart/io/network_export.py</code> <pre><code>def export_nodes(self, network: HaplotypeNetwork) -&gt; None:\n    \"\"\"\n    Export node attributes to CSV.\n\n    Parameters\n    ----------\n    network :\n        HaplotypeNetwork object.\n    \"\"\"\n    graph = network.graph if hasattr(network, 'graph') else network\n\n    # Collect all attribute keys\n    all_keys = set()\n    for _node, attrs in graph.nodes(data=True):\n        all_keys.update(attrs.keys())\n\n    fieldnames = ['node_id'] + sorted(all_keys)\n\n    with open(self.filepath, 'w', newline='') as f:\n        writer = csv.DictWriter(f, fieldnames=fieldnames)\n        writer.writeheader()\n\n        for node, attrs in graph.nodes(data=True):\n            row = {'node_id': str(node)}\n            row.update(attrs)\n            writer.writerow(row)\n</code></pre>"},{"location":"api/io/writers/#pypopart.io.network_export.CSVExporter.export_edges","title":"export_edges","text":"<pre><code>export_edges(network: HaplotypeNetwork) -&gt; None\n</code></pre> <p>Export edge attributes to CSV.</p> <p>Parameters:</p> Name Type Description Default <code>network</code> <code>HaplotypeNetwork</code> <p>HaplotypeNetwork object.</p> required Source code in <code>src/pypopart/io/network_export.py</code> <pre><code>def export_edges(self, network: HaplotypeNetwork) -&gt; None:\n    \"\"\"\n    Export edge attributes to CSV.\n\n    Parameters\n    ----------\n    network :\n        HaplotypeNetwork object.\n    \"\"\"\n    graph = network.graph if hasattr(network, 'graph') else network\n\n    # Collect all attribute keys\n    all_keys = set()\n    for _source, _target, attrs in graph.edges(data=True):\n        all_keys.update(attrs.keys())\n\n    fieldnames = ['source', 'target'] + sorted(all_keys)\n\n    with open(self.filepath, 'w', newline='') as f:\n        writer = csv.DictWriter(f, fieldnames=fieldnames)\n        writer.writeheader()\n\n        for source, target, attrs in graph.edges(data=True):\n            row = {'source': str(source), 'target': str(target)}\n            row.update(attrs)\n            writer.writerow(row)\n</code></pre>"},{"location":"api/io/writers/#pypopart.io.network_export.CSVExporter.export_statistics","title":"export_statistics","text":"<pre><code>export_statistics(\n    network: HaplotypeNetwork, statistics: Dict[str, Any]\n) -&gt; None\n</code></pre> <p>Export network statistics to CSV.</p> <p>Parameters:</p> Name Type Description Default <code>network</code> <code>HaplotypeNetwork</code> <p>HaplotypeNetwork object.</p> required <code>statistics</code> <code>Dict[str, Any]</code> <p>Dictionary of statistics to export.</p> required Source code in <code>src/pypopart/io/network_export.py</code> <pre><code>def export_statistics(\n    self, network: HaplotypeNetwork, statistics: Dict[str, Any]\n) -&gt; None:\n    \"\"\"\n    Export network statistics to CSV.\n\n    Parameters\n    ----------\n    network :\n        HaplotypeNetwork object.\n    statistics :\n        Dictionary of statistics to export.\n    \"\"\"\n    with open(self.filepath, 'w', newline='') as f:\n        writer = csv.writer(f)\n        writer.writerow(['Statistic', 'Value'])\n\n        for key, value in sorted(statistics.items()):\n            writer.writerow([key, value])\n</code></pre>"},{"location":"api/stats/popgen/","title":"Population Genetics","text":"<p>Population genetics statistics and tests.</p>"},{"location":"api/stats/popgen/#overview","title":"Overview","text":"<p>The <code>popgen</code> module provides population genetics analyses:</p> <ul> <li>Diversity measures (haplotype, nucleotide)</li> <li>Neutrality tests (Tajima's D, Fu's Fs)</li> <li>Population differentiation (FST)</li> <li>Gene flow estimates</li> <li>Site frequency spectrum</li> </ul>"},{"location":"api/stats/popgen/#modules","title":"Modules","text":""},{"location":"api/stats/popgen/#pypopart.stats.popgen","title":"pypopart.stats.popgen","text":"<p>Population genetics statistics for PyPopART.</p> <p>This module provides functions for calculating population genetics measures including Tajima's D, Fu's Fs, FST, and AMOVA.</p>"},{"location":"api/stats/popgen/#pypopart.stats.popgen.TajimaDResult","title":"TajimaDResult  <code>dataclass</code>","text":"<p>Result of Tajima's D test.</p> Source code in <code>src/pypopart/stats/popgen.py</code> <pre><code>@dataclass\nclass TajimaDResult:\n    \"\"\"Result of Tajima's D test.\"\"\"\n\n    D: float\n    pi: float\n    theta_w: float\n    n_segregating_sites: int\n    n_samples: int\n</code></pre>"},{"location":"api/stats/popgen/#pypopart.stats.popgen.FuFsResult","title":"FuFsResult  <code>dataclass</code>","text":"<p>Result of Fu's Fs test.</p> Source code in <code>src/pypopart/stats/popgen.py</code> <pre><code>@dataclass\nclass FuFsResult:\n    \"\"\"Result of Fu's Fs test.\"\"\"\n\n    Fs: float\n    theta_pi: float\n    n_haplotypes: int\n    n_samples: int\n</code></pre>"},{"location":"api/stats/popgen/#pypopart.stats.popgen.FstResult","title":"FstResult  <code>dataclass</code>","text":"<p>Result of pairwise FST calculation.</p> Source code in <code>src/pypopart/stats/popgen.py</code> <pre><code>@dataclass\nclass FstResult:\n    \"\"\"Result of pairwise FST calculation.\"\"\"\n\n    fst: float\n    pop1: str\n    pop2: str\n    hs: float  # Within-population diversity\n    ht: float  # Total diversity\n</code></pre>"},{"location":"api/stats/popgen/#pypopart.stats.popgen.AMOVAResult","title":"AMOVAResult  <code>dataclass</code>","text":"<p>Result of AMOVA (Analysis of Molecular Variance).</p> Source code in <code>src/pypopart/stats/popgen.py</code> <pre><code>@dataclass\nclass AMOVAResult:\n    \"\"\"Result of AMOVA (Analysis of Molecular Variance).\"\"\"\n\n    phi_st: float  # Among-population variance\n    phi_sc: float  # Among-groups-within-populations variance (if groups defined)\n    phi_ct: float  # Among-groups variance (if groups defined)\n    variance_among_pops: float\n    variance_within_pops: float\n    percent_among_pops: float\n    percent_within_pops: float\n</code></pre>"},{"location":"api/stats/popgen/#pypopart.stats.popgen.calculate_tajimas_d","title":"calculate_tajimas_d","text":"<pre><code>calculate_tajimas_d(\n    alignment: Alignment,\n    populations: Optional[Dict[str, str]] = None,\n) -&gt; TajimaDResult\n</code></pre> <p>Calculate Tajima's D statistic.</p> <p>Tajima's D tests for deviation from neutral evolution by comparing two estimates of theta (population mutation rate): - \u03c0 (nucleotide diversity) - \u03b8_W (Watterson's estimator based on segregating sites)</p> <p>D = 0: neutral evolution D &gt; 0: balancing selection or population contraction D &lt; 0: directional selection or population expansion</p> <p>Args:     alignment: Alignment object     populations: Optional dict mapping sequence_id -&gt; population</p> <p>Returns:</p> Type Description <code>    TajimaDResult with D statistic and related values.</code> Source code in <code>src/pypopart/stats/popgen.py</code> <pre><code>def calculate_tajimas_d(\n    alignment: Alignment, populations: Optional[Dict[str, str]] = None\n) -&gt; TajimaDResult:\n    \"\"\"\n    Calculate Tajima's D statistic.\n\n    Tajima's D tests for deviation from neutral evolution by comparing\n    two estimates of theta (population mutation rate):\n    - \u03c0 (nucleotide diversity)\n    - \u03b8_W (Watterson's estimator based on segregating sites)\n\n    D = 0: neutral evolution\n    D &gt; 0: balancing selection or population contraction\n    D &lt; 0: directional selection or population expansion\n\n    Args:\n        alignment: Alignment object\n        populations: Optional dict mapping sequence_id -&gt; population\n\n    Returns\n    -------\n        TajimaDResult with D statistic and related values.\n    \"\"\"\n    n = len(alignment)  # Number of sequences\n    L = alignment.length  # Sequence length\n\n    if n &lt; 2:\n        return TajimaDResult(\n            D=0.0, pi=0.0, theta_w=0.0, n_segregating_sites=0, n_samples=n\n        )\n\n    # Calculate number of segregating sites (S)\n    S = 0\n    for pos in range(L):\n        column = alignment.get_column(pos)\n        # Remove gaps\n        column_no_gaps = [c for c in column if c != '-']\n        if len(set(column_no_gaps)) &gt; 1:\n            S += 1\n\n    # Calculate Watterson's estimator (\u03b8_W)\n    # \u03b8_W = S / a1\n    a1 = sum(1.0 / i for i in range(1, n))\n    theta_w = S / a1 if a1 &gt; 0 else 0.0\n\n    # Calculate nucleotide diversity (\u03c0)\n    # \u03c0 = average pairwise differences\n    total_diff = 0\n    comparisons = 0\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            seq_i = alignment[i].data\n            seq_j = alignment[j].data\n\n            diff = sum(\n                1 for a, b in zip(seq_i, seq_j) if a != b and a != '-' and b != '-'\n            )\n            total_diff += diff\n            comparisons += 1\n\n    pi = total_diff / comparisons if comparisons &gt; 0 else 0.0\n\n    # Calculate Tajima's D\n    # D = (\u03c0 - \u03b8_W) / sqrt(V(\u03c0 - \u03b8_W))\n\n    # Calculate variance terms\n    a2 = sum(1.0 / (i**2) for i in range(1, n))\n\n    b1 = (n + 1) / (3 * (n - 1))\n    b2 = 2 * (n**2 + n + 3) / (9 * n * (n - 1))\n\n    c1 = b1 - 1 / a1\n    c2 = b2 - (n + 2) / (a1 * n) + a2 / (a1**2)\n\n    e1 = c1 / a1\n    e2 = c2 / (a1**2 + a2)\n\n    variance = e1 * S + e2 * S * (S - 1)\n\n    if variance &gt; 0:\n        D = (pi - theta_w) / math.sqrt(variance)\n    else:\n        D = 0.0\n\n    return TajimaDResult(\n        D=D, pi=pi, theta_w=theta_w, n_segregating_sites=S, n_samples=n\n    )\n</code></pre>"},{"location":"api/stats/popgen/#pypopart.stats.popgen.calculate_fu_fs","title":"calculate_fu_fs","text":"<pre><code>calculate_fu_fs(\n    network: HaplotypeNetwork, alignment: Alignment\n) -&gt; FuFsResult\n</code></pre> <p>Calculate Fu's Fs statistic.</p> <p>Fu's Fs is based on the probability of observing a random neutral sample with as many or more haplotypes as observed, given theta estimated from nucleotide diversity.</p> <p>Negative Fs: excess of recent mutations (population expansion) Positive Fs: deficiency of alleles (balancing selection or bottleneck)</p> <p>Args:     network: HaplotypeNetwork object     alignment: Alignment object</p> <p>Returns:</p> Type Description <code>    FuFsResult with Fs statistic and related values.</code> Source code in <code>src/pypopart/stats/popgen.py</code> <pre><code>def calculate_fu_fs(network: HaplotypeNetwork, alignment: Alignment) -&gt; FuFsResult:\n    \"\"\"\n    Calculate Fu's Fs statistic.\n\n    Fu's Fs is based on the probability of observing a random neutral sample\n    with as many or more haplotypes as observed, given theta estimated from\n    nucleotide diversity.\n\n    Negative Fs: excess of recent mutations (population expansion)\n    Positive Fs: deficiency of alleles (balancing selection or bottleneck)\n\n    Args:\n        network: HaplotypeNetwork object\n        alignment: Alignment object\n\n    Returns\n    -------\n        FuFsResult with Fs statistic and related values.\n    \"\"\"\n    # Get number of haplotypes and samples\n    k = len(network.haplotypes)  # Number of haplotypes\n    n = network.get_total_samples()  # Total samples\n\n    if n &lt; 2 or k &lt; 1:\n        return FuFsResult(Fs=0.0, theta_pi=0.0, n_haplotypes=k, n_samples=n)\n\n    # Calculate nucleotide diversity (\u03c0)\n    # Use average pairwise differences\n    total_diff = 0\n    comparisons = 0\n\n    haplotype_list = network.haplotypes\n    for i, hap_i in enumerate(haplotype_list):\n        for _j, hap_j in enumerate(haplotype_list[i + 1 :], start=i + 1):\n            seq_i = hap_i.sequence.data\n            seq_j = hap_j.sequence.data\n\n            diff = sum(\n                1 for a, b in zip(seq_i, seq_j) if a != b and a != '-' and b != '-'\n            )\n\n            # Weight by frequencies\n            freq_i = hap_i.frequency\n            freq_j = hap_j.frequency\n\n            total_diff += diff * freq_i * freq_j\n            comparisons += freq_i * freq_j\n\n    theta_pi = total_diff / comparisons if comparisons &gt; 0 else 0.0\n\n    # Calculate Fs\n    # Fs is complex, using simplified approximation\n    # Fs \u2248 ln(S / (theta_pi)) where S is observed haplotypes\n\n    if theta_pi &gt; 0:\n        # Approximate calculation\n        expected_k = 1 + theta_pi * sum(1.0 / i for i in range(1, n))\n\n        if expected_k &gt; 0:\n            Fs = (\n                math.log(k / expected_k)\n                if k &gt; expected_k\n                else -math.log(expected_k / k)\n            )\n        else:\n            Fs = 0.0\n    else:\n        Fs = 0.0\n\n    return FuFsResult(Fs=Fs, theta_pi=theta_pi, n_haplotypes=k, n_samples=n)\n</code></pre>"},{"location":"api/stats/popgen/#pypopart.stats.popgen.calculate_pairwise_fst","title":"calculate_pairwise_fst","text":"<pre><code>calculate_pairwise_fst(\n    network: HaplotypeNetwork, pop1: str, pop2: str\n) -&gt; FstResult\n</code></pre> <p>Calculate pairwise FST between two populations.</p> <p>FST measures population differentiation based on genetic variance: FST = (HT - HS) / HT</p> <p>where: - HT is the expected heterozygosity in the total population - HS is the expected heterozygosity within populations</p> <p>FST = 0: no differentiation FST = 1: complete differentiation</p> <p>Args:     network: HaplotypeNetwork object     pop1: Name of first population     pop2: Name of second population</p> <p>Returns:</p> Type Description <code>    FstResult with FST and related values.</code> Source code in <code>src/pypopart/stats/popgen.py</code> <pre><code>def calculate_pairwise_fst(\n    network: HaplotypeNetwork, pop1: str, pop2: str\n) -&gt; FstResult:\n    \"\"\"\n    Calculate pairwise FST between two populations.\n\n    FST measures population differentiation based on genetic variance:\n    FST = (HT - HS) / HT\n\n    where:\n    - HT is the expected heterozygosity in the total population\n    - HS is the expected heterozygosity within populations\n\n    FST = 0: no differentiation\n    FST = 1: complete differentiation\n\n    Args:\n        network: HaplotypeNetwork object\n        pop1: Name of first population\n        pop2: Name of second population\n\n    Returns\n    -------\n        FstResult with FST and related values.\n    \"\"\"\n    # Get haplotypes for each population\n    pop1_counts: Dict[str, int] = defaultdict(int)\n    pop2_counts: Dict[str, int] = defaultdict(int)\n\n    for hap_id in network.nodes:\n        haplotype = network.get_haplotype(hap_id)\n        if haplotype is None:\n            continue\n\n        freq_info = haplotype.get_frequency_info()\n        if pop1 in freq_info.by_population:\n            pop1_counts[hap_id] = freq_info.by_population[pop1]\n        if pop2 in freq_info.by_population:\n            pop2_counts[hap_id] = freq_info.by_population[pop2]\n\n    n1 = sum(pop1_counts.values())\n    n2 = sum(pop2_counts.values())\n\n    if n1 == 0 or n2 == 0:\n        return FstResult(fst=0.0, pop1=pop1, pop2=pop2, hs=0.0, ht=0.0)\n\n    # Calculate expected heterozygosity for each population\n    h1 = 1.0 - sum((count / n1) ** 2 for count in pop1_counts.values())\n    h2 = 1.0 - sum((count / n2) ** 2 for count in pop2_counts.values())\n\n    # Average within-population heterozygosity\n    hs = (n1 * h1 + n2 * h2) / (n1 + n2)\n\n    # Calculate total heterozygosity\n    all_haplotypes = set(pop1_counts.keys()) | set(pop2_counts.keys())\n    n_total = n1 + n2\n\n    total_counts = {}\n    for hap_id in all_haplotypes:\n        total_counts[hap_id] = pop1_counts.get(hap_id, 0) + pop2_counts.get(hap_id, 0)\n\n    ht = 1.0 - sum((count / n_total) ** 2 for count in total_counts.values())\n\n    # Calculate FST\n    if ht &gt; 0:\n        fst = (ht - hs) / ht\n    else:\n        fst = 0.0\n\n    return FstResult(fst=fst, pop1=pop1, pop2=pop2, hs=hs, ht=ht)\n</code></pre>"},{"location":"api/stats/popgen/#pypopart.stats.popgen.calculate_fst_matrix","title":"calculate_fst_matrix","text":"<pre><code>calculate_fst_matrix(\n    network: HaplotypeNetwork,\n) -&gt; Dict[Tuple[str, str], float]\n</code></pre> <p>Calculate pairwise FST for all population pairs.</p> <p>Args:     network: HaplotypeNetwork object</p> <p>Returns:</p> Type Description <code>    Dictionary mapping (pop1, pop2) tuples to FST values.</code> Source code in <code>src/pypopart/stats/popgen.py</code> <pre><code>def calculate_fst_matrix(network: HaplotypeNetwork) -&gt; Dict[Tuple[str, str], float]:\n    \"\"\"\n    Calculate pairwise FST for all population pairs.\n\n    Args:\n        network: HaplotypeNetwork object\n\n    Returns\n    -------\n        Dictionary mapping (pop1, pop2) tuples to FST values.\n    \"\"\"\n    # Get all populations\n    populations = set()\n    for hap_id in network.nodes:\n        haplotype = network.get_haplotype(hap_id)\n        if haplotype is not None:\n            freq_info = haplotype.get_frequency_info()\n            populations.update(freq_info.by_population.keys())\n\n    populations = sorted(populations)\n\n    # Calculate pairwise FST\n    fst_matrix = {}\n    for i, pop1 in enumerate(populations):\n        for pop2 in populations[i + 1 :]:\n            result = calculate_pairwise_fst(network, pop1, pop2)\n            fst_matrix[(pop1, pop2)] = result.fst\n            fst_matrix[(pop2, pop1)] = result.fst  # Symmetric\n\n    # Add diagonal (self-comparison = 0)\n    for pop in populations:\n        fst_matrix[(pop, pop)] = 0.0\n\n    return fst_matrix\n</code></pre>"},{"location":"api/stats/popgen/#pypopart.stats.popgen.calculate_amova","title":"calculate_amova","text":"<pre><code>calculate_amova(\n    network: HaplotypeNetwork,\n    alignment: Alignment,\n    groups: Optional[Dict[str, str]] = None,\n) -&gt; AMOVAResult\n</code></pre> <p>Calculate AMOVA (Analysis of Molecular Variance).</p> <p>AMOVA partitions genetic variance into components: - Among populations - Within populations - (Optionally) Among groups of populations</p> <p>Args:     network: HaplotypeNetwork object     alignment: Alignment object     groups: Optional dict mapping population -&gt; group</p> <p>Returns:</p> Type Description <code>    AMOVAResult with variance components and phi statistics.</code> Source code in <code>src/pypopart/stats/popgen.py</code> <pre><code>def calculate_amova(\n    network: HaplotypeNetwork,\n    alignment: Alignment,\n    groups: Optional[Dict[str, str]] = None,\n) -&gt; AMOVAResult:\n    \"\"\"\n    Calculate AMOVA (Analysis of Molecular Variance).\n\n    AMOVA partitions genetic variance into components:\n    - Among populations\n    - Within populations\n    - (Optionally) Among groups of populations\n\n    Args:\n        network: HaplotypeNetwork object\n        alignment: Alignment object\n        groups: Optional dict mapping population -&gt; group\n\n    Returns\n    -------\n        AMOVAResult with variance components and phi statistics.\n    \"\"\"\n    # Get populations and their samples\n    pop_haplotypes: Dict[str, List[str]] = defaultdict(list)\n\n    for hap_id in network.nodes:\n        haplotype = network.get_haplotype(hap_id)\n        if haplotype is None:\n            continue\n\n        freq_info = haplotype.get_frequency_info()\n        for pop, count in freq_info.by_population.items():\n            # Add haplotype multiple times according to count\n            pop_haplotypes[pop].extend([hap_id] * count)\n\n    populations = list(pop_haplotypes.keys())\n    n_pops = len(populations)\n\n    if n_pops &lt; 2:\n        return AMOVAResult(\n            phi_st=0.0,\n            phi_sc=0.0,\n            phi_ct=0.0,\n            variance_among_pops=0.0,\n            variance_within_pops=0.0,\n            percent_among_pops=0.0,\n            percent_within_pops=0.0,\n        )\n\n    # Calculate pairwise distances between all haplotypes\n    def get_distance(hap_id1: str, hap_id2: str) -&gt; int:\n        \"\"\"Get number of differences between two haplotypes.\"\"\"\n        if hap_id1 == hap_id2:\n            return 0\n\n        hap1 = network.get_haplotype(hap_id1)\n        hap2 = network.get_haplotype(hap_id2)\n\n        if hap1 is None or hap2 is None:\n            return 0\n\n        seq1 = hap1.sequence.data\n        seq2 = hap2.sequence.data\n\n        return sum(1 for a, b in zip(seq1, seq2) if a != b and a != '-' and b != '-')\n\n    # Calculate total sum of squares (SST)\n    sum(len(haps) for haps in pop_haplotypes.values())\n\n    # Mean pairwise distance over all samples\n    all_distances = []\n    for pop1_haps in pop_haplotypes.values():\n        for i, hap1 in enumerate(pop1_haps):\n            for hap2 in pop1_haps[i + 1 :]:\n                all_distances.append(get_distance(hap1, hap2))\n\n    for i, pop1 in enumerate(populations):\n        for pop2 in populations[i + 1 :]:\n            for hap1 in pop_haplotypes[pop1]:\n                for hap2 in pop_haplotypes[pop2]:\n                    all_distances.append(get_distance(hap1, hap2))\n\n    mean_dist_total = np.mean(all_distances) if all_distances else 0.0\n\n    # Calculate within-population variance\n    within_pop_variance = 0.0\n    for pop_haps in pop_haplotypes.values():\n        if len(pop_haps) &lt; 2:\n            continue\n\n        pop_distances = []\n        for i, hap1 in enumerate(pop_haps):\n            for hap2 in pop_haps[i + 1 :]:\n                pop_distances.append(get_distance(hap1, hap2))\n\n        if pop_distances:\n            within_pop_variance += np.sum(\n                [(d - mean_dist_total) ** 2 for d in pop_distances]\n            )\n\n    # Calculate among-population variance\n    among_pop_variance = 0.0\n    for i, pop1 in enumerate(populations):\n        for pop2 in populations[i + 1 :]:\n            # Mean distance between populations\n            between_distances = []\n            for hap1 in pop_haplotypes[pop1]:\n                for hap2 in pop_haplotypes[pop2]:\n                    between_distances.append(get_distance(hap1, hap2))\n\n            if between_distances:\n                mean_between = np.mean(between_distances)\n                among_pop_variance += (mean_between - mean_dist_total) ** 2 * len(\n                    between_distances\n                )\n\n    # Normalize variances\n    total_variance = within_pop_variance + among_pop_variance\n\n    if total_variance &gt; 0:\n        percent_within = (within_pop_variance / total_variance) * 100\n        percent_among = (among_pop_variance / total_variance) * 100\n        phi_st = among_pop_variance / total_variance\n    else:\n        percent_within = 0.0\n        percent_among = 0.0\n        phi_st = 0.0\n\n    return AMOVAResult(\n        phi_st=phi_st,\n        phi_sc=0.0,  # Not calculated without groups\n        phi_ct=0.0,  # Not calculated without groups\n        variance_among_pops=among_pop_variance,\n        variance_within_pops=within_pop_variance,\n        percent_among_pops=percent_among,\n        percent_within_pops=percent_within,\n    )\n</code></pre>"},{"location":"api/stats/popgen/#pypopart.stats.popgen.calculate_mismatch_distribution","title":"calculate_mismatch_distribution","text":"<pre><code>calculate_mismatch_distribution(\n    network: HaplotypeNetwork,\n) -&gt; Dict[int, int]\n</code></pre> <p>Calculate the mismatch distribution.</p> <p>The mismatch distribution shows the frequency of pairwise differences between haplotypes. The shape of this distribution can indicate demographic history: - Unimodal: recent population expansion - Multimodal: population at equilibrium</p> <p>Args:     network: HaplotypeNetwork object</p> <p>Returns:</p> Type Description <code>    Dictionary mapping number of differences -&gt; frequency.</code> Source code in <code>src/pypopart/stats/popgen.py</code> <pre><code>def calculate_mismatch_distribution(network: HaplotypeNetwork) -&gt; Dict[int, int]:\n    \"\"\"\n    Calculate the mismatch distribution.\n\n    The mismatch distribution shows the frequency of pairwise differences\n    between haplotypes. The shape of this distribution can indicate\n    demographic history:\n    - Unimodal: recent population expansion\n    - Multimodal: population at equilibrium\n\n    Args:\n        network: HaplotypeNetwork object\n\n    Returns\n    -------\n        Dictionary mapping number of differences -&gt; frequency.\n    \"\"\"\n    mismatch_counts: Dict[int, int] = defaultdict(int)\n\n    haplotype_list = network.haplotypes\n\n    for i, hap_i in enumerate(haplotype_list):\n        for hap_j in haplotype_list[i:]:  # Include self-comparison (0 differences)\n            seq_i = hap_i.sequence.data\n            seq_j = hap_j.sequence.data\n\n            differences = sum(\n                1 for a, b in zip(seq_i, seq_j) if a != b and a != '-' and b != '-'\n            )\n\n            # Weight by product of frequencies\n            freq_i = hap_i.frequency\n            freq_j = hap_j.frequency\n\n            if i == haplotype_list.index(hap_j):\n                # Self-comparison\n                weight = freq_i * (freq_i - 1) // 2 if freq_i &gt; 1 else 0\n            else:\n                weight = freq_i * freq_j\n\n            mismatch_counts[differences] += weight\n\n    return dict(mismatch_counts)\n</code></pre>"},{"location":"api/stats/statistics/","title":"Network Statistics","text":"<p>Network topology and graph statistics.</p>"},{"location":"api/stats/statistics/#overview","title":"Overview","text":"<p>The <code>statistics</code> module calculates network-level metrics:</p> <ul> <li>Basic properties (nodes, edges, density)</li> <li>Centrality measures</li> <li>Path metrics (diameter, average path length)</li> <li>Clustering coefficients</li> <li>Community detection</li> </ul>"},{"location":"api/stats/statistics/#modules","title":"Modules","text":""},{"location":"api/stats/statistics/#pypopart.stats.statistics","title":"pypopart.stats.statistics","text":"<p>Network statistics and diversity metrics for PyPopART.</p> <p>This module provides functions for calculating various statistics about haplotype networks, including diversity measures, network topology metrics, and frequency distributions.</p>"},{"location":"api/stats/statistics/#pypopart.stats.statistics.DiversityMetrics","title":"DiversityMetrics  <code>dataclass</code>","text":"<p>Container for diversity metrics.</p> Source code in <code>src/pypopart/stats/statistics.py</code> <pre><code>@dataclass\nclass DiversityMetrics:\n    \"\"\"Container for diversity metrics.\"\"\"\n\n    haplotype_diversity: float\n    nucleotide_diversity: float\n    shannon_index: float\n    num_haplotypes: int\n    num_samples: int\n</code></pre>"},{"location":"api/stats/statistics/#pypopart.stats.statistics.NetworkMetrics","title":"NetworkMetrics  <code>dataclass</code>","text":"<p>Container for network topology metrics.</p> Source code in <code>src/pypopart/stats/statistics.py</code> <pre><code>@dataclass\nclass NetworkMetrics:\n    \"\"\"Container for network topology metrics.\"\"\"\n\n    diameter: int\n    clustering_coefficient: float\n    average_path_length: float\n    reticulation_index: float\n    num_components: int\n    central_haplotypes: List[str]\n</code></pre>"},{"location":"api/stats/statistics/#pypopart.stats.statistics.calculate_haplotype_frequencies","title":"calculate_haplotype_frequencies","text":"<pre><code>calculate_haplotype_frequencies(\n    network: HaplotypeNetwork, normalize: bool = False\n) -&gt; Dict[str, Dict[str, float]]\n</code></pre> <p>Calculate haplotype frequencies overall and by population.</p> <p>Args:     network: HaplotypeNetwork object     normalize: If True, return frequencies as proportions (0-1)</p> <p>Returns:</p> Type Description <code>    Dictionary with:.</code> <p>'overall': Dict[haplotype_id -&gt; frequency/count] 'by_population': Dict[population -&gt; Dict[haplotype_id -&gt; frequency/count]]</p> Source code in <code>src/pypopart/stats/statistics.py</code> <pre><code>def calculate_haplotype_frequencies(\n    network: HaplotypeNetwork, normalize: bool = False\n) -&gt; Dict[str, Dict[str, float]]:\n    \"\"\"\n    Calculate haplotype frequencies overall and by population.\n\n    Args:\n        network: HaplotypeNetwork object\n        normalize: If True, return frequencies as proportions (0-1)\n\n    Returns\n    -------\n        Dictionary with:.\n            'overall': Dict[haplotype_id -&gt; frequency/count]\n            'by_population': Dict[population -&gt; Dict[haplotype_id -&gt; frequency/count]]\n    \"\"\"\n    overall_counts: Dict[str, int] = defaultdict(int)\n    pop_counts: Dict[str, Dict[str, int]] = defaultdict(lambda: defaultdict(int))\n\n    total_samples = 0\n    pop_totals: Dict[str, int] = defaultdict(int)\n\n    # Collect counts\n    for hap_id in network.nodes:\n        haplotype = network.get_haplotype(hap_id)\n        if haplotype is None:\n            continue\n\n        count = haplotype.frequency\n        overall_counts[hap_id] = count\n        total_samples += count\n\n        # By population\n        freq_info = haplotype.get_frequency_info()\n        for pop, pop_count in freq_info.by_population.items():\n            pop_counts[pop][hap_id] = pop_count\n            pop_totals[pop] += pop_count\n\n    # Normalize if requested\n    if normalize and total_samples &gt; 0:\n        overall_freq = {\n            hap_id: count / total_samples for hap_id, count in overall_counts.items()\n        }\n    else:\n        overall_freq = dict(overall_counts)\n\n    by_pop_freq = {}\n    for pop, counts in pop_counts.items():\n        if normalize and pop_totals[pop] &gt; 0:\n            by_pop_freq[pop] = {\n                hap_id: count / pop_totals[pop] for hap_id, count in counts.items()\n            }\n        else:\n            by_pop_freq[pop] = dict(counts)\n\n    return {\n        'overall': overall_freq,\n        'by_population': by_pop_freq,\n        'total_samples': total_samples,\n    }\n</code></pre>"},{"location":"api/stats/statistics/#pypopart.stats.statistics.calculate_diversity_metrics","title":"calculate_diversity_metrics","text":"<pre><code>calculate_diversity_metrics(\n    network: HaplotypeNetwork,\n    alignment: Optional[Alignment] = None,\n) -&gt; DiversityMetrics\n</code></pre> <p>Calculate diversity metrics for a haplotype network.</p> <p>Args:     network: HaplotypeNetwork object     alignment: Optional alignment for nucleotide diversity calculation</p> <p>Returns:</p> Type Description <code>    DiversityMetrics object with calculated metrics.</code> Source code in <code>src/pypopart/stats/statistics.py</code> <pre><code>def calculate_diversity_metrics(\n    network: HaplotypeNetwork, alignment: Optional[Alignment] = None\n) -&gt; DiversityMetrics:\n    \"\"\"\n    Calculate diversity metrics for a haplotype network.\n\n    Args:\n        network: HaplotypeNetwork object\n        alignment: Optional alignment for nucleotide diversity calculation\n\n    Returns\n    -------\n        DiversityMetrics object with calculated metrics.\n    \"\"\"\n    # Get frequencies\n    freq_info = calculate_haplotype_frequencies(network, normalize=True)\n    overall_freq = freq_info['overall']\n    total_samples = freq_info['total_samples']\n\n    num_haplotypes = len(overall_freq)\n\n    # Haplotype diversity (Nei's gene diversity)\n    # H = (n / (n-1)) * (1 - sum(p_i^2))\n    if total_samples &lt;= 1:\n        haplotype_diversity = 0.0\n    else:\n        sum_p_squared = sum(p**2 for p in overall_freq.values())\n        haplotype_diversity = (total_samples / (total_samples - 1)) * (\n            1 - sum_p_squared\n        )\n\n    # Shannon diversity index\n    # H = -sum(p_i * ln(p_i))\n    shannon_index = 0.0\n    for p in overall_freq.values():\n        if p &gt; 0:\n            shannon_index -= p * np.log(p)\n\n    # Nucleotide diversity (\u03c0)\n    nucleotide_diversity = 0.0\n    if alignment is not None and total_samples &gt; 1:\n        nucleotide_diversity = _calculate_nucleotide_diversity(\n            network, alignment, overall_freq\n        )\n\n    return DiversityMetrics(\n        haplotype_diversity=haplotype_diversity,\n        nucleotide_diversity=nucleotide_diversity,\n        shannon_index=shannon_index,\n        num_haplotypes=num_haplotypes,\n        num_samples=total_samples,\n    )\n</code></pre>"},{"location":"api/stats/statistics/#pypopart.stats.statistics.calculate_network_metrics","title":"calculate_network_metrics","text":"<pre><code>calculate_network_metrics(\n    network: HaplotypeNetwork,\n) -&gt; NetworkMetrics\n</code></pre> <p>Calculate comprehensive network topology metrics.</p> <p>Args:     network: HaplotypeNetwork object</p> <p>Returns:</p> Type Description <code>    NetworkMetrics object with calculated metrics.</code> Source code in <code>src/pypopart/stats/statistics.py</code> <pre><code>def calculate_network_metrics(network: HaplotypeNetwork) -&gt; NetworkMetrics:\n    \"\"\"\n    Calculate comprehensive network topology metrics.\n\n    Args:\n        network: HaplotypeNetwork object\n\n    Returns\n    -------\n        NetworkMetrics object with calculated metrics.\n    \"\"\"\n    G = network.to_networkx()\n\n    # Basic metrics\n    if G.number_of_nodes() == 0:\n        return NetworkMetrics(\n            diameter=0,\n            clustering_coefficient=0.0,\n            average_path_length=0.0,\n            reticulation_index=0.0,\n            num_components=0,\n            central_haplotypes=[],\n        )\n\n    # Diameter (max shortest path in largest component)\n    if nx.is_connected(G):\n        diameter = nx.diameter(G)\n        avg_path_length = nx.average_shortest_path_length(G)\n    else:\n        # For disconnected graphs, use largest component\n        largest_cc = max(nx.connected_components(G), key=len)\n        subgraph = G.subgraph(largest_cc)\n        diameter = nx.diameter(subgraph) if len(largest_cc) &gt; 1 else 0\n        avg_path_length = (\n            nx.average_shortest_path_length(subgraph) if len(largest_cc) &gt; 1 else 0.0\n        )\n\n    # Clustering coefficient\n    clustering_coefficient = nx.average_clustering(G)\n\n    # Reticulation index (proportion of alternative connections)\n    # For a tree: edges = nodes - components\n    # Reticulation = (actual_edges - tree_edges) / tree_edges\n    num_nodes = G.number_of_nodes()\n    num_edges = G.number_of_edges()\n    num_components = nx.number_connected_components(G)\n    tree_edges = num_nodes - num_components\n\n    if tree_edges &gt; 0:\n        reticulation_index = (num_edges - tree_edges) / tree_edges\n    else:\n        reticulation_index = 0.0\n\n    # Identify central haplotypes (top 3 by degree centrality)\n    degree_centrality = nx.degree_centrality(G)\n    sorted_nodes = sorted(degree_centrality.items(), key=lambda x: x[1], reverse=True)\n    central_haplotypes = [node for node, _ in sorted_nodes[:3]]\n\n    return NetworkMetrics(\n        diameter=diameter,\n        clustering_coefficient=clustering_coefficient,\n        average_path_length=avg_path_length,\n        reticulation_index=reticulation_index,\n        num_components=num_components,\n        central_haplotypes=central_haplotypes,\n    )\n</code></pre>"},{"location":"api/stats/statistics/#pypopart.stats.statistics.identify_central_haplotypes","title":"identify_central_haplotypes","text":"<pre><code>identify_central_haplotypes(\n    network: HaplotypeNetwork, method: str = \"degree\"\n) -&gt; List[Tuple[str, float]]\n</code></pre> <p>Identify central haplotypes using various centrality measures.</p> <p>Args:     network: HaplotypeNetwork object     method: Centrality method ('degree', 'betweenness', 'closeness', 'eigenvector')</p> <p>Returns:</p> Type Description <code>    List of (haplotype_id, centrality_score) tuples, sorted by score (descending).</code> Source code in <code>src/pypopart/stats/statistics.py</code> <pre><code>def identify_central_haplotypes(\n    network: HaplotypeNetwork, method: str = 'degree'\n) -&gt; List[Tuple[str, float]]:\n    \"\"\"\n    Identify central haplotypes using various centrality measures.\n\n    Args:\n        network: HaplotypeNetwork object\n        method: Centrality method ('degree', 'betweenness', 'closeness', 'eigenvector')\n\n    Returns\n    -------\n        List of (haplotype_id, centrality_score) tuples, sorted by score (descending).\n    \"\"\"\n    G = network.to_networkx()\n\n    if G.number_of_nodes() == 0:\n        return []\n\n    # Calculate centrality\n    if method == 'degree':\n        centrality = nx.degree_centrality(G)\n    elif method == 'betweenness':\n        centrality = nx.betweenness_centrality(G)\n    elif method == 'closeness':\n        if nx.is_connected(G):\n            centrality = nx.closeness_centrality(G)\n        else:\n            centrality = {}\n            for component in nx.connected_components(G):\n                subgraph = G.subgraph(component)\n                comp_centrality = nx.closeness_centrality(subgraph)\n                centrality.update(comp_centrality)\n    elif method == 'eigenvector':\n        try:\n            centrality = nx.eigenvector_centrality(G, max_iter=1000)\n        except nx.PowerIterationFailedConvergence:\n            # Fall back to degree centrality\n            centrality = nx.degree_centrality(G)\n    else:\n        raise ValueError(f'Unknown centrality method: {method}')\n\n    # Sort by centrality score\n    sorted_centrality = sorted(centrality.items(), key=lambda x: x[1], reverse=True)\n\n    return sorted_centrality\n</code></pre>"},{"location":"api/stats/statistics/#pypopart.stats.statistics.calculate_reticulation_index","title":"calculate_reticulation_index","text":"<pre><code>calculate_reticulation_index(\n    network: HaplotypeNetwork,\n) -&gt; float\n</code></pre> <p>Calculate the reticulation index of the network.</p> <p>The reticulation index measures the proportion of reticulations (alternative connections) in the network compared to a simple tree.</p> <p>Args:     network: HaplotypeNetwork object</p> <p>Returns:</p> Type Description <code>    Reticulation index (0 for a tree, &gt;0 for networks with reticulations).</code> Source code in <code>src/pypopart/stats/statistics.py</code> <pre><code>def calculate_reticulation_index(network: HaplotypeNetwork) -&gt; float:\n    \"\"\"\n    Calculate the reticulation index of the network.\n\n    The reticulation index measures the proportion of reticulations\n    (alternative connections) in the network compared to a simple tree.\n\n    Args:\n        network: HaplotypeNetwork object\n\n    Returns\n    -------\n        Reticulation index (0 for a tree, &gt;0 for networks with reticulations).\n    \"\"\"\n    G = network.to_networkx()\n\n    num_nodes = G.number_of_nodes()\n    num_edges = G.number_of_edges()\n    num_components = nx.number_connected_components(G)\n\n    if num_nodes == 0:\n        return 0.0\n\n    # For a tree: edges = nodes - components\n    tree_edges = num_nodes - num_components\n\n    if tree_edges == 0:\n        return 0.0\n\n    # Reticulation index\n    return (num_edges - tree_edges) / tree_edges\n</code></pre>"},{"location":"api/stats/statistics/#pypopart.stats.statistics.get_frequency_distribution","title":"get_frequency_distribution","text":"<pre><code>get_frequency_distribution(\n    network: HaplotypeNetwork,\n) -&gt; Dict[int, int]\n</code></pre> <p>Get the frequency distribution of haplotypes.</p> <p>Returns a dictionary mapping frequency values to the number of haplotypes with that frequency.</p> <p>Args:     network: HaplotypeNetwork object</p> <p>Returns:</p> Type Description <code>    Dictionary mapping frequency -&gt; count of haplotypes.</code> Source code in <code>src/pypopart/stats/statistics.py</code> <pre><code>def get_frequency_distribution(network: HaplotypeNetwork) -&gt; Dict[int, int]:\n    \"\"\"\n    Get the frequency distribution of haplotypes.\n\n    Returns a dictionary mapping frequency values to the number of\n    haplotypes with that frequency.\n\n    Args:\n        network: HaplotypeNetwork object\n\n    Returns\n    -------\n        Dictionary mapping frequency -&gt; count of haplotypes.\n    \"\"\"\n    frequencies = []\n\n    for hap_id in network.nodes:\n        haplotype = network.get_haplotype(hap_id)\n        if haplotype is not None:\n            frequencies.append(haplotype.frequency)\n\n    return dict(Counter(frequencies))\n</code></pre>"},{"location":"api/stats/statistics/#pypopart.stats.statistics.calculate_summary_statistics","title":"calculate_summary_statistics","text":"<pre><code>calculate_summary_statistics(\n    network: HaplotypeNetwork,\n    alignment: Optional[Alignment] = None,\n) -&gt; Dict[str, any]\n</code></pre> <p>Calculate comprehensive summary statistics for a network.</p> <p>Args:     network: HaplotypeNetwork object     alignment: Optional alignment for additional metrics</p> <p>Returns:</p> Type Description <code>    Dictionary with all calculated statistics.</code> Source code in <code>src/pypopart/stats/statistics.py</code> <pre><code>def calculate_summary_statistics(\n    network: HaplotypeNetwork, alignment: Optional[Alignment] = None\n) -&gt; Dict[str, any]:\n    \"\"\"\n    Calculate comprehensive summary statistics for a network.\n\n    Args:\n        network: HaplotypeNetwork object\n        alignment: Optional alignment for additional metrics\n\n    Returns\n    -------\n        Dictionary with all calculated statistics.\n    \"\"\"\n    # Get diversity metrics\n    diversity = calculate_diversity_metrics(network, alignment)\n\n    # Get network metrics\n    net_metrics = calculate_network_metrics(network)\n\n    # Get frequency information\n    freq_info = calculate_haplotype_frequencies(network, normalize=False)\n\n    # Get frequency distribution\n    freq_dist = get_frequency_distribution(network)\n\n    return {\n        'diversity': {\n            'haplotype_diversity': diversity.haplotype_diversity,\n            'nucleotide_diversity': diversity.nucleotide_diversity,\n            'shannon_index': diversity.shannon_index,\n            'num_haplotypes': diversity.num_haplotypes,\n            'num_samples': diversity.num_samples,\n        },\n        'network': {\n            'diameter': net_metrics.diameter,\n            'clustering_coefficient': net_metrics.clustering_coefficient,\n            'average_path_length': net_metrics.average_path_length,\n            'reticulation_index': net_metrics.reticulation_index,\n            'num_components': net_metrics.num_components,\n            'central_haplotypes': net_metrics.central_haplotypes,\n        },\n        'frequencies': freq_info,\n        'frequency_distribution': freq_dist,\n    }\n</code></pre>"},{"location":"api/stats/topology/","title":"Topology Analysis","text":"<p>Network topology analysis tools.</p>"},{"location":"api/stats/topology/#overview","title":"Overview","text":"<p>The <code>topology</code> module provides specialized network topology analyses:</p> <ul> <li>Hub identification</li> <li>Bridge detection</li> <li>Star pattern recognition</li> <li>Articulation points</li> <li>Community structure</li> </ul>"},{"location":"api/stats/topology/#modules","title":"Modules","text":""},{"location":"api/stats/topology/#pypopart.stats.topology","title":"pypopart.stats.topology","text":"<p>Network topology analysis for PyPopART.</p> <p>This module provides functions for analyzing the topology of haplotype networks, including identifying star-like patterns, partitions, and ancestral nodes.</p>"},{"location":"api/stats/topology/#pypopart.stats.topology.StarPattern","title":"StarPattern  <code>dataclass</code>","text":"<p>Represents a star-like pattern in the network.</p> Source code in <code>src/pypopart/stats/topology.py</code> <pre><code>@dataclass\nclass StarPattern:\n    \"\"\"Represents a star-like pattern in the network.\"\"\"\n\n    center: str\n    leaves: List[str]\n    center_frequency: int\n    total_frequency: int\n    is_perfect_star: bool\n</code></pre>"},{"location":"api/stats/topology/#pypopart.stats.topology.Partition","title":"Partition  <code>dataclass</code>","text":"<p>Represents a partition (connected component) in the network.</p> Source code in <code>src/pypopart/stats/topology.py</code> <pre><code>@dataclass\nclass Partition:\n    \"\"\"Represents a partition (connected component) in the network.\"\"\"\n\n    nodes: List[str]\n    num_nodes: int\n    total_samples: int\n    diameter: int\n    is_connected: bool\n</code></pre>"},{"location":"api/stats/topology/#pypopart.stats.topology.AncestralNode","title":"AncestralNode  <code>dataclass</code>","text":"<p>Represents a potential ancestral node.</p> Source code in <code>src/pypopart/stats/topology.py</code> <pre><code>@dataclass\nclass AncestralNode:\n    \"\"\"Represents a potential ancestral node.\"\"\"\n\n    node_id: str\n    score: float\n    degree: int\n    frequency: int\n    centrality: float\n    is_median_vector: bool\n</code></pre>"},{"location":"api/stats/topology/#pypopart.stats.topology.identify_star_patterns","title":"identify_star_patterns","text":"<pre><code>identify_star_patterns(\n    network: HaplotypeNetwork, min_leaves: int = 3\n) -&gt; List[StarPattern]\n</code></pre> <p>Identify star-like patterns in the network.</p> <p>A star pattern has a central node connected to multiple leaves (nodes with degree 1).</p> <p>Args:     network: HaplotypeNetwork object     min_leaves: Minimum number of leaves for a pattern to be considered</p> <p>Returns:</p> Type Description <code>    List of StarPattern objects.</code> Source code in <code>src/pypopart/stats/topology.py</code> <pre><code>def identify_star_patterns(\n    network: HaplotypeNetwork, min_leaves: int = 3\n) -&gt; List[StarPattern]:\n    \"\"\"\n    Identify star-like patterns in the network.\n\n    A star pattern has a central node connected to multiple leaves\n    (nodes with degree 1).\n\n    Args:\n        network: HaplotypeNetwork object\n        min_leaves: Minimum number of leaves for a pattern to be considered\n\n    Returns\n    -------\n        List of StarPattern objects.\n    \"\"\"\n    G = network.to_networkx()\n    patterns = []\n\n    for node in G.nodes():\n        neighbors = list(G.neighbors(node))\n\n        # Check if this node could be a star center\n        if len(neighbors) &lt; min_leaves:\n            continue\n\n        # Count how many neighbors are leaves (degree 1)\n        leaves = [n for n in neighbors if G.degree(n) == 1]\n\n        if len(leaves) &gt;= min_leaves:\n            # Get frequencies\n            center_hap = network.get_haplotype(node)\n            center_freq = center_hap.frequency if center_hap else 0\n\n            total_freq = center_freq\n            for leaf in leaves:\n                leaf_hap = network.get_haplotype(leaf)\n                if leaf_hap:\n                    total_freq += leaf_hap.frequency\n\n            # Check if it's a perfect star (all neighbors are leaves)\n            is_perfect = len(leaves) == len(neighbors)\n\n            pattern = StarPattern(\n                center=node,\n                leaves=leaves,\n                center_frequency=center_freq,\n                total_frequency=total_freq,\n                is_perfect_star=is_perfect,\n            )\n            patterns.append(pattern)\n\n    # Sort by number of leaves (descending)\n    patterns.sort(key=lambda p: len(p.leaves), reverse=True)\n\n    return patterns\n</code></pre>"},{"location":"api/stats/topology/#pypopart.stats.topology.detect_network_partitions","title":"detect_network_partitions","text":"<pre><code>detect_network_partitions(\n    network: HaplotypeNetwork,\n) -&gt; List[Partition]\n</code></pre> <p>Detect partitions (connected components) in the network.</p> <p>Args:     network: HaplotypeNetwork object</p> <p>Returns:</p> Type Description <code>    List of Partition objects, sorted by size (descending).</code> Source code in <code>src/pypopart/stats/topology.py</code> <pre><code>def detect_network_partitions(network: HaplotypeNetwork) -&gt; List[Partition]:\n    \"\"\"\n    Detect partitions (connected components) in the network.\n\n    Args:\n        network: HaplotypeNetwork object\n\n    Returns\n    -------\n        List of Partition objects, sorted by size (descending).\n    \"\"\"\n    G = network.to_networkx()\n    components = list(nx.connected_components(G))\n\n    partitions = []\n    for component in components:\n        nodes = list(component)\n        num_nodes = len(nodes)\n\n        # Calculate total samples\n        total_samples = 0\n        for node in nodes:\n            hap = network.get_haplotype(node)\n            if hap:\n                total_samples += hap.frequency\n\n        # Calculate diameter\n        subgraph = G.subgraph(component)\n        if num_nodes &gt; 1:\n            diameter = nx.diameter(subgraph)\n        else:\n            diameter = 0\n\n        partition = Partition(\n            nodes=nodes,\n            num_nodes=num_nodes,\n            total_samples=total_samples,\n            diameter=diameter,\n            is_connected=True,\n        )\n        partitions.append(partition)\n\n    # Sort by number of nodes (descending)\n    partitions.sort(key=lambda p: p.num_nodes, reverse=True)\n\n    return partitions\n</code></pre>"},{"location":"api/stats/topology/#pypopart.stats.topology.calculate_node_centrality","title":"calculate_node_centrality","text":"<pre><code>calculate_node_centrality(\n    network: HaplotypeNetwork,\n    methods: Optional[List[str]] = None,\n) -&gt; Dict[str, Dict[str, float]]\n</code></pre> <p>Calculate various centrality measures for all nodes.</p> <p>Args:     network: HaplotypeNetwork object     methods: List of centrality methods to calculate              ('degree', 'betweenness', 'closeness', 'eigenvector')              If None, calculates all methods</p> <p>Returns:</p> Type Description <code>    Dictionary mapping node_id -&gt; {method -&gt; centrality_score}.</code> Source code in <code>src/pypopart/stats/topology.py</code> <pre><code>def calculate_node_centrality(\n    network: HaplotypeNetwork, methods: Optional[List[str]] = None\n) -&gt; Dict[str, Dict[str, float]]:\n    \"\"\"\n    Calculate various centrality measures for all nodes.\n\n    Args:\n        network: HaplotypeNetwork object\n        methods: List of centrality methods to calculate\n                 ('degree', 'betweenness', 'closeness', 'eigenvector')\n                 If None, calculates all methods\n\n    Returns\n    -------\n        Dictionary mapping node_id -&gt; {method -&gt; centrality_score}.\n    \"\"\"\n    if methods is None:\n        methods = ['degree', 'betweenness', 'closeness', 'eigenvector']\n\n    G = network.to_networkx()\n    centrality_scores: Dict[str, Dict[str, float]] = defaultdict(dict)\n\n    if G.number_of_nodes() == 0:\n        return {}\n\n    # Calculate each centrality measure\n    for method in methods:\n        if method == 'degree':\n            scores = nx.degree_centrality(G)\n        elif method == 'betweenness':\n            scores = nx.betweenness_centrality(G)\n        elif method == 'closeness':\n            if nx.is_connected(G):\n                scores = nx.closeness_centrality(G)\n            else:\n                # Calculate per component\n                scores = {}\n                for component in nx.connected_components(G):\n                    subgraph = G.subgraph(component)\n                    comp_scores = nx.closeness_centrality(subgraph)\n                    scores.update(comp_scores)\n        elif method == 'eigenvector':\n            try:\n                scores = nx.eigenvector_centrality(G, max_iter=1000)\n            except (nx.PowerIterationFailedConvergence, nx.NetworkXError):\n                # Fall back to degree centrality\n                scores = nx.degree_centrality(G)\n        else:\n            continue\n\n        for node, score in scores.items():\n            centrality_scores[node][method] = score\n\n    return dict(centrality_scores)\n</code></pre>"},{"location":"api/stats/topology/#pypopart.stats.topology.identify_ancestral_nodes","title":"identify_ancestral_nodes","text":"<pre><code>identify_ancestral_nodes(\n    network: HaplotypeNetwork, top_n: int = 5\n) -&gt; List[AncestralNode]\n</code></pre> <p>Identify potential ancestral nodes in the network.</p> <p>Ancestral nodes are typically characterized by: - High frequency - High degree (many connections) - Central position in the network - High betweenness centrality</p> <p>Args:     network: HaplotypeNetwork object     top_n: Number of top candidates to return</p> <p>Returns:</p> Type Description <code>    List of AncestralNode objects, sorted by score (descending).</code> Source code in <code>src/pypopart/stats/topology.py</code> <pre><code>def identify_ancestral_nodes(\n    network: HaplotypeNetwork, top_n: int = 5\n) -&gt; List[AncestralNode]:\n    \"\"\"\n    Identify potential ancestral nodes in the network.\n\n    Ancestral nodes are typically characterized by:\n    - High frequency\n    - High degree (many connections)\n    - Central position in the network\n    - High betweenness centrality\n\n    Args:\n        network: HaplotypeNetwork object\n        top_n: Number of top candidates to return\n\n    Returns\n    -------\n        List of AncestralNode objects, sorted by score (descending).\n    \"\"\"\n    G = network.to_networkx()\n\n    if G.number_of_nodes() == 0:\n        return []\n\n    # Calculate centrality measures\n    nx.degree_centrality(G)\n    betweenness_cent = nx.betweenness_centrality(G)\n\n    # Score each node\n    candidates = []\n\n    for node in G.nodes():\n        haplotype = network.get_haplotype(node)\n        if haplotype is None:\n            continue\n\n        frequency = haplotype.frequency\n        degree = G.degree(node)\n\n        # Calculate composite score\n        # Normalize each component\n        max_freq = max(\n            network.get_haplotype(n).frequency\n            for n in G.nodes()\n            if network.get_haplotype(n) is not None\n        )\n        max_degree = max(G.degree(n) for n in G.nodes())\n\n        freq_score = frequency / max_freq if max_freq &gt; 0 else 0\n        degree_score = degree / max_degree if max_degree &gt; 0 else 0\n        betweenness_score = betweenness_cent[node]\n\n        # Composite score (weighted average)\n        score = 0.4 * freq_score + 0.3 * degree_score + 0.3 * betweenness_score\n\n        is_median = node in network._median_vectors\n\n        ancestral = AncestralNode(\n            node_id=node,\n            score=score,\n            degree=degree,\n            frequency=frequency,\n            centrality=betweenness_cent[node],\n            is_median_vector=is_median,\n        )\n        candidates.append(ancestral)\n\n    # Sort by score (descending) and return top N\n    candidates.sort(key=lambda x: x.score, reverse=True)\n\n    return candidates[:top_n]\n</code></pre>"},{"location":"api/stats/topology/#pypopart.stats.topology.calculate_topology_summary","title":"calculate_topology_summary","text":"<pre><code>calculate_topology_summary(\n    network: HaplotypeNetwork,\n) -&gt; Dict[str, any]\n</code></pre> <p>Create a comprehensive topology summary report.</p> <p>Args:     network: HaplotypeNetwork object</p> <p>Returns:</p> Type Description <code>    Dictionary with topology analysis results.</code> Source code in <code>src/pypopart/stats/topology.py</code> <pre><code>def calculate_topology_summary(network: HaplotypeNetwork) -&gt; Dict[str, any]:\n    \"\"\"\n    Create a comprehensive topology summary report.\n\n    Args:\n        network: HaplotypeNetwork object\n\n    Returns\n    -------\n        Dictionary with topology analysis results.\n    \"\"\"\n    G = network.to_networkx()\n\n    # Basic topology\n    num_nodes = G.number_of_nodes()\n    num_edges = G.number_of_edges()\n\n    if num_nodes == 0:\n        return {\n            'num_nodes': 0,\n            'num_edges': 0,\n            'star_patterns': [],\n            'partitions': [],\n            'ancestral_candidates': [],\n            'centrality': {},\n        }\n\n    # Identify patterns\n    star_patterns = identify_star_patterns(network, min_leaves=2)\n    partitions = detect_network_partitions(network)\n    ancestral_candidates = identify_ancestral_nodes(network, top_n=5)\n\n    # Calculate centrality\n    centrality = calculate_node_centrality(network)\n\n    # Network connectivity\n    is_connected = nx.is_connected(G)\n    num_components = nx.number_connected_components(G)\n\n    # Degree distribution\n    degrees = [G.degree(n) for n in G.nodes()]\n    degree_dist = {\n        'min': min(degrees) if degrees else 0,\n        'max': max(degrees) if degrees else 0,\n        'mean': sum(degrees) / len(degrees) if degrees else 0,\n        'median': sorted(degrees)[len(degrees) // 2] if degrees else 0,\n    }\n\n    return {\n        'num_nodes': num_nodes,\n        'num_edges': num_edges,\n        'is_connected': is_connected,\n        'num_components': num_components,\n        'degree_distribution': degree_dist,\n        'star_patterns': [\n            {\n                'center': p.center,\n                'num_leaves': len(p.leaves),\n                'center_frequency': p.center_frequency,\n                'is_perfect_star': p.is_perfect_star,\n            }\n            for p in star_patterns\n        ],\n        'partitions': [\n            {\n                'num_nodes': p.num_nodes,\n                'total_samples': p.total_samples,\n                'diameter': p.diameter,\n            }\n            for p in partitions\n        ],\n        'ancestral_candidates': [\n            {\n                'node_id': a.node_id,\n                'score': a.score,\n                'degree': a.degree,\n                'frequency': a.frequency,\n                'is_median_vector': a.is_median_vector,\n            }\n            for a in ancestral_candidates\n        ],\n        'top_central_nodes': {\n            method: sorted(scores.items(), key=lambda x: x[1], reverse=True)[:5]\n            for method, scores in (\n                (\n                    'degree',\n                    {n: c['degree'] for n, c in centrality.items() if 'degree' in c},\n                ),\n                (\n                    'betweenness',\n                    {\n                        n: c['betweenness']\n                        for n, c in centrality.items()\n                        if 'betweenness' in c\n                    },\n                ),\n            )\n        },\n    }\n</code></pre>"},{"location":"api/stats/topology/#pypopart.stats.topology.find_central_hub_nodes","title":"find_central_hub_nodes","text":"<pre><code>find_central_hub_nodes(\n    network: HaplotypeNetwork,\n    degree_threshold: Optional[int] = None,\n) -&gt; List[Tuple[str, int]]\n</code></pre> <p>Find hub nodes (nodes with high degree).</p> <p>Args:     network: HaplotypeNetwork object     degree_threshold: Minimum degree to be considered a hub                      If None, uses mean degree + 1 std dev</p> <p>Returns:</p> Type Description <code>    List of (node_id, degree) tuples, sorted by degree (descending).</code> Source code in <code>src/pypopart/stats/topology.py</code> <pre><code>def find_central_hub_nodes(\n    network: HaplotypeNetwork, degree_threshold: Optional[int] = None\n) -&gt; List[Tuple[str, int]]:\n    \"\"\"\n    Find hub nodes (nodes with high degree).\n\n    Args:\n        network: HaplotypeNetwork object\n        degree_threshold: Minimum degree to be considered a hub\n                         If None, uses mean degree + 1 std dev\n\n    Returns\n    -------\n        List of (node_id, degree) tuples, sorted by degree (descending).\n    \"\"\"\n    G = network.to_networkx()\n\n    if G.number_of_nodes() == 0:\n        return []\n\n    degrees = dict(G.degree())\n\n    if degree_threshold is None:\n        # Calculate threshold as mean + 1 std dev\n        degree_values = list(degrees.values())\n        mean_degree = sum(degree_values) / len(degree_values)\n\n        if len(degree_values) &gt; 1:\n            variance = sum((d - mean_degree) ** 2 for d in degree_values) / len(\n                degree_values\n            )\n            std_dev = variance**0.5\n            degree_threshold = int(mean_degree + std_dev)\n        else:\n            degree_threshold = 0\n\n    # Find hubs\n    hubs = [\n        (node, degree) for node, degree in degrees.items() if degree &gt;= degree_threshold\n    ]\n\n    # Sort by degree (descending)\n    hubs.sort(key=lambda x: x[1], reverse=True)\n\n    return hubs\n</code></pre>"},{"location":"api/stats/topology/#pypopart.stats.topology.detect_bridges","title":"detect_bridges","text":"<pre><code>detect_bridges(\n    network: HaplotypeNetwork,\n) -&gt; List[Tuple[str, str]]\n</code></pre> <p>Detect bridge edges in the network.</p> <p>A bridge is an edge whose removal would disconnect the network or increase the number of connected components.</p> <p>Args:     network: HaplotypeNetwork object</p> <p>Returns:</p> Type Description <code>    List of (node1, node2) tuples representing bridge edges.</code> Source code in <code>src/pypopart/stats/topology.py</code> <pre><code>def detect_bridges(network: HaplotypeNetwork) -&gt; List[Tuple[str, str]]:\n    \"\"\"\n    Detect bridge edges in the network.\n\n    A bridge is an edge whose removal would disconnect the network\n    or increase the number of connected components.\n\n    Args:\n        network: HaplotypeNetwork object\n\n    Returns\n    -------\n        List of (node1, node2) tuples representing bridge edges.\n    \"\"\"\n    G = network.to_networkx()\n\n    if G.number_of_nodes() &lt; 2:\n        return []\n\n    # Find bridges using NetworkX\n    bridges = list(nx.bridges(G))\n\n    return bridges\n</code></pre>"},{"location":"api/stats/topology/#pypopart.stats.topology.identify_bottleneck_nodes","title":"identify_bottleneck_nodes","text":"<pre><code>identify_bottleneck_nodes(\n    network: HaplotypeNetwork,\n) -&gt; List[Tuple[str, float]]\n</code></pre> <p>Identify bottleneck nodes (articulation points with high betweenness).</p> <p>Bottleneck nodes are those whose removal would significantly disrupt information flow in the network.</p> <p>Args:     network: HaplotypeNetwork object</p> <p>Returns:</p> Type Description <code>    List of (node_id, betweenness_score) tuples, sorted by score (descending).</code> Source code in <code>src/pypopart/stats/topology.py</code> <pre><code>def identify_bottleneck_nodes(network: HaplotypeNetwork) -&gt; List[Tuple[str, float]]:\n    \"\"\"\n    Identify bottleneck nodes (articulation points with high betweenness).\n\n    Bottleneck nodes are those whose removal would significantly\n    disrupt information flow in the network.\n\n    Args:\n        network: HaplotypeNetwork object\n\n    Returns\n    -------\n        List of (node_id, betweenness_score) tuples, sorted by score (descending).\n    \"\"\"\n    G = network.to_networkx()\n\n    if G.number_of_nodes() &lt; 3:\n        return []\n\n    # Find articulation points (cut vertices)\n    articulation_points = set(nx.articulation_points(G))\n\n    if not articulation_points:\n        return []\n\n    # Calculate betweenness centrality for articulation points\n    betweenness = nx.betweenness_centrality(G)\n\n    bottlenecks = [(node, betweenness[node]) for node in articulation_points]\n\n    # Sort by betweenness (descending)\n    bottlenecks.sort(key=lambda x: x[1], reverse=True)\n\n    return bottlenecks\n</code></pre>"},{"location":"api/visualization/interactive/","title":"Interactive Visualization","text":"<p>Interactive HTML-based network exploration.</p>"},{"location":"api/visualization/interactive/#overview","title":"Overview","text":"<p>The <code>interactive_plot</code> module provides Plotly-based interactive visualizations.</p> <p>Features: - HTML output - Zoom and pan - Hover information - Click selection - Web embedding</p>"},{"location":"api/visualization/interactive/#modules","title":"Modules","text":""},{"location":"api/visualization/interactive/#pypopart.visualization.interactive_plot","title":"pypopart.visualization.interactive_plot","text":"<p>Interactive network visualization using Plotly for PyPopART.</p> <p>Provides Plotly-based interactive plotting for haplotype networks with hover information, zoom/pan, and clickable elements.</p>"},{"location":"api/visualization/interactive/#pypopart.visualization.interactive_plot.InteractiveNetworkPlotter","title":"InteractiveNetworkPlotter","text":"<p>Interactive network plotter using Plotly.</p> <p>Creates interactive visualizations of haplotype networks with hover information, zoom/pan controls, and clickable nodes.</p> Source code in <code>src/pypopart/visualization/interactive_plot.py</code> <pre><code>class InteractiveNetworkPlotter:\n    \"\"\"\n    Interactive network plotter using Plotly.\n\n    Creates interactive visualizations of haplotype networks with\n    hover information, zoom/pan controls, and clickable nodes.\n    \"\"\"\n\n    def __init__(self, network: HaplotypeNetwork):\n        \"\"\"\n        Initialize interactive plotter with a haplotype network.\n\n        Parameters\n        ----------\n        network :\n            HaplotypeNetwork object to visualize.\n        \"\"\"\n        self.network = network\n        self.figure = None\n\n    def plot(\n        self,\n        layout: Optional[Dict[str, Tuple[float, float]]] = None,\n        layout_algorithm: str = 'spring',\n        node_size_scale: float = 20.0,\n        node_color_map: Optional[Dict[str, str]] = None,\n        population_colors: Optional[Dict[str, str]] = None,\n        edge_width_scale: float = 2.0,\n        show_labels: bool = True,\n        show_edge_labels: bool = True,\n        median_vector_color: str = 'lightgray',\n        title: Optional[str] = None,\n        width: int = 1000,\n        height: int = 800,\n        **kwargs,\n    ) -&gt; Figure:\n        \"\"\"\n            Create an interactive network plot.\n\n        Parameters\n        ----------\n            layout :\n                Pre-computed node positions {node_id: (x, y)}.\n            layout_algorithm :\n                NetworkX layout algorithm ('spring', 'circular', 'kamada_kawai').\n            node_size_scale :\n                Scaling factor for node sizes.\n            node_color_map :\n                Custom color mapping {node_id: color}.\n            population_colors :\n                Color mapping for populations {pop_name: color}.\n            edge_width_scale :\n                Scaling factor for edge widths.\n            show_labels :\n                Whether to show node labels.\n            show_edge_labels :\n                Whether to show edge labels with mutation counts.\n            median_vector_color :\n                Color for median vector nodes.\n            title :\n                Plot title.\n            width :\n                Figure width in pixels.\n            height :\n                Figure height in pixels.\n            **kwargs :\n                Additional layout arguments.\n\n        Returns\n        -------\n            Plotly Figure object.\n        \"\"\"\n        # Get graph and compute layout if not provided\n        graph = self.network._graph\n        if layout is None:\n            layout = self._compute_layout(graph, layout_algorithm)\n\n        # Create figure\n        self.figure = go.Figure()\n\n        # Add edges first (so they appear below nodes)\n        self._add_edges(graph, layout, edge_width_scale, show_edge_labels)\n\n        # Add nodes\n        self._add_nodes(\n            graph,\n            layout,\n            node_size_scale,\n            node_color_map,\n            population_colors,\n            median_vector_color,\n            show_labels,\n        )\n\n        # Update layout\n        plot_title = title if title else self.network.name\n        self.figure.update_layout(\n            title={\n                'text': plot_title,\n                'x': 0.5,\n                'xanchor': 'center',\n                'font': {'size': 20},\n            },\n            showlegend=True,\n            hovermode='closest',\n            width=width,\n            height=height,\n            xaxis={'showgrid': False, 'zeroline': False, 'showticklabels': False},\n            yaxis={'showgrid': False, 'zeroline': False, 'showticklabels': False},\n            plot_bgcolor='white',\n            **kwargs,\n        )\n\n        return self.figure\n\n    def add_population_legend(self, population_colors: Dict[str, str]) -&gt; None:\n        \"\"\"\n        Add a legend for population colors.\n\n        Parameters\n        ----------\n        population_colors :\n            Color mapping for populations.\n        \"\"\"\n        if self.figure is None:\n            raise ValueError('No plot exists. Call plot() first.')\n\n        # Add invisible traces for legend\n        for pop_name, color in sorted(population_colors.items()):\n            self.figure.add_trace(\n                go.Scatter(\n                    x=[None],\n                    y=[None],\n                    mode='markers',\n                    marker={'size': 10, 'color': color},\n                    showlegend=True,\n                    name=pop_name,\n                    hoverinfo='skip',\n                )\n            )\n\n    def save_html(self, filename: str, auto_open: bool = False, **kwargs) -&gt; None:\n        \"\"\"\n        Save the interactive plot as an HTML file.\n\n        Parameters\n        ----------\n        filename :\n            Output filename (should end with .html).\n        auto_open :\n            Whether to automatically open in browser.\n        **kwargs :\n            Additional arguments passed to write_html().\n        \"\"\"\n        if self.figure is None:\n            raise ValueError('No plot exists. Call plot() first.')\n\n        self.figure.write_html(filename, auto_open=auto_open, **kwargs)\n\n    def show(self) -&gt; None:\n        \"\"\"Display the interactive plot in a browser or notebook.\"\"\"\n        if self.figure is None:\n            raise ValueError('No plot exists. Call plot() first.')\n\n        self.figure.show()\n\n    def _compute_layout(\n        self, graph: nx.Graph, algorithm: str\n    ) -&gt; Dict[str, Tuple[float, float]]:\n        \"\"\"\n            Compute node layout using specified algorithm.\n\n        Parameters\n        ----------\n            graph :\n                NetworkX graph.\n            algorithm :\n                Layout algorithm name.\n\n        Returns\n        -------\n            Dictionary mapping node IDs to (x, y) positions.\n        \"\"\"\n        if algorithm == 'spring':\n            return nx.spring_layout(graph, k=1, iterations=50)\n        elif algorithm == 'circular':\n            return nx.circular_layout(graph)\n        elif algorithm == 'kamada_kawai':\n            return nx.kamada_kawai_layout(graph)\n        elif algorithm == 'spectral':\n            return nx.spectral_layout(graph)\n        elif algorithm == 'shell':\n            return nx.shell_layout(graph)\n        else:\n            raise ValueError(f'Unknown layout algorithm: {algorithm}')\n\n    def _add_edges(\n        self,\n        graph: nx.Graph,\n        layout: Dict[str, Tuple[float, float]],\n        width_scale: float,\n        show_edge_labels: bool = True,\n    ) -&gt; None:\n        \"\"\"\n        Add edges to the plot.\n\n        Parameters\n        ----------\n        graph :\n            NetworkX graph.\n        layout :\n            Node positions.\n        width_scale :\n            Edge width scaling factor.\n        show_edge_labels :\n            Whether to show edge labels with mutation counts.\n        \"\"\"\n        edge_traces = []\n        edge_annotations = []\n\n        for u, v in graph.edges():\n            x0, y0 = layout[u]\n            x1, y1 = layout[v]\n\n            # Get edge weight\n            weight = graph[u][v].get('weight', 1)\n\n            # Calculate width (inverse of distance)\n            width = width_scale * max(0.5, 3.0 / max(weight, 1))\n\n            # Create hover text\n            hover_text = f'{u} \u2194 {v}&lt;br&gt;Distance: {weight} mutation(s)&lt;br&gt;'\n\n            # Create edge trace\n            edge_trace = go.Scatter(\n                x=[x0, x1, None],\n                y=[y0, y1, None],\n                mode='lines',\n                line={'width': width, 'color': 'rgba(150, 150, 150, 0.6)'},\n                hoverinfo='text',\n                hovertext=hover_text,\n                showlegend=False,\n            )\n\n            edge_traces.append(edge_trace)\n\n            # Add edge label annotation if requested\n            if show_edge_labels and weight &gt; 0:\n                # Position label at midpoint of edge\n                x_mid = (x0 + x1) / 2\n                y_mid = (y0 + y1) / 2\n\n                edge_annotations.append(\n                    {\n                        'x': x_mid,\n                        'y': y_mid,\n                        'text': str(int(weight)),\n                        'showarrow': False,\n                        'font': {'size': 10, 'color': 'rgba(100, 100, 100, 0.8)'},\n                        'bgcolor': 'rgba(255, 255, 255, 0.7)',\n                        'borderpad': 2,\n                    }\n                )\n\n        # Add all edge traces\n        for trace in edge_traces:\n            self.figure.add_trace(trace)\n\n        # Add edge label annotations\n        if edge_annotations:\n            self.figure.update_layout(annotations=edge_annotations)\n\n    def _add_nodes(\n        self,\n        graph: nx.Graph,\n        layout: Dict[str, Tuple[float, float]],\n        size_scale: float,\n        node_color_map: Optional[Dict[str, str]],\n        population_colors: Optional[Dict[str, str]],\n        median_vector_color: str,\n        show_labels: bool,\n    ) -&gt; None:\n        \"\"\"\n        Add nodes to the plot.\n\n        Parameters\n        ----------\n        graph :\n            NetworkX graph.\n        layout :\n            Node positions.\n        size_scale :\n            Node size scaling factor.\n        node_color_map :\n            Custom node color mapping.\n        population_colors :\n            Population color mapping.\n        median_vector_color :\n            Color for median vectors.\n        show_labels :\n            Whether to show node labels.\n        \"\"\"\n        # Separate haplotypes and median vectors\n        haplotype_nodes = [\n            n for n in graph.nodes() if not self.network.is_median_vector(n)\n        ]\n        median_nodes = self.network.median_vector_ids\n\n        # Add haplotype nodes\n        if haplotype_nodes:\n            self._add_node_trace(\n                haplotype_nodes,\n                layout,\n                size_scale,\n                node_color_map,\n                population_colors,\n                'circle',\n                show_labels,\n                is_median=False,\n            )\n\n        # Add median vector nodes\n        if median_nodes:\n            self._add_node_trace(\n                median_nodes,\n                layout,\n                size_scale,\n                dict.fromkeys(median_nodes, median_vector_color),\n                None,\n                'square',\n                show_labels,\n                is_median=True,\n            )\n\n    def _add_node_trace(\n        self,\n        nodes: List[str],\n        layout: Dict[str, Tuple[float, float]],\n        size_scale: float,\n        node_color_map: Optional[Dict[str, str]],\n        population_colors: Optional[Dict[str, str]],\n        symbol: str,\n        show_labels: bool,\n        is_median: bool,\n    ) -&gt; None:\n        \"\"\"\n        Add a trace for a group of nodes.\n\n        Parameters\n        ----------\n        nodes :\n            List of node IDs.\n        layout :\n            Node positions.\n        size_scale :\n            Size scaling factor.\n        node_color_map :\n            Custom color mapping.\n        population_colors :\n            Population color mapping.\n        symbol :\n            Marker symbol ('circle' or 'square').\n        show_labels :\n            Whether to show labels.\n        is_median :\n            Whether these are median vectors.\n        \"\"\"\n        x_coords = []\n        y_coords = []\n        sizes = []\n        colors = []\n        texts = []\n        hover_texts = []\n\n        for node in nodes:\n            # Position\n            x, y = layout[node]\n            x_coords.append(x)\n            y_coords.append(y)\n\n            # Get haplotype data\n            hap = self.network.get_haplotype(node)\n\n            # Size\n            if is_median:\n                sizes.append(size_scale * 0.8)\n            elif hap:\n                sizes.append(size_scale * np.sqrt(hap.frequency))\n            else:\n                sizes.append(size_scale * 0.5)\n\n            # Color\n            color = self._get_node_color(\n                node, hap, node_color_map, population_colors, is_median\n            )\n            colors.append(color)\n\n            # Label\n            if show_labels:\n                texts.append(node)\n            else:\n                texts.append('')\n\n            # Hover text\n            hover_text = self._create_hover_text(node, hap, is_median)\n            hover_texts.append(hover_text)\n\n        # Create node trace\n        node_trace = go.Scatter(\n            x=x_coords,\n            y=y_coords,\n            mode='markers+text' if show_labels else 'markers',\n            marker={\n                'size': sizes,\n                'color': colors,\n                'symbol': symbol,\n                'line': {'width': 2, 'color': 'black'},\n            },\n            text=texts,\n            textposition='top center',\n            textfont={'size': 10, 'family': 'Arial Black'},\n            hoverinfo='text',\n            hovertext=hover_texts,\n            showlegend=False,\n        )\n\n        self.figure.add_trace(node_trace)\n\n    def _get_node_color(\n        self,\n        node: str,\n        hap: Any,\n        node_color_map: Optional[Dict[str, str]],\n        population_colors: Optional[Dict[str, str]],\n        is_median: bool,\n    ) -&gt; str:\n        \"\"\"\n            Determine node color based on priority.\n\n        Parameters\n        ----------\n            node :\n                Node ID.\n            hap :\n                Haplotype object or None.\n            node_color_map :\n                Custom color mapping.\n            population_colors :\n                Population color mapping.\n            is_median :\n                Whether this is a median vector.\n\n        Returns\n        -------\n            Color string.\n        \"\"\"\n        if is_median:\n            return 'lightgray'\n        elif node_color_map and node in node_color_map:\n            return node_color_map[node]\n        elif population_colors and hap:\n            pop_counts = hap.get_frequency_by_population()\n            if pop_counts:\n                # Find dominant population\n                dominant_pop = max(pop_counts.items(), key=lambda x: x[1])[0]\n                return population_colors.get(dominant_pop, 'lightblue')\n\n        return 'lightblue'\n\n    def _create_hover_text(self, node: str, hap: Any, is_median: bool) -&gt; str:\n        \"\"\"\n            Create hover text for a node.\n\n        Parameters\n        ----------\n            node :\n                Node ID.\n            hap :\n                Haplotype object or None.\n            is_median :\n                Whether this is a median vector.\n\n        Returns\n        -------\n            Formatted hover text string.\n        \"\"\"\n        lines = [f'&lt;b&gt;{node}&lt;/b&gt;']\n\n        if is_median:\n            lines.append('Type: Median Vector')\n        elif hap:\n            lines.append(f'Frequency: {hap.frequency}')\n\n            # Add population information\n            pop_counts = hap.get_frequency_by_population()\n            if pop_counts:\n                lines.append('&lt;br&gt;&lt;b&gt;Populations:&lt;/b&gt;')\n                for pop, count in sorted(pop_counts.items()):\n                    lines.append(f'  {pop}: {count}')\n\n            # Add sample IDs if not too many\n            sample_ids = hap.sample_ids\n            if len(sample_ids) &lt;= 10:\n                lines.append('&lt;br&gt;&lt;b&gt;Samples:&lt;/b&gt;')\n                lines.append(', '.join(sample_ids))\n            else:\n                lines.append(f'&lt;br&gt;&lt;b&gt;Samples:&lt;/b&gt; {len(sample_ids)} total')\n\n        return '&lt;br&gt;'.join(lines)\n</code></pre>"},{"location":"api/visualization/interactive/#pypopart.visualization.interactive_plot.InteractiveNetworkPlotter.__init__","title":"__init__","text":"<pre><code>__init__(network: HaplotypeNetwork)\n</code></pre> <p>Initialize interactive plotter with a haplotype network.</p> <p>Parameters:</p> Name Type Description Default <code>network</code> <code>HaplotypeNetwork</code> <p>HaplotypeNetwork object to visualize.</p> required Source code in <code>src/pypopart/visualization/interactive_plot.py</code> <pre><code>def __init__(self, network: HaplotypeNetwork):\n    \"\"\"\n    Initialize interactive plotter with a haplotype network.\n\n    Parameters\n    ----------\n    network :\n        HaplotypeNetwork object to visualize.\n    \"\"\"\n    self.network = network\n    self.figure = None\n</code></pre>"},{"location":"api/visualization/interactive/#pypopart.visualization.interactive_plot.InteractiveNetworkPlotter.plot","title":"plot","text":"<pre><code>plot(\n    layout: Optional[Dict[str, Tuple[float, float]]] = None,\n    layout_algorithm: str = \"spring\",\n    node_size_scale: float = 20.0,\n    node_color_map: Optional[Dict[str, str]] = None,\n    population_colors: Optional[Dict[str, str]] = None,\n    edge_width_scale: float = 2.0,\n    show_labels: bool = True,\n    show_edge_labels: bool = True,\n    median_vector_color: str = \"lightgray\",\n    title: Optional[str] = None,\n    width: int = 1000,\n    height: int = 800,\n    **kwargs\n) -&gt; Figure\n</code></pre> <pre><code>Create an interactive network plot.\n</code></pre> <p>Returns:</p> Type Description <code>    Plotly Figure object.</code> Source code in <code>src/pypopart/visualization/interactive_plot.py</code> <pre><code>def plot(\n    self,\n    layout: Optional[Dict[str, Tuple[float, float]]] = None,\n    layout_algorithm: str = 'spring',\n    node_size_scale: float = 20.0,\n    node_color_map: Optional[Dict[str, str]] = None,\n    population_colors: Optional[Dict[str, str]] = None,\n    edge_width_scale: float = 2.0,\n    show_labels: bool = True,\n    show_edge_labels: bool = True,\n    median_vector_color: str = 'lightgray',\n    title: Optional[str] = None,\n    width: int = 1000,\n    height: int = 800,\n    **kwargs,\n) -&gt; Figure:\n    \"\"\"\n        Create an interactive network plot.\n\n    Parameters\n    ----------\n        layout :\n            Pre-computed node positions {node_id: (x, y)}.\n        layout_algorithm :\n            NetworkX layout algorithm ('spring', 'circular', 'kamada_kawai').\n        node_size_scale :\n            Scaling factor for node sizes.\n        node_color_map :\n            Custom color mapping {node_id: color}.\n        population_colors :\n            Color mapping for populations {pop_name: color}.\n        edge_width_scale :\n            Scaling factor for edge widths.\n        show_labels :\n            Whether to show node labels.\n        show_edge_labels :\n            Whether to show edge labels with mutation counts.\n        median_vector_color :\n            Color for median vector nodes.\n        title :\n            Plot title.\n        width :\n            Figure width in pixels.\n        height :\n            Figure height in pixels.\n        **kwargs :\n            Additional layout arguments.\n\n    Returns\n    -------\n        Plotly Figure object.\n    \"\"\"\n    # Get graph and compute layout if not provided\n    graph = self.network._graph\n    if layout is None:\n        layout = self._compute_layout(graph, layout_algorithm)\n\n    # Create figure\n    self.figure = go.Figure()\n\n    # Add edges first (so they appear below nodes)\n    self._add_edges(graph, layout, edge_width_scale, show_edge_labels)\n\n    # Add nodes\n    self._add_nodes(\n        graph,\n        layout,\n        node_size_scale,\n        node_color_map,\n        population_colors,\n        median_vector_color,\n        show_labels,\n    )\n\n    # Update layout\n    plot_title = title if title else self.network.name\n    self.figure.update_layout(\n        title={\n            'text': plot_title,\n            'x': 0.5,\n            'xanchor': 'center',\n            'font': {'size': 20},\n        },\n        showlegend=True,\n        hovermode='closest',\n        width=width,\n        height=height,\n        xaxis={'showgrid': False, 'zeroline': False, 'showticklabels': False},\n        yaxis={'showgrid': False, 'zeroline': False, 'showticklabels': False},\n        plot_bgcolor='white',\n        **kwargs,\n    )\n\n    return self.figure\n</code></pre>"},{"location":"api/visualization/interactive/#pypopart.visualization.interactive_plot.InteractiveNetworkPlotter.add_population_legend","title":"add_population_legend","text":"<pre><code>add_population_legend(\n    population_colors: Dict[str, str],\n) -&gt; None\n</code></pre> <p>Add a legend for population colors.</p> <p>Parameters:</p> Name Type Description Default <code>population_colors</code> <code>Dict[str, str]</code> <p>Color mapping for populations.</p> required Source code in <code>src/pypopart/visualization/interactive_plot.py</code> <pre><code>def add_population_legend(self, population_colors: Dict[str, str]) -&gt; None:\n    \"\"\"\n    Add a legend for population colors.\n\n    Parameters\n    ----------\n    population_colors :\n        Color mapping for populations.\n    \"\"\"\n    if self.figure is None:\n        raise ValueError('No plot exists. Call plot() first.')\n\n    # Add invisible traces for legend\n    for pop_name, color in sorted(population_colors.items()):\n        self.figure.add_trace(\n            go.Scatter(\n                x=[None],\n                y=[None],\n                mode='markers',\n                marker={'size': 10, 'color': color},\n                showlegend=True,\n                name=pop_name,\n                hoverinfo='skip',\n            )\n        )\n</code></pre>"},{"location":"api/visualization/interactive/#pypopart.visualization.interactive_plot.InteractiveNetworkPlotter.save_html","title":"save_html","text":"<pre><code>save_html(\n    filename: str, auto_open: bool = False, **kwargs\n) -&gt; None\n</code></pre> <p>Save the interactive plot as an HTML file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Output filename (should end with .html).</p> required <code>auto_open</code> <code>bool</code> <p>Whether to automatically open in browser.</p> <code>False</code> <code>**kwargs</code> <p>Additional arguments passed to write_html().</p> <code>{}</code> Source code in <code>src/pypopart/visualization/interactive_plot.py</code> <pre><code>def save_html(self, filename: str, auto_open: bool = False, **kwargs) -&gt; None:\n    \"\"\"\n    Save the interactive plot as an HTML file.\n\n    Parameters\n    ----------\n    filename :\n        Output filename (should end with .html).\n    auto_open :\n        Whether to automatically open in browser.\n    **kwargs :\n        Additional arguments passed to write_html().\n    \"\"\"\n    if self.figure is None:\n        raise ValueError('No plot exists. Call plot() first.')\n\n    self.figure.write_html(filename, auto_open=auto_open, **kwargs)\n</code></pre>"},{"location":"api/visualization/interactive/#pypopart.visualization.interactive_plot.InteractiveNetworkPlotter.show","title":"show","text":"<pre><code>show() -&gt; None\n</code></pre> <p>Display the interactive plot in a browser or notebook.</p> Source code in <code>src/pypopart/visualization/interactive_plot.py</code> <pre><code>def show(self) -&gt; None:\n    \"\"\"Display the interactive plot in a browser or notebook.\"\"\"\n    if self.figure is None:\n        raise ValueError('No plot exists. Call plot() first.')\n\n    self.figure.show()\n</code></pre>"},{"location":"api/visualization/interactive/#pypopart.visualization.interactive_plot.plot_interactive_network","title":"plot_interactive_network","text":"<pre><code>plot_interactive_network(\n    network: HaplotypeNetwork, **kwargs\n) -&gt; Figure\n</code></pre> <p>Plot an interactive haplotype network.</p> <p>Args:     network: HaplotypeNetwork object to visualize     **kwargs: Arguments passed to InteractiveNetworkPlotter.plot()</p> <p>Returns:</p> Name Type Description <code>    Plotly Figure object.</code> <code>Example</code> <code>Figure</code> <p>from pypopart.core.graph import HaplotypeNetwork from pypopart.visualization.interactive_plot import plot_interactive_network network = HaplotypeNetwork()</p> Source code in <code>src/pypopart/visualization/interactive_plot.py</code> <pre><code>def plot_interactive_network(network: HaplotypeNetwork, **kwargs) -&gt; Figure:\n    \"\"\"\n    Plot an interactive haplotype network.\n\n    Args:\n        network: HaplotypeNetwork object to visualize\n        **kwargs: Arguments passed to InteractiveNetworkPlotter.plot()\n\n    Returns\n    -------\n        Plotly Figure object.\n\n    Example:\n        &gt;&gt;&gt; from pypopart.core.graph import HaplotypeNetwork\n        &gt;&gt;&gt; from pypopart.visualization.interactive_plot import plot_interactive_network\n        &gt;&gt;&gt; network = HaplotypeNetwork()\n        &gt;&gt;&gt; # ... build network ...\n        &gt;&gt;&gt; fig = plot_interactive_network(network, layout_algorithm='spring')\n        &gt;&gt;&gt; fig.show()\n    \"\"\"\n    plotter = InteractiveNetworkPlotter(network)\n    return plotter.plot(**kwargs)\n</code></pre>"},{"location":"api/visualization/interactive/#pypopart.visualization.interactive_plot.plot_interactive_network--build-network","title":"... build network ...","text":"<p>fig = plot_interactive_network(network, layout_algorithm='spring') fig.show()</p>"},{"location":"api/visualization/interactive/#pypopart.visualization.interactive_plot.create_interactive_figure","title":"create_interactive_figure","text":"<pre><code>create_interactive_figure(\n    network: HaplotypeNetwork,\n    population_colors: Optional[Dict[str, str]] = None,\n    filename: Optional[str] = None,\n    auto_open: bool = False,\n    **kwargs\n) -&gt; Figure\n</code></pre> <p>Create an interactive figure with legend.</p> <p>Args:     network: HaplotypeNetwork object to visualize     population_colors: Color mapping for populations     filename: Optional filename to save HTML file     auto_open: Whether to open the file in browser     **kwargs: Additional arguments passed to plot()</p> <p>Returns:</p> Name Type Description <code>    Plotly Figure object.</code> <code>Example</code> <code>Figure</code> <p>fig = create_interactive_figure( ...     network, ...     population_colors={'PopA': 'red', 'PopB': 'blue'}, ...     filename='network.html' ... )</p> Source code in <code>src/pypopart/visualization/interactive_plot.py</code> <pre><code>def create_interactive_figure(\n    network: HaplotypeNetwork,\n    population_colors: Optional[Dict[str, str]] = None,\n    filename: Optional[str] = None,\n    auto_open: bool = False,\n    **kwargs,\n) -&gt; Figure:\n    \"\"\"\n    Create an interactive figure with legend.\n\n    Args:\n        network: HaplotypeNetwork object to visualize\n        population_colors: Color mapping for populations\n        filename: Optional filename to save HTML file\n        auto_open: Whether to open the file in browser\n        **kwargs: Additional arguments passed to plot()\n\n    Returns\n    -------\n        Plotly Figure object.\n\n    Example:\n        &gt;&gt;&gt; fig = create_interactive_figure(\n        ...     network,\n        ...     population_colors={'PopA': 'red', 'PopB': 'blue'},\n        ...     filename='network.html'\n        ... )\n    \"\"\"\n    plotter = InteractiveNetworkPlotter(network)\n\n    # Create plot\n    fig = plotter.plot(population_colors=population_colors, **kwargs)\n\n    # Add legend if population colors provided\n    if population_colors:\n        plotter.add_population_legend(population_colors)\n\n    # Save if filename provided\n    if filename:\n        plotter.save_html(filename, auto_open=auto_open)\n\n    return fig\n</code></pre>"},{"location":"api/visualization/layout/","title":"Layout Algorithms","text":"<p>Network layout and positioning algorithms.</p>"},{"location":"api/visualization/layout/#overview","title":"Overview","text":"<p>The <code>layout.algorithms</code> module provides various network layout algorithms:</p> <ul> <li>Spring: Force-directed layout</li> <li>Circular: Circular arrangement</li> <li>Kamada-Kawai: Energy minimization</li> <li>Spectral: Eigenvalue-based</li> </ul>"},{"location":"api/visualization/layout/#modules","title":"Modules","text":""},{"location":"api/visualization/layout/#pypopart.layout.algorithms","title":"pypopart.layout.algorithms","text":"<p>Layout algorithms for network visualization in PyPopART.</p> <p>Provides various layout algorithms for positioning nodes in haplotype networks, including force-directed, hierarchical, spectral, and custom layouts.</p> Algorithm Selection Guide <p>For small networks (&lt;50 nodes):     - KamadaKawaiLayout: Best quality, slow     - ForceDirectedLayout: Good quality, moderate speed</p> <p>For medium networks (50-500 nodes):     - ForceDirectedLayout: Default choice, good balance     - SpectralLayout: Faster alternative, good quality     - HierarchicalLayout: Very fast, tree-like structure</p> <p>For large networks (&gt;500 nodes):     - SpectralLayout: Fast, maintains structure     - HierarchicalLayout: Fastest option     - CircularLayout: Simple, very fast</p> <p>Special purposes:     - RadialLayout: Emphasize central node     - CircularLayout: Show connectivity patterns</p>"},{"location":"api/visualization/layout/#pypopart.layout.algorithms.LayoutAlgorithm","title":"LayoutAlgorithm","text":"<p>Base class for layout algorithms.</p> <p>Provides interface for computing node positions in network visualizations.</p> Source code in <code>src/pypopart/layout/algorithms.py</code> <pre><code>class LayoutAlgorithm:\n    \"\"\"\n    Base class for layout algorithms.\n\n    Provides interface for computing node positions in network visualizations.\n    \"\"\"\n\n    def __init__(self, network: HaplotypeNetwork):\n        \"\"\"\n        Initialize layout algorithm with a network.\n\n        Parameters\n        ----------\n        network :\n            HaplotypeNetwork object.\n        \"\"\"\n        self.network = network\n        self.graph = network._graph\n\n    def compute(self, **kwargs) -&gt; Dict[str, Tuple[float, float]]:\n        \"\"\"\n            Compute node positions.\n\n        Parameters\n        ----------\n            **kwargs :\n                Algorithm-specific parameters.\n\n        Returns\n        -------\n            Dictionary mapping node IDs to (x, y) positions.\n        \"\"\"\n        raise NotImplementedError('Subclasses must implement compute()')\n\n    def save_layout(\n        self, layout: Dict[str, Tuple[float, float]], filename: str\n    ) -&gt; None:\n        \"\"\"\n        Save layout to a JSON file.\n\n        Parameters\n        ----------\n        layout :\n            Node positions dictionary.\n        filename :\n            Output filename.\n        \"\"\"\n        # Convert tuples to lists for JSON serialization\n        layout_serializable = {node: list(pos) for node, pos in layout.items()}\n\n        with open(filename, 'w') as f:\n            json.dump(layout_serializable, f, indent=2)\n\n    @staticmethod\n    def load_layout(filename: str) -&gt; Dict[str, Tuple[float, float]]:\n        \"\"\"\n            Load layout from a JSON file.\n\n        Parameters\n        ----------\n            filename :\n                Input filename.\n\n        Returns\n        -------\n            Dictionary mapping node IDs to (x, y) positions.\n        \"\"\"\n        with open(filename, 'r') as f:\n            layout_data = json.load(f)\n\n        # Convert lists back to tuples\n        return {node: tuple(pos) for node, pos in layout_data.items()}\n</code></pre>"},{"location":"api/visualization/layout/#pypopart.layout.algorithms.LayoutAlgorithm.__init__","title":"__init__","text":"<pre><code>__init__(network: HaplotypeNetwork)\n</code></pre> <p>Initialize layout algorithm with a network.</p> <p>Parameters:</p> Name Type Description Default <code>network</code> <code>HaplotypeNetwork</code> <p>HaplotypeNetwork object.</p> required Source code in <code>src/pypopart/layout/algorithms.py</code> <pre><code>def __init__(self, network: HaplotypeNetwork):\n    \"\"\"\n    Initialize layout algorithm with a network.\n\n    Parameters\n    ----------\n    network :\n        HaplotypeNetwork object.\n    \"\"\"\n    self.network = network\n    self.graph = network._graph\n</code></pre>"},{"location":"api/visualization/layout/#pypopart.layout.algorithms.LayoutAlgorithm.compute","title":"compute","text":"<pre><code>compute(**kwargs) -&gt; Dict[str, Tuple[float, float]]\n</code></pre> <pre><code>Compute node positions.\n</code></pre> <p>Returns:</p> Type Description <code>    Dictionary mapping node IDs to (x, y) positions.</code> Source code in <code>src/pypopart/layout/algorithms.py</code> <pre><code>def compute(self, **kwargs) -&gt; Dict[str, Tuple[float, float]]:\n    \"\"\"\n        Compute node positions.\n\n    Parameters\n    ----------\n        **kwargs :\n            Algorithm-specific parameters.\n\n    Returns\n    -------\n        Dictionary mapping node IDs to (x, y) positions.\n    \"\"\"\n    raise NotImplementedError('Subclasses must implement compute()')\n</code></pre>"},{"location":"api/visualization/layout/#pypopart.layout.algorithms.LayoutAlgorithm.save_layout","title":"save_layout","text":"<pre><code>save_layout(\n    layout: Dict[str, Tuple[float, float]], filename: str\n) -&gt; None\n</code></pre> <p>Save layout to a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>layout</code> <code>Dict[str, Tuple[float, float]]</code> <p>Node positions dictionary.</p> required <code>filename</code> <code>str</code> <p>Output filename.</p> required Source code in <code>src/pypopart/layout/algorithms.py</code> <pre><code>def save_layout(\n    self, layout: Dict[str, Tuple[float, float]], filename: str\n) -&gt; None:\n    \"\"\"\n    Save layout to a JSON file.\n\n    Parameters\n    ----------\n    layout :\n        Node positions dictionary.\n    filename :\n        Output filename.\n    \"\"\"\n    # Convert tuples to lists for JSON serialization\n    layout_serializable = {node: list(pos) for node, pos in layout.items()}\n\n    with open(filename, 'w') as f:\n        json.dump(layout_serializable, f, indent=2)\n</code></pre>"},{"location":"api/visualization/layout/#pypopart.layout.algorithms.LayoutAlgorithm.load_layout","title":"load_layout  <code>staticmethod</code>","text":"<pre><code>load_layout(\n    filename: str,\n) -&gt; Dict[str, Tuple[float, float]]\n</code></pre> <pre><code>Load layout from a JSON file.\n</code></pre> <p>Returns:</p> Type Description <code>    Dictionary mapping node IDs to (x, y) positions.</code> Source code in <code>src/pypopart/layout/algorithms.py</code> <pre><code>@staticmethod\ndef load_layout(filename: str) -&gt; Dict[str, Tuple[float, float]]:\n    \"\"\"\n        Load layout from a JSON file.\n\n    Parameters\n    ----------\n        filename :\n            Input filename.\n\n    Returns\n    -------\n        Dictionary mapping node IDs to (x, y) positions.\n    \"\"\"\n    with open(filename, 'r') as f:\n        layout_data = json.load(f)\n\n    # Convert lists back to tuples\n    return {node: tuple(pos) for node, pos in layout_data.items()}\n</code></pre>"},{"location":"api/visualization/layout/#pypopart.layout.algorithms.ForceDirectedLayout","title":"ForceDirectedLayout","text":"<p>               Bases: <code>LayoutAlgorithm</code></p> <p>Force-directed layout using spring algorithm.</p> <p>Simulates physical spring forces between connected nodes to create aesthetically pleasing layouts. Uses the Fruchterman-Reingold algorithm implemented in NetworkX's spring_layout.</p> Performance <ul> <li>Time complexity: O(iterations * N^2) where N is number of nodes</li> <li>Typical runtime: ~25ms for 100 nodes, 50 iterations</li> <li>Best for: Networks with 10-500 nodes</li> <li>Quality: Good balance between speed and aesthetic quality</li> </ul> Notes <p>For very large networks (&gt;500 nodes), consider using: - HierarchicalLayout (fastest, ~0.1ms for 100 nodes) - CircularLayout (very fast, ~0.2ms for 100 nodes) - SpectralLayout (faster alternative to force-directed)</p> Source code in <code>src/pypopart/layout/algorithms.py</code> <pre><code>class ForceDirectedLayout(LayoutAlgorithm):\n    \"\"\"\n    Force-directed layout using spring algorithm.\n\n    Simulates physical spring forces between connected nodes to create\n    aesthetically pleasing layouts. Uses the Fruchterman-Reingold algorithm\n    implemented in NetworkX's spring_layout.\n\n    Performance\n    -----------\n    - Time complexity: O(iterations * N^2) where N is number of nodes\n    - Typical runtime: ~25ms for 100 nodes, 50 iterations\n    - Best for: Networks with 10-500 nodes\n    - Quality: Good balance between speed and aesthetic quality\n\n    Notes\n    -----\n    For very large networks (&gt;500 nodes), consider using:\n    - HierarchicalLayout (fastest, ~0.1ms for 100 nodes)\n    - CircularLayout (very fast, ~0.2ms for 100 nodes)\n    - SpectralLayout (faster alternative to force-directed)\n    \"\"\"\n\n    def compute(\n        self,\n        k: Optional[float] = None,\n        iterations: int = 50,\n        seed: Optional[int] = None,\n        **kwargs,\n    ) -&gt; Dict[str, Tuple[float, float]]:\n        \"\"\"\n            Compute force-directed layout.\n\n        Parameters\n        ----------\n            k :\n                Optimal distance between nodes (None for auto).\n                Smaller values bring nodes closer together.\n            iterations :\n                Number of iterations for optimization.\n                More iterations = better quality but slower.\n                Default 50 is good for most networks.\n            seed :\n                Random seed for reproducibility.\n            **kwargs :\n                Additional parameters passed to spring_layout.\n\n        Returns\n        -------\n            Node positions dictionary.\n        \"\"\"\n        layout = nx.spring_layout(\n            self.graph, k=k, iterations=iterations, seed=seed, **kwargs\n        )\n        # Convert numpy arrays to tuples\n        return {node: tuple(pos) for node, pos in layout.items()}\n</code></pre>"},{"location":"api/visualization/layout/#pypopart.layout.algorithms.ForceDirectedLayout.compute","title":"compute","text":"<pre><code>compute(\n    k: Optional[float] = None,\n    iterations: int = 50,\n    seed: Optional[int] = None,\n    **kwargs\n) -&gt; Dict[str, Tuple[float, float]]\n</code></pre> <pre><code>Compute force-directed layout.\n</code></pre> <p>Returns:</p> Type Description <code>    Node positions dictionary.</code> Source code in <code>src/pypopart/layout/algorithms.py</code> <pre><code>def compute(\n    self,\n    k: Optional[float] = None,\n    iterations: int = 50,\n    seed: Optional[int] = None,\n    **kwargs,\n) -&gt; Dict[str, Tuple[float, float]]:\n    \"\"\"\n        Compute force-directed layout.\n\n    Parameters\n    ----------\n        k :\n            Optimal distance between nodes (None for auto).\n            Smaller values bring nodes closer together.\n        iterations :\n            Number of iterations for optimization.\n            More iterations = better quality but slower.\n            Default 50 is good for most networks.\n        seed :\n            Random seed for reproducibility.\n        **kwargs :\n            Additional parameters passed to spring_layout.\n\n    Returns\n    -------\n        Node positions dictionary.\n    \"\"\"\n    layout = nx.spring_layout(\n        self.graph, k=k, iterations=iterations, seed=seed, **kwargs\n    )\n    # Convert numpy arrays to tuples\n    return {node: tuple(pos) for node, pos in layout.items()}\n</code></pre>"},{"location":"api/visualization/layout/#pypopart.layout.algorithms.CircularLayout","title":"CircularLayout","text":"<p>               Bases: <code>LayoutAlgorithm</code></p> <p>Circular layout arranging nodes in a circle.</p> <p>Places nodes evenly spaced around a circle, useful for showing connectivity patterns.</p> Source code in <code>src/pypopart/layout/algorithms.py</code> <pre><code>class CircularLayout(LayoutAlgorithm):\n    \"\"\"\n    Circular layout arranging nodes in a circle.\n\n    Places nodes evenly spaced around a circle, useful for showing\n    connectivity patterns.\n    \"\"\"\n\n    def compute(\n        self, scale: float = 1.0, center: Optional[Tuple[float, float]] = None, **kwargs\n    ) -&gt; Dict[str, Tuple[float, float]]:\n        \"\"\"\n            Compute circular layout.\n\n        Parameters\n        ----------\n            scale :\n                Scale factor for the layout.\n            center :\n                Center position (x, y).\n            **kwargs :\n                Additional parameters passed to circular_layout.\n\n        Returns\n        -------\n            Node positions dictionary.\n        \"\"\"\n        layout = nx.circular_layout(self.graph, scale=scale, center=center, **kwargs)\n        # Convert numpy arrays to tuples\n        return {node: tuple(pos) for node, pos in layout.items()}\n</code></pre>"},{"location":"api/visualization/layout/#pypopart.layout.algorithms.CircularLayout.compute","title":"compute","text":"<pre><code>compute(\n    scale: float = 1.0,\n    center: Optional[Tuple[float, float]] = None,\n    **kwargs\n) -&gt; Dict[str, Tuple[float, float]]\n</code></pre> <pre><code>Compute circular layout.\n</code></pre> <p>Returns:</p> Type Description <code>    Node positions dictionary.</code> Source code in <code>src/pypopart/layout/algorithms.py</code> <pre><code>def compute(\n    self, scale: float = 1.0, center: Optional[Tuple[float, float]] = None, **kwargs\n) -&gt; Dict[str, Tuple[float, float]]:\n    \"\"\"\n        Compute circular layout.\n\n    Parameters\n    ----------\n        scale :\n            Scale factor for the layout.\n        center :\n            Center position (x, y).\n        **kwargs :\n            Additional parameters passed to circular_layout.\n\n    Returns\n    -------\n        Node positions dictionary.\n    \"\"\"\n    layout = nx.circular_layout(self.graph, scale=scale, center=center, **kwargs)\n    # Convert numpy arrays to tuples\n    return {node: tuple(pos) for node, pos in layout.items()}\n</code></pre>"},{"location":"api/visualization/layout/#pypopart.layout.algorithms.RadialLayout","title":"RadialLayout","text":"<p>               Bases: <code>LayoutAlgorithm</code></p> <p>Radial layout with center node and concentric rings.</p> <p>Places a central node at the origin and arranges other nodes in concentric circles based on distance from center.</p> Source code in <code>src/pypopart/layout/algorithms.py</code> <pre><code>class RadialLayout(LayoutAlgorithm):\n    \"\"\"\n    Radial layout with center node and concentric rings.\n\n    Places a central node at the origin and arranges other nodes\n    in concentric circles based on distance from center.\n    \"\"\"\n\n    def compute(\n        self, center_node: Optional[str] = None, scale: float = 1.0, **kwargs\n    ) -&gt; Dict[str, Tuple[float, float]]:\n        \"\"\"\n            Compute radial layout.\n\n        Parameters\n        ----------\n            center_node :\n                Node to place at center (most connected if None).\n            scale :\n                Scale factor for the layout.\n            **kwargs :\n                Additional parameters.\n\n        Returns\n        -------\n            Node positions dictionary.\n        \"\"\"\n        if not self.graph.nodes():\n            return {}\n\n        # Find center node if not specified\n        if center_node is None:\n            # Use node with highest degree\n            center_node = max(self.graph.nodes(), key=lambda n: self.graph.degree(n))\n\n        # Calculate distances from center using shortest path\n        try:\n            distances = nx.single_source_shortest_path_length(self.graph, center_node)\n            # Add disconnected nodes at max distance + 1\n            max_dist = max(distances.values()) if distances else 0\n            for node in self.graph.nodes():\n                if node not in distances:\n                    distances[node] = max_dist + 1\n        except nx.NetworkXError:\n            # If graph is disconnected, use all nodes at max distance\n            distances = dict.fromkeys(self.graph.nodes(), 1)\n            distances[center_node] = 0\n\n        # Group nodes by distance\n        max_distance = max(distances.values()) if distances else 0\n        rings: Dict[int, List[str]] = {i: [] for i in range(max_distance + 1)}\n\n        for node, dist in distances.items():\n            rings[dist].append(node)\n\n        # Position nodes\n        positions = {}\n        positions[center_node] = (0.0, 0.0)\n\n        for ring_idx, nodes in rings.items():\n            if ring_idx == 0:\n                continue\n\n            radius = scale * ring_idx\n            n_nodes = len(nodes)\n\n            for i, node in enumerate(nodes):\n                angle = 2 * np.pi * i / n_nodes\n                x = radius * np.cos(angle)\n                y = radius * np.sin(angle)\n                positions[node] = (x, y)\n\n        return positions\n</code></pre>"},{"location":"api/visualization/layout/#pypopart.layout.algorithms.RadialLayout.compute","title":"compute","text":"<pre><code>compute(\n    center_node: Optional[str] = None,\n    scale: float = 1.0,\n    **kwargs\n) -&gt; Dict[str, Tuple[float, float]]\n</code></pre> <pre><code>Compute radial layout.\n</code></pre> <p>Returns:</p> Type Description <code>    Node positions dictionary.</code> Source code in <code>src/pypopart/layout/algorithms.py</code> <pre><code>def compute(\n    self, center_node: Optional[str] = None, scale: float = 1.0, **kwargs\n) -&gt; Dict[str, Tuple[float, float]]:\n    \"\"\"\n        Compute radial layout.\n\n    Parameters\n    ----------\n        center_node :\n            Node to place at center (most connected if None).\n        scale :\n            Scale factor for the layout.\n        **kwargs :\n            Additional parameters.\n\n    Returns\n    -------\n        Node positions dictionary.\n    \"\"\"\n    if not self.graph.nodes():\n        return {}\n\n    # Find center node if not specified\n    if center_node is None:\n        # Use node with highest degree\n        center_node = max(self.graph.nodes(), key=lambda n: self.graph.degree(n))\n\n    # Calculate distances from center using shortest path\n    try:\n        distances = nx.single_source_shortest_path_length(self.graph, center_node)\n        # Add disconnected nodes at max distance + 1\n        max_dist = max(distances.values()) if distances else 0\n        for node in self.graph.nodes():\n            if node not in distances:\n                distances[node] = max_dist + 1\n    except nx.NetworkXError:\n        # If graph is disconnected, use all nodes at max distance\n        distances = dict.fromkeys(self.graph.nodes(), 1)\n        distances[center_node] = 0\n\n    # Group nodes by distance\n    max_distance = max(distances.values()) if distances else 0\n    rings: Dict[int, List[str]] = {i: [] for i in range(max_distance + 1)}\n\n    for node, dist in distances.items():\n        rings[dist].append(node)\n\n    # Position nodes\n    positions = {}\n    positions[center_node] = (0.0, 0.0)\n\n    for ring_idx, nodes in rings.items():\n        if ring_idx == 0:\n            continue\n\n        radius = scale * ring_idx\n        n_nodes = len(nodes)\n\n        for i, node in enumerate(nodes):\n            angle = 2 * np.pi * i / n_nodes\n            x = radius * np.cos(angle)\n            y = radius * np.sin(angle)\n            positions[node] = (x, y)\n\n    return positions\n</code></pre>"},{"location":"api/visualization/layout/#pypopart.layout.algorithms.HierarchicalLayout","title":"HierarchicalLayout","text":"<p>               Bases: <code>LayoutAlgorithm</code></p> <p>Hierarchical layout arranging nodes in levels.</p> <p>Creates a tree-like structure with nodes arranged in horizontal levels based on distance from a root node.</p> Source code in <code>src/pypopart/layout/algorithms.py</code> <pre><code>class HierarchicalLayout(LayoutAlgorithm):\n    \"\"\"\n    Hierarchical layout arranging nodes in levels.\n\n    Creates a tree-like structure with nodes arranged in horizontal\n    levels based on distance from a root node.\n    \"\"\"\n\n    def compute(\n        self,\n        root_node: Optional[str] = None,\n        vertical: bool = True,\n        width: float = 2.0,\n        height: float = 2.0,\n        **kwargs,\n    ) -&gt; Dict[str, Tuple[float, float]]:\n        \"\"\"\n            Compute hierarchical layout.\n\n        Parameters\n        ----------\n            root_node :\n                Root node for hierarchy (most connected if None).\n            vertical :\n                If True, levels are horizontal; if False, levels are vertical.\n            width :\n                Total width of the layout.\n            height :\n                Total height of the layout.\n            **kwargs :\n                Additional parameters.\n\n        Returns\n        -------\n            Node positions dictionary.\n        \"\"\"\n        if not self.graph.nodes():\n            return {}\n\n        # Find root node if not specified\n        if root_node is None:\n            root_node = max(self.graph.nodes(), key=lambda n: self.graph.degree(n))\n\n        # Calculate distances from root using BFS\n        try:\n            distances = nx.single_source_shortest_path_length(self.graph, root_node)\n            # Add disconnected nodes at max level + 1\n            max_dist = max(distances.values()) if distances else 0\n            for node in self.graph.nodes():\n                if node not in distances:\n                    distances[node] = max_dist + 1\n        except nx.NetworkXError:\n            # If graph is disconnected, use default distances\n            distances = dict.fromkeys(self.graph.nodes(), 1)\n            distances[root_node] = 0\n\n        # Group nodes by level\n        max_level = max(distances.values()) if distances else 0\n        levels: Dict[int, List[str]] = {i: [] for i in range(max_level + 1)}\n\n        for node, level in distances.items():\n            levels[level].append(node)\n\n        # Position nodes\n        positions = {}\n\n        for level_idx, nodes in levels.items():\n            n_nodes = len(nodes)\n\n            if vertical:\n                # Horizontal levels (top to bottom)\n                y = height * (1 - level_idx / max(max_level, 1))\n\n                for i, node in enumerate(nodes):\n                    if n_nodes == 1:\n                        x = width / 2\n                    else:\n                        x = width * i / (n_nodes - 1)\n                    positions[node] = (x, y)\n            else:\n                # Vertical levels (left to right)\n                x = width * level_idx / max(max_level, 1)\n\n                for i, node in enumerate(nodes):\n                    if n_nodes == 1:\n                        y = height / 2\n                    else:\n                        y = height * (1 - i / (n_nodes - 1))\n                    positions[node] = (x, y)\n\n        return positions\n</code></pre>"},{"location":"api/visualization/layout/#pypopart.layout.algorithms.HierarchicalLayout.compute","title":"compute","text":"<pre><code>compute(\n    root_node: Optional[str] = None,\n    vertical: bool = True,\n    width: float = 2.0,\n    height: float = 2.0,\n    **kwargs\n) -&gt; Dict[str, Tuple[float, float]]\n</code></pre> <pre><code>Compute hierarchical layout.\n</code></pre> <p>Returns:</p> Type Description <code>    Node positions dictionary.</code> Source code in <code>src/pypopart/layout/algorithms.py</code> <pre><code>def compute(\n    self,\n    root_node: Optional[str] = None,\n    vertical: bool = True,\n    width: float = 2.0,\n    height: float = 2.0,\n    **kwargs,\n) -&gt; Dict[str, Tuple[float, float]]:\n    \"\"\"\n        Compute hierarchical layout.\n\n    Parameters\n    ----------\n        root_node :\n            Root node for hierarchy (most connected if None).\n        vertical :\n            If True, levels are horizontal; if False, levels are vertical.\n        width :\n            Total width of the layout.\n        height :\n            Total height of the layout.\n        **kwargs :\n            Additional parameters.\n\n    Returns\n    -------\n        Node positions dictionary.\n    \"\"\"\n    if not self.graph.nodes():\n        return {}\n\n    # Find root node if not specified\n    if root_node is None:\n        root_node = max(self.graph.nodes(), key=lambda n: self.graph.degree(n))\n\n    # Calculate distances from root using BFS\n    try:\n        distances = nx.single_source_shortest_path_length(self.graph, root_node)\n        # Add disconnected nodes at max level + 1\n        max_dist = max(distances.values()) if distances else 0\n        for node in self.graph.nodes():\n            if node not in distances:\n                distances[node] = max_dist + 1\n    except nx.NetworkXError:\n        # If graph is disconnected, use default distances\n        distances = dict.fromkeys(self.graph.nodes(), 1)\n        distances[root_node] = 0\n\n    # Group nodes by level\n    max_level = max(distances.values()) if distances else 0\n    levels: Dict[int, List[str]] = {i: [] for i in range(max_level + 1)}\n\n    for node, level in distances.items():\n        levels[level].append(node)\n\n    # Position nodes\n    positions = {}\n\n    for level_idx, nodes in levels.items():\n        n_nodes = len(nodes)\n\n        if vertical:\n            # Horizontal levels (top to bottom)\n            y = height * (1 - level_idx / max(max_level, 1))\n\n            for i, node in enumerate(nodes):\n                if n_nodes == 1:\n                    x = width / 2\n                else:\n                    x = width * i / (n_nodes - 1)\n                positions[node] = (x, y)\n        else:\n            # Vertical levels (left to right)\n            x = width * level_idx / max(max_level, 1)\n\n            for i, node in enumerate(nodes):\n                if n_nodes == 1:\n                    y = height / 2\n                else:\n                    y = height * (1 - i / (n_nodes - 1))\n                positions[node] = (x, y)\n\n    return positions\n</code></pre>"},{"location":"api/visualization/layout/#pypopart.layout.algorithms.KamadaKawaiLayout","title":"KamadaKawaiLayout","text":"<p>               Bases: <code>LayoutAlgorithm</code></p> <p>Kamada-Kawai layout algorithm.</p> <p>Uses energy minimization to position nodes based on graph-theoretic distances. Produces high-quality layouts but is computationally expensive for large networks.</p> Performance <ul> <li>Time complexity: O(N^3) where N is number of nodes</li> <li>Typical runtime: ~190ms for 100 nodes</li> <li>Best for: Small networks (&lt;50 nodes) where layout quality is critical</li> <li>Quality: Excellent, minimizes stress based on graph distances</li> </ul> Notes <p>For large networks, use ForceDirectedLayout or SpectralLayout instead. Kamada-Kawai can be very slow for networks with &gt;100 nodes.</p> Source code in <code>src/pypopart/layout/algorithms.py</code> <pre><code>class KamadaKawaiLayout(LayoutAlgorithm):\n    \"\"\"\n    Kamada-Kawai layout algorithm.\n\n    Uses energy minimization to position nodes based on graph-theoretic\n    distances. Produces high-quality layouts but is computationally expensive\n    for large networks.\n\n    Performance\n    -----------\n    - Time complexity: O(N^3) where N is number of nodes\n    - Typical runtime: ~190ms for 100 nodes\n    - Best for: Small networks (&lt;50 nodes) where layout quality is critical\n    - Quality: Excellent, minimizes stress based on graph distances\n\n    Notes\n    -----\n    For large networks, use ForceDirectedLayout or SpectralLayout instead.\n    Kamada-Kawai can be very slow for networks with &gt;100 nodes.\n    \"\"\"\n\n    def compute(\n        self, scale: float = 1.0, center: Optional[Tuple[float, float]] = None, **kwargs\n    ) -&gt; Dict[str, Tuple[float, float]]:\n        \"\"\"\n            Compute Kamada-Kawai layout.\n\n        Parameters\n        ----------\n            scale :\n                Scale factor for the layout.\n            center :\n                Center position (x, y).\n            **kwargs :\n                Additional parameters passed to kamada_kawai_layout.\n\n        Returns\n        -------\n            Node positions dictionary.\n\n        Warnings\n        --------\n        This algorithm can be very slow for large networks (&gt;100 nodes).\n        Consider using ForceDirectedLayout or SpectralLayout as faster alternatives.\n        \"\"\"\n        layout = nx.kamada_kawai_layout(\n            self.graph, scale=scale, center=center, **kwargs\n        )\n        # Convert numpy arrays to tuples\n        return {node: tuple(pos) for node, pos in layout.items()}\n</code></pre>"},{"location":"api/visualization/layout/#pypopart.layout.algorithms.KamadaKawaiLayout.compute","title":"compute","text":"<pre><code>compute(\n    scale: float = 1.0,\n    center: Optional[Tuple[float, float]] = None,\n    **kwargs\n) -&gt; Dict[str, Tuple[float, float]]\n</code></pre> <pre><code>Compute Kamada-Kawai layout.\n</code></pre> <p>Returns:</p> Type Description <code>    Node positions dictionary.</code> Warnings <p>This algorithm can be very slow for large networks (&gt;100 nodes). Consider using ForceDirectedLayout or SpectralLayout as faster alternatives.</p> Source code in <code>src/pypopart/layout/algorithms.py</code> <pre><code>def compute(\n    self, scale: float = 1.0, center: Optional[Tuple[float, float]] = None, **kwargs\n) -&gt; Dict[str, Tuple[float, float]]:\n    \"\"\"\n        Compute Kamada-Kawai layout.\n\n    Parameters\n    ----------\n        scale :\n            Scale factor for the layout.\n        center :\n            Center position (x, y).\n        **kwargs :\n            Additional parameters passed to kamada_kawai_layout.\n\n    Returns\n    -------\n        Node positions dictionary.\n\n    Warnings\n    --------\n    This algorithm can be very slow for large networks (&gt;100 nodes).\n    Consider using ForceDirectedLayout or SpectralLayout as faster alternatives.\n    \"\"\"\n    layout = nx.kamada_kawai_layout(\n        self.graph, scale=scale, center=center, **kwargs\n    )\n    # Convert numpy arrays to tuples\n    return {node: tuple(pos) for node, pos in layout.items()}\n</code></pre>"},{"location":"api/visualization/layout/#pypopart.layout.algorithms.SpectralLayout","title":"SpectralLayout","text":"<p>               Bases: <code>LayoutAlgorithm</code></p> <p>Spectral layout using graph Laplacian eigenvectors.</p> <p>Uses the eigenvectors of the graph Laplacian matrix to position nodes. This is a fast alternative to force-directed layouts that works well for large networks.</p> Performance <ul> <li>Time complexity: O(N^2) where N is number of nodes</li> <li>Typical runtime: ~5-10ms for 100 nodes</li> <li>Best for: Large networks (100-1000+ nodes)</li> <li>Quality: Good, respects graph structure efficiently</li> </ul> Notes <p>Spectral layout is much faster than Kamada-Kawai and comparable to force-directed layouts while maintaining good quality. Particularly effective for networks with clear clustering structure.</p> Source code in <code>src/pypopart/layout/algorithms.py</code> <pre><code>class SpectralLayout(LayoutAlgorithm):\n    \"\"\"\n    Spectral layout using graph Laplacian eigenvectors.\n\n    Uses the eigenvectors of the graph Laplacian matrix to position nodes.\n    This is a fast alternative to force-directed layouts that works well\n    for large networks.\n\n    Performance\n    -----------\n    - Time complexity: O(N^2) where N is number of nodes\n    - Typical runtime: ~5-10ms for 100 nodes\n    - Best for: Large networks (100-1000+ nodes)\n    - Quality: Good, respects graph structure efficiently\n\n    Notes\n    -----\n    Spectral layout is much faster than Kamada-Kawai and comparable\n    to force-directed layouts while maintaining good quality.\n    Particularly effective for networks with clear clustering structure.\n    \"\"\"\n\n    def compute(\n        self,\n        scale: float = 1.0,\n        center: Optional[Tuple[float, float]] = None,\n        dim: int = 2,\n        **kwargs,\n    ) -&gt; Dict[str, Tuple[float, float]]:\n        \"\"\"\n        Compute spectral layout using graph Laplacian.\n\n        Parameters\n        ----------\n        scale :\n            Scale factor for the layout.\n        center :\n            Center position (x, y).\n        dim :\n            Dimensionality of layout (default 2 for 2D visualization).\n        **kwargs :\n            Additional parameters passed to spectral_layout.\n\n        Returns\n        -------\n        Node positions dictionary.\n        \"\"\"\n        layout = nx.spectral_layout(\n            self.graph, scale=scale, center=center, dim=dim, **kwargs\n        )\n        # Convert numpy arrays to tuples\n        return {node: tuple(pos) for node, pos in layout.items()}\n</code></pre>"},{"location":"api/visualization/layout/#pypopart.layout.algorithms.SpectralLayout.compute","title":"compute","text":"<pre><code>compute(\n    scale: float = 1.0,\n    center: Optional[Tuple[float, float]] = None,\n    dim: int = 2,\n    **kwargs\n) -&gt; Dict[str, Tuple[float, float]]\n</code></pre> <p>Compute spectral layout using graph Laplacian.</p> <p>Parameters:</p> Name Type Description Default <code>scale</code> <code>float</code> <p>Scale factor for the layout.</p> <code>1.0</code> <code>center</code> <code>Optional[Tuple[float, float]]</code> <p>Center position (x, y).</p> <code>None</code> <code>dim</code> <code>int</code> <p>Dimensionality of layout (default 2 for 2D visualization).</p> <code>2</code> <code>**kwargs</code> <p>Additional parameters passed to spectral_layout.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Node positions dictionary.</code> Source code in <code>src/pypopart/layout/algorithms.py</code> <pre><code>def compute(\n    self,\n    scale: float = 1.0,\n    center: Optional[Tuple[float, float]] = None,\n    dim: int = 2,\n    **kwargs,\n) -&gt; Dict[str, Tuple[float, float]]:\n    \"\"\"\n    Compute spectral layout using graph Laplacian.\n\n    Parameters\n    ----------\n    scale :\n        Scale factor for the layout.\n    center :\n        Center position (x, y).\n    dim :\n        Dimensionality of layout (default 2 for 2D visualization).\n    **kwargs :\n        Additional parameters passed to spectral_layout.\n\n    Returns\n    -------\n    Node positions dictionary.\n    \"\"\"\n    layout = nx.spectral_layout(\n        self.graph, scale=scale, center=center, dim=dim, **kwargs\n    )\n    # Convert numpy arrays to tuples\n    return {node: tuple(pos) for node, pos in layout.items()}\n</code></pre>"},{"location":"api/visualization/layout/#pypopart.layout.algorithms.ManualLayout","title":"ManualLayout","text":"<p>               Bases: <code>LayoutAlgorithm</code></p> <p>Manual layout with user-specified positions.</p> <p>Allows manual positioning of nodes or adjustment of existing layouts.</p> Source code in <code>src/pypopart/layout/algorithms.py</code> <pre><code>class ManualLayout(LayoutAlgorithm):\n    \"\"\"\n    Manual layout with user-specified positions.\n\n    Allows manual positioning of nodes or adjustment of existing layouts.\n    \"\"\"\n\n    def __init__(\n        self,\n        network: HaplotypeNetwork,\n        initial_positions: Optional[Dict[str, Tuple[float, float]]] = None,\n    ):\n        \"\"\"\n        Initialize manual layout.\n\n        Parameters\n        ----------\n        network :\n            HaplotypeNetwork object.\n        initial_positions :\n            Starting positions for nodes.\n        \"\"\"\n        super().__init__(network)\n        self.positions = initial_positions or {}\n\n    def compute(self, **kwargs) -&gt; Dict[str, Tuple[float, float]]:\n        \"\"\"\n            Return current manual positions.\n\n        Parameters\n        ----------\n            **kwargs :\n                Ignored.\n\n        Returns\n        -------\n            Node positions dictionary.\n        \"\"\"\n        # Fill in missing nodes with default layout\n        if len(self.positions) &lt; len(self.graph.nodes()):\n            default_layout = nx.spring_layout(self.graph)\n            for node in self.graph.nodes():\n                if node not in self.positions:\n                    self.positions[node] = default_layout[node]\n\n        return self.positions\n\n    def set_position(self, node: str, position: Tuple[float, float]) -&gt; None:\n        \"\"\"\n        Set position for a specific node.\n\n        Parameters\n        ----------\n        node :\n            Node ID.\n        position :\n            (x, y) coordinates.\n        \"\"\"\n        if node not in self.graph.nodes():\n            raise ValueError(f\"Node '{node}' not in network\")\n\n        self.positions[node] = position\n\n    def move_node(self, node: str, dx: float, dy: float) -&gt; None:\n        \"\"\"\n        Move a node by a relative offset.\n\n        Parameters\n        ----------\n        node :\n            Node ID.\n        dx :\n            X offset.\n        dy :\n            Y offset.\n        \"\"\"\n        if node not in self.positions:\n            raise ValueError(f\"Node '{node}' has no position set\")\n\n        x, y = self.positions[node]\n        self.positions[node] = (x + dx, y + dy)\n</code></pre>"},{"location":"api/visualization/layout/#pypopart.layout.algorithms.ManualLayout.__init__","title":"__init__","text":"<pre><code>__init__(\n    network: HaplotypeNetwork,\n    initial_positions: Optional[\n        Dict[str, Tuple[float, float]]\n    ] = None,\n)\n</code></pre> <p>Initialize manual layout.</p> <p>Parameters:</p> Name Type Description Default <code>network</code> <code>HaplotypeNetwork</code> <p>HaplotypeNetwork object.</p> required <code>initial_positions</code> <code>Optional[Dict[str, Tuple[float, float]]]</code> <p>Starting positions for nodes.</p> <code>None</code> Source code in <code>src/pypopart/layout/algorithms.py</code> <pre><code>def __init__(\n    self,\n    network: HaplotypeNetwork,\n    initial_positions: Optional[Dict[str, Tuple[float, float]]] = None,\n):\n    \"\"\"\n    Initialize manual layout.\n\n    Parameters\n    ----------\n    network :\n        HaplotypeNetwork object.\n    initial_positions :\n        Starting positions for nodes.\n    \"\"\"\n    super().__init__(network)\n    self.positions = initial_positions or {}\n</code></pre>"},{"location":"api/visualization/layout/#pypopart.layout.algorithms.ManualLayout.compute","title":"compute","text":"<pre><code>compute(**kwargs) -&gt; Dict[str, Tuple[float, float]]\n</code></pre> <pre><code>Return current manual positions.\n</code></pre> <p>Returns:</p> Type Description <code>    Node positions dictionary.</code> Source code in <code>src/pypopart/layout/algorithms.py</code> <pre><code>def compute(self, **kwargs) -&gt; Dict[str, Tuple[float, float]]:\n    \"\"\"\n        Return current manual positions.\n\n    Parameters\n    ----------\n        **kwargs :\n            Ignored.\n\n    Returns\n    -------\n        Node positions dictionary.\n    \"\"\"\n    # Fill in missing nodes with default layout\n    if len(self.positions) &lt; len(self.graph.nodes()):\n        default_layout = nx.spring_layout(self.graph)\n        for node in self.graph.nodes():\n            if node not in self.positions:\n                self.positions[node] = default_layout[node]\n\n    return self.positions\n</code></pre>"},{"location":"api/visualization/layout/#pypopart.layout.algorithms.ManualLayout.set_position","title":"set_position","text":"<pre><code>set_position(\n    node: str, position: Tuple[float, float]\n) -&gt; None\n</code></pre> <p>Set position for a specific node.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>str</code> <p>Node ID.</p> required <code>position</code> <code>Tuple[float, float]</code> <p>(x, y) coordinates.</p> required Source code in <code>src/pypopart/layout/algorithms.py</code> <pre><code>def set_position(self, node: str, position: Tuple[float, float]) -&gt; None:\n    \"\"\"\n    Set position for a specific node.\n\n    Parameters\n    ----------\n    node :\n        Node ID.\n    position :\n        (x, y) coordinates.\n    \"\"\"\n    if node not in self.graph.nodes():\n        raise ValueError(f\"Node '{node}' not in network\")\n\n    self.positions[node] = position\n</code></pre>"},{"location":"api/visualization/layout/#pypopart.layout.algorithms.ManualLayout.move_node","title":"move_node","text":"<pre><code>move_node(node: str, dx: float, dy: float) -&gt; None\n</code></pre> <p>Move a node by a relative offset.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>str</code> <p>Node ID.</p> required <code>dx</code> <code>float</code> <p>X offset.</p> required <code>dy</code> <code>float</code> <p>Y offset.</p> required Source code in <code>src/pypopart/layout/algorithms.py</code> <pre><code>def move_node(self, node: str, dx: float, dy: float) -&gt; None:\n    \"\"\"\n    Move a node by a relative offset.\n\n    Parameters\n    ----------\n    node :\n        Node ID.\n    dx :\n        X offset.\n    dy :\n        Y offset.\n    \"\"\"\n    if node not in self.positions:\n        raise ValueError(f\"Node '{node}' has no position set\")\n\n    x, y = self.positions[node]\n    self.positions[node] = (x + dx, y + dy)\n</code></pre>"},{"location":"api/visualization/layout/#pypopart.layout.algorithms.LayoutManager","title":"LayoutManager","text":"<p>Manager for network layout computation and persistence.</p> <p>Provides high-level interface for computing, saving, and loading network layouts with optional caching.</p> <p>Parameters:</p> Name Type Description Default <code>network</code> <code>HaplotypeNetwork</code> <p>The haplotype network to compute layouts for.</p> required <code>enable_cache</code> <code>bool</code> <p>If True, cache layout results for repeated calls with same parameters. Default is True. Disable if network structure changes between calls.</p> <code>True</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; manager = LayoutManager(network)\n&gt;&gt;&gt; layout = manager.compute_layout('spring', iterations=50, seed=42)\n&gt;&gt;&gt; # Second call with same parameters uses cached result\n&gt;&gt;&gt; layout2 = manager.compute_layout('spring', iterations=50, seed=42)\n</code></pre> Source code in <code>src/pypopart/layout/algorithms.py</code> <pre><code>class LayoutManager:\n    \"\"\"\n    Manager for network layout computation and persistence.\n\n    Provides high-level interface for computing, saving, and loading\n    network layouts with optional caching.\n\n    Parameters\n    ----------\n    network : HaplotypeNetwork\n        The haplotype network to compute layouts for.\n    enable_cache : bool, optional\n        If True, cache layout results for repeated calls with same parameters.\n        Default is True. Disable if network structure changes between calls.\n\n    Examples\n    --------\n    &gt;&gt;&gt; manager = LayoutManager(network)\n    &gt;&gt;&gt; layout = manager.compute_layout('spring', iterations=50, seed=42)\n    &gt;&gt;&gt; # Second call with same parameters uses cached result\n    &gt;&gt;&gt; layout2 = manager.compute_layout('spring', iterations=50, seed=42)\n    \"\"\"\n\n    def __init__(self, network: HaplotypeNetwork, enable_cache: bool = True):\n        \"\"\"\n        Initialize layout manager.\n\n        Parameters\n        ----------\n        network :\n            HaplotypeNetwork object.\n        enable_cache :\n            Enable caching of layout computations. Default True.\n        \"\"\"\n        self.network = network\n        self._enable_cache = enable_cache\n        self._cache: Dict[str, Dict[str, Tuple[float, float]]] = {}\n        self._algorithms = {\n            'force_directed': ForceDirectedLayout,\n            'spring': ForceDirectedLayout,  # Alias\n            'circular': CircularLayout,\n            'radial': RadialLayout,\n            'hierarchical': HierarchicalLayout,\n            'kamada_kawai': KamadaKawaiLayout,\n            'spectral': SpectralLayout,\n            'manual': ManualLayout,\n        }\n\n    def compute_layout(\n        self, algorithm: str = 'force_directed', use_cache: bool = True, **kwargs\n    ) -&gt; Dict[str, Tuple[float, float]]:\n        \"\"\"\n        Compute network layout using specified algorithm.\n\n        Parameters\n        ----------\n        algorithm :\n            Layout algorithm name.\n        use_cache :\n            If True and caching is enabled, return cached result if available.\n            Default True.\n        **kwargs :\n            Algorithm-specific parameters.\n\n        Returns\n        -------\n        Node positions dictionary.\n\n        Raises\n        ------\n        ValueError :\n            If algorithm not recognized.\n\n        Notes\n        -----\n        Results are cached based on algorithm name and parameters. To force\n        recomputation, set use_cache=False or clear_cache().\n        \"\"\"\n        if algorithm not in self._algorithms:\n            available = ', '.join(self._algorithms.keys())\n            raise ValueError(f\"Unknown algorithm '{algorithm}'. Available: {available}\")\n\n        # Check cache if enabled\n        if self._enable_cache and use_cache:\n            cache_key = self._make_cache_key(algorithm, kwargs)\n            if cache_key in self._cache:\n                return self._cache[cache_key]\n\n        # Compute layout\n        layout_class = self._algorithms[algorithm]\n        layout_algo = layout_class(self.network)\n        result = layout_algo.compute(**kwargs)\n\n        # Store in cache if enabled\n        if self._enable_cache:\n            cache_key = self._make_cache_key(algorithm, kwargs)\n            self._cache[cache_key] = result\n\n        return result\n\n    def _make_cache_key(self, algorithm: str, kwargs: Dict) -&gt; str:\n        \"\"\"\n        Create a cache key from algorithm name and parameters.\n\n        Parameters\n        ----------\n        algorithm : str\n            Algorithm name.\n        kwargs : dict\n            Algorithm parameters.\n\n        Returns\n        -------\n        str\n            Cache key string.\n        \"\"\"\n        import json\n\n        # Sort kwargs for consistent keys\n        sorted_kwargs = json.dumps(kwargs, sort_keys=True, default=str)\n        return f'{algorithm}:{sorted_kwargs}'\n\n    def clear_cache(self) -&gt; None:\n        \"\"\"\n        Clear the layout cache.\n\n        Use this after the network structure has changed to ensure\n        fresh layout computations.\n        \"\"\"\n        self._cache.clear()\n\n    def save_layout(\n        self, layout: Dict[str, Tuple[float, float]], filename: str\n    ) -&gt; None:\n        \"\"\"\n        Save layout to file.\n\n        Parameters\n        ----------\n        layout :\n            Node positions dictionary.\n        filename :\n            Output filename (JSON format).\n        \"\"\"\n        algo = LayoutAlgorithm(self.network)\n        algo.save_layout(layout, filename)\n\n    def load_layout(self, filename: str) -&gt; Dict[str, Tuple[float, float]]:\n        \"\"\"\n            Load layout from file.\n\n        Parameters\n        ----------\n            filename :\n                Input filename (JSON format).\n\n        Returns\n        -------\n            Node positions dictionary.\n        \"\"\"\n        return LayoutAlgorithm.load_layout(filename)\n\n    def get_available_algorithms(self) -&gt; List[str]:\n        \"\"\"\n        Get list of available layout algorithms.\n\n        Returns\n        -------\n            List of algorithm names.\n        \"\"\"\n        return list(self._algorithms.keys())\n</code></pre>"},{"location":"api/visualization/layout/#pypopart.layout.algorithms.LayoutManager.__init__","title":"__init__","text":"<pre><code>__init__(\n    network: HaplotypeNetwork, enable_cache: bool = True\n)\n</code></pre> <p>Initialize layout manager.</p> <p>Parameters:</p> Name Type Description Default <code>network</code> <code>HaplotypeNetwork</code> <p>HaplotypeNetwork object.</p> required <code>enable_cache</code> <code>bool</code> <p>Enable caching of layout computations. Default True.</p> <code>True</code> Source code in <code>src/pypopart/layout/algorithms.py</code> <pre><code>def __init__(self, network: HaplotypeNetwork, enable_cache: bool = True):\n    \"\"\"\n    Initialize layout manager.\n\n    Parameters\n    ----------\n    network :\n        HaplotypeNetwork object.\n    enable_cache :\n        Enable caching of layout computations. Default True.\n    \"\"\"\n    self.network = network\n    self._enable_cache = enable_cache\n    self._cache: Dict[str, Dict[str, Tuple[float, float]]] = {}\n    self._algorithms = {\n        'force_directed': ForceDirectedLayout,\n        'spring': ForceDirectedLayout,  # Alias\n        'circular': CircularLayout,\n        'radial': RadialLayout,\n        'hierarchical': HierarchicalLayout,\n        'kamada_kawai': KamadaKawaiLayout,\n        'spectral': SpectralLayout,\n        'manual': ManualLayout,\n    }\n</code></pre>"},{"location":"api/visualization/layout/#pypopart.layout.algorithms.LayoutManager.compute_layout","title":"compute_layout","text":"<pre><code>compute_layout(\n    algorithm: str = \"force_directed\",\n    use_cache: bool = True,\n    **kwargs\n) -&gt; Dict[str, Tuple[float, float]]\n</code></pre> <p>Compute network layout using specified algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>algorithm</code> <code>str</code> <p>Layout algorithm name.</p> <code>'force_directed'</code> <code>use_cache</code> <code>bool</code> <p>If True and caching is enabled, return cached result if available. Default True.</p> <code>True</code> <code>**kwargs</code> <p>Algorithm-specific parameters.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Node positions dictionary.</code> <p>Raises:</p> Type Description <code>ValueError :</code> <p>If algorithm not recognized.</p> Notes <p>Results are cached based on algorithm name and parameters. To force recomputation, set use_cache=False or clear_cache().</p> Source code in <code>src/pypopart/layout/algorithms.py</code> <pre><code>def compute_layout(\n    self, algorithm: str = 'force_directed', use_cache: bool = True, **kwargs\n) -&gt; Dict[str, Tuple[float, float]]:\n    \"\"\"\n    Compute network layout using specified algorithm.\n\n    Parameters\n    ----------\n    algorithm :\n        Layout algorithm name.\n    use_cache :\n        If True and caching is enabled, return cached result if available.\n        Default True.\n    **kwargs :\n        Algorithm-specific parameters.\n\n    Returns\n    -------\n    Node positions dictionary.\n\n    Raises\n    ------\n    ValueError :\n        If algorithm not recognized.\n\n    Notes\n    -----\n    Results are cached based on algorithm name and parameters. To force\n    recomputation, set use_cache=False or clear_cache().\n    \"\"\"\n    if algorithm not in self._algorithms:\n        available = ', '.join(self._algorithms.keys())\n        raise ValueError(f\"Unknown algorithm '{algorithm}'. Available: {available}\")\n\n    # Check cache if enabled\n    if self._enable_cache and use_cache:\n        cache_key = self._make_cache_key(algorithm, kwargs)\n        if cache_key in self._cache:\n            return self._cache[cache_key]\n\n    # Compute layout\n    layout_class = self._algorithms[algorithm]\n    layout_algo = layout_class(self.network)\n    result = layout_algo.compute(**kwargs)\n\n    # Store in cache if enabled\n    if self._enable_cache:\n        cache_key = self._make_cache_key(algorithm, kwargs)\n        self._cache[cache_key] = result\n\n    return result\n</code></pre>"},{"location":"api/visualization/layout/#pypopart.layout.algorithms.LayoutManager.clear_cache","title":"clear_cache","text":"<pre><code>clear_cache() -&gt; None\n</code></pre> <p>Clear the layout cache.</p> <p>Use this after the network structure has changed to ensure fresh layout computations.</p> Source code in <code>src/pypopart/layout/algorithms.py</code> <pre><code>def clear_cache(self) -&gt; None:\n    \"\"\"\n    Clear the layout cache.\n\n    Use this after the network structure has changed to ensure\n    fresh layout computations.\n    \"\"\"\n    self._cache.clear()\n</code></pre>"},{"location":"api/visualization/layout/#pypopart.layout.algorithms.LayoutManager.save_layout","title":"save_layout","text":"<pre><code>save_layout(\n    layout: Dict[str, Tuple[float, float]], filename: str\n) -&gt; None\n</code></pre> <p>Save layout to file.</p> <p>Parameters:</p> Name Type Description Default <code>layout</code> <code>Dict[str, Tuple[float, float]]</code> <p>Node positions dictionary.</p> required <code>filename</code> <code>str</code> <p>Output filename (JSON format).</p> required Source code in <code>src/pypopart/layout/algorithms.py</code> <pre><code>def save_layout(\n    self, layout: Dict[str, Tuple[float, float]], filename: str\n) -&gt; None:\n    \"\"\"\n    Save layout to file.\n\n    Parameters\n    ----------\n    layout :\n        Node positions dictionary.\n    filename :\n        Output filename (JSON format).\n    \"\"\"\n    algo = LayoutAlgorithm(self.network)\n    algo.save_layout(layout, filename)\n</code></pre>"},{"location":"api/visualization/layout/#pypopart.layout.algorithms.LayoutManager.load_layout","title":"load_layout","text":"<pre><code>load_layout(\n    filename: str,\n) -&gt; Dict[str, Tuple[float, float]]\n</code></pre> <pre><code>Load layout from file.\n</code></pre> <p>Returns:</p> Type Description <code>    Node positions dictionary.</code> Source code in <code>src/pypopart/layout/algorithms.py</code> <pre><code>def load_layout(self, filename: str) -&gt; Dict[str, Tuple[float, float]]:\n    \"\"\"\n        Load layout from file.\n\n    Parameters\n    ----------\n        filename :\n            Input filename (JSON format).\n\n    Returns\n    -------\n        Node positions dictionary.\n    \"\"\"\n    return LayoutAlgorithm.load_layout(filename)\n</code></pre>"},{"location":"api/visualization/layout/#pypopart.layout.algorithms.LayoutManager.get_available_algorithms","title":"get_available_algorithms","text":"<pre><code>get_available_algorithms() -&gt; List[str]\n</code></pre> <p>Get list of available layout algorithms.</p> <p>Returns:</p> Type Description <code>    List of algorithm names.</code> Source code in <code>src/pypopart/layout/algorithms.py</code> <pre><code>def get_available_algorithms(self) -&gt; List[str]:\n    \"\"\"\n    Get list of available layout algorithms.\n\n    Returns\n    -------\n        List of algorithm names.\n    \"\"\"\n    return list(self._algorithms.keys())\n</code></pre>"},{"location":"api/visualization/static/","title":"Static Visualization","text":"<p>Publication-quality static network plots.</p>"},{"location":"api/visualization/static/#overview","title":"Overview","text":"<p>The <code>static_plot</code> module provides matplotlib-based plotting for creating high-quality figures.</p> <p>Features: - PNG, PDF, SVG export - Customizable layouts - Node/edge styling - Color schemes - Publication-ready output</p>"},{"location":"api/visualization/static/#modules","title":"Modules","text":""},{"location":"api/visualization/static/#pypopart.visualization.static_plot","title":"pypopart.visualization.static_plot","text":"<p>Static network visualization using matplotlib for PyPopART.</p> <p>Provides matplotlib-based plotting functions for haplotype networks with customizable node sizes, colors, edge styles, and layouts.</p>"},{"location":"api/visualization/static/#pypopart.visualization.static_plot.StaticNetworkPlotter","title":"StaticNetworkPlotter","text":"<p>Static network plotter using matplotlib.</p> <p>Generates publication-quality static plots of haplotype networks with customizable styling for nodes, edges, labels, and legends.</p> Source code in <code>src/pypopart/visualization/static_plot.py</code> <pre><code>class StaticNetworkPlotter:\n    \"\"\"\n    Static network plotter using matplotlib.\n\n    Generates publication-quality static plots of haplotype networks\n    with customizable styling for nodes, edges, labels, and legends.\n    \"\"\"\n\n    def __init__(self, network: HaplotypeNetwork):\n        \"\"\"\n        Initialize plotter with a haplotype network.\n\n        Parameters\n        ----------\n        network :\n            HaplotypeNetwork object to visualize.\n        \"\"\"\n        self.network = network\n        self.figure = None\n        self.ax = None\n\n    def plot(\n        self,\n        layout: Optional[Dict[str, Tuple[float, float]]] = None,\n        layout_algorithm: str = 'spring',\n        node_size_scale: float = 300.0,\n        node_color_map: Optional[Dict[str, str]] = None,\n        population_colors: Optional[Dict[str, str]] = None,\n        edge_width_scale: float = 1.0,\n        show_labels: bool = True,\n        show_mutations: bool = True,\n        median_vector_color: str = 'lightgray',\n        median_vector_marker: str = 's',\n        figsize: Tuple[float, float] = (12, 10),\n        title: Optional[str] = None,\n        **kwargs,\n    ) -&gt; Tuple[plt.Figure, plt.Axes]:\n        \"\"\"\n            Create a static network plot.\n\n        Parameters\n        ----------\n            layout :\n                Pre-computed node positions {node_id: (x, y)}.\n            layout_algorithm :\n                NetworkX layout algorithm ('spring', 'circular', 'kamada_kawai').\n            node_size_scale :\n                Scaling factor for node sizes.\n            node_color_map :\n                Custom color mapping {node_id: color}.\n            population_colors :\n                Color mapping for populations {pop_name: color}.\n            edge_width_scale :\n                Scaling factor for edge widths.\n            show_labels :\n                Whether to show node labels.\n            show_mutations :\n                Whether to show mutation counts on edges.\n            median_vector_color :\n                Color for median vector nodes.\n            median_vector_marker :\n                Marker shape for median vectors ('s'=square, 'o'=circle).\n            figsize :\n                Figure size (width, height) in inches.\n            title :\n                Plot title.\n            **kwargs :\n                Additional arguments passed to networkx drawing functions.\n\n        Returns\n        -------\n            Figure and axes objects.\n        \"\"\"\n        # Create figure and axes\n        self.figure, self.ax = plt.subplots(figsize=figsize)\n\n        # Get graph and compute layout if not provided\n        graph = self.network._graph\n        if layout is None:\n            layout = self._compute_layout(graph, layout_algorithm)\n\n        # Prepare node attributes\n        node_sizes = self._compute_node_sizes(node_size_scale)\n        node_colors = self._compute_node_colors(\n            node_color_map, population_colors, median_vector_color\n        )\n\n        # Prepare edge attributes\n        edge_widths = self._compute_edge_widths(edge_width_scale)\n\n        # Separate haplotypes and median vectors\n        haplotype_nodes = [\n            n for n in graph.nodes() if not self.network.is_median_vector(n)\n        ]\n        median_nodes = self.network.median_vector_ids\n\n        # Draw haplotype nodes\n        if haplotype_nodes:\n            hap_sizes = [node_sizes[n] for n in haplotype_nodes]\n            hap_colors = [node_colors[n] for n in haplotype_nodes]\n            nx.draw_networkx_nodes(\n                graph,\n                layout,\n                nodelist=haplotype_nodes,\n                node_size=hap_sizes,\n                node_color=hap_colors,\n                node_shape='o',\n                edgecolors='black',\n                linewidths=1.5,\n                ax=self.ax,\n                **{k: v for k, v in kwargs.items() if k.startswith('node_')},\n            )\n\n        # Draw median vector nodes\n        if median_nodes:\n            med_sizes = [node_sizes[n] for n in median_nodes]\n            med_colors = [node_colors[n] for n in median_nodes]\n            nx.draw_networkx_nodes(\n                graph,\n                layout,\n                nodelist=median_nodes,\n                node_size=med_sizes,\n                node_color=med_colors,\n                node_shape=median_vector_marker,\n                edgecolors='black',\n                linewidths=1.5,\n                ax=self.ax,\n                **{k: v for k, v in kwargs.items() if k.startswith('node_')},\n            )\n\n        # Draw edges\n        nx.draw_networkx_edges(\n            graph,\n            layout,\n            width=edge_widths,\n            edge_color='gray',\n            alpha=0.6,\n            ax=self.ax,\n            **{k: v for k, v in kwargs.items() if k.startswith('edge_')},\n        )\n\n        # Draw labels if requested\n        if show_labels:\n            labels = {n: n for n in graph.nodes()}\n            nx.draw_networkx_labels(\n                graph,\n                layout,\n                labels=labels,\n                font_size=8,\n                font_weight='bold',\n                ax=self.ax,\n            )\n\n        # Draw mutation counts on edges if requested\n        if show_mutations:\n            self._draw_edge_labels(graph, layout)\n\n        # Add title\n        if title:\n            self.ax.set_title(title, fontsize=14, fontweight='bold', pad=20)\n        elif self.network.name:\n            self.ax.set_title(self.network.name, fontsize=14, fontweight='bold', pad=20)\n\n        # Remove axes\n        self.ax.axis('off')\n\n        # Tight layout\n        plt.tight_layout()\n\n        return self.figure, self.ax\n\n    def add_legend(\n        self,\n        population_colors: Optional[Dict[str, str]] = None,\n        show_median_vectors: bool = True,\n        show_size_scale: bool = True,\n        loc: str = 'best',\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"\n        Add a legend to the plot.\n\n        Parameters\n        ----------\n        population_colors :\n            Population color mapping {pop_name: color}.\n        show_median_vectors :\n            Whether to include median vectors in legend.\n        show_size_scale :\n            Whether to show node size scale.\n        loc :\n            Legend location.\n        **kwargs :\n            Additional arguments passed to plt.legend().\n        \"\"\"\n        if self.ax is None:\n            raise ValueError('No plot exists. Call plot() first.')\n\n        legend_elements = []\n\n        # Add population colors\n        if population_colors:\n            for pop_name, color in sorted(population_colors.items()):\n                legend_elements.append(mpatches.Patch(color=color, label=pop_name))\n\n        # Add median vectors\n        if show_median_vectors and len(self.network.median_vector_ids) &gt; 0:\n            legend_elements.append(\n                Line2D(\n                    [0],\n                    [0],\n                    marker='s',\n                    color='w',\n                    markerfacecolor='lightgray',\n                    markersize=10,\n                    markeredgecolor='black',\n                    markeredgewidth=1.5,\n                    label='Median Vector',\n                    linestyle='None',\n                )\n            )\n\n        # Add size scale examples if requested\n        if show_size_scale:\n            # Find range of frequencies\n            frequencies = []\n            for node in self.network._graph.nodes():\n                if not self.network.is_median_vector(node):\n                    hap = self.network.get_haplotype(node)\n                    if hap:\n                        frequencies.append(hap.frequency)\n\n            if frequencies:\n                min_freq = min(frequencies)\n                max_freq = max(frequencies)\n\n                # Add size legend for min and max\n                if min_freq != max_freq:\n                    legend_elements.append(\n                        Line2D(\n                            [0],\n                            [0],\n                            marker='o',\n                            color='w',\n                            markerfacecolor='gray',\n                            markersize=5,\n                            markeredgecolor='black',\n                            markeredgewidth=1,\n                            label=f'n={min_freq}',\n                            linestyle='None',\n                        )\n                    )\n                    legend_elements.append(\n                        Line2D(\n                            [0],\n                            [0],\n                            marker='o',\n                            color='w',\n                            markerfacecolor='gray',\n                            markersize=12,\n                            markeredgecolor='black',\n                            markeredgewidth=1,\n                            label=f'n={max_freq}',\n                            linestyle='None',\n                        )\n                    )\n\n        if legend_elements:\n            self.ax.legend(\n                handles=legend_elements,\n                loc=loc,\n                frameon=True,\n                fancybox=True,\n                shadow=True,\n                **kwargs,\n            )\n\n    def add_scale_bar(\n        self,\n        num_mutations: int = 1,\n        position: Tuple[float, float] = (0.05, 0.05),\n        length: float = 0.1,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"\n        Add a scale bar showing mutation distance.\n\n        Parameters\n        ----------\n        num_mutations :\n            Number of mutations represented by scale bar.\n        position :\n            Position as fraction of axes (x, y).\n        length :\n            Length of scale bar as fraction of axes width.\n        **kwargs :\n            Additional arguments for the line and text.\n        \"\"\"\n        if self.ax is None:\n            raise ValueError('No plot exists. Call plot() first.')\n\n        # Get axes limits\n        xlim = self.ax.get_xlim()\n        ylim = self.ax.get_ylim()\n\n        # Calculate absolute position and length\n        x_start = xlim[0] + (xlim[1] - xlim[0]) * position[0]\n        y_pos = ylim[0] + (ylim[1] - ylim[0]) * position[1]\n        bar_length = (xlim[1] - xlim[0]) * length\n\n        # Draw scale bar\n        self.ax.plot(\n            [x_start, x_start + bar_length],\n            [y_pos, y_pos],\n            'k-',\n            linewidth=2,\n            solid_capstyle='butt',\n        )\n\n        # Add text label\n        label = f'{num_mutations} mutation{\"s\" if num_mutations != 1 else \"\"}'\n        self.ax.text(\n            x_start + bar_length / 2,\n            y_pos - (ylim[1] - ylim[0]) * 0.02,\n            label,\n            ha='center',\n            va='top',\n            fontsize=10,\n            fontweight='bold',\n        )\n\n    def add_statistics_annotation(\n        self,\n        stats: Optional[Dict[str, Any]] = None,\n        position: Tuple[float, float] = (0.02, 0.98),\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"\n        Add network statistics as text annotation.\n\n        Parameters\n        ----------\n        stats :\n            Dictionary of statistics to display.\n        position :\n            Position as fraction of axes (x, y).\n        **kwargs :\n            Additional arguments for the text box.\n        \"\"\"\n        if self.ax is None:\n            raise ValueError('No plot exists. Call plot() first.')\n\n        if stats is None:\n            # Get basic network stats\n            net_stats = self.network.calculate_stats()\n            stats = {\n                'Haplotypes': net_stats.num_haplotypes,\n                'Samples': net_stats.total_samples,\n                'Median Vectors': net_stats.num_median_vectors,\n                'Edges': net_stats.num_edges,\n            }\n\n        # Format statistics text\n        text_lines = []\n        for key, value in stats.items():\n            if isinstance(value, float):\n                text_lines.append(f'{key}: {value:.2f}')\n            else:\n                text_lines.append(f'{key}: {value}')\n        text = '\\n'.join(text_lines)\n\n        # Add text box\n        props = {\n            'boxstyle': 'round',\n            'facecolor': 'white',\n            'alpha': 0.8,\n            'edgecolor': 'black',\n        }\n        props.update(kwargs.get('bbox', {}))\n\n        self.ax.text(\n            position[0],\n            position[1],\n            text,\n            transform=self.ax.transAxes,\n            fontsize=10,\n            verticalalignment='top',\n            bbox=props,\n        )\n\n    def save(\n        self, filename: str, dpi: int = 300, bbox_inches: str = 'tight', **kwargs\n    ) -&gt; None:\n        \"\"\"\n        Save the plot to a file.\n\n        Parameters\n        ----------\n        filename :\n            Output filename (extension determines format: .png, .pdf, .svg).\n        dpi :\n            Resolution in dots per inch.\n        bbox_inches :\n            Bounding box setting.\n        **kwargs :\n            Additional arguments passed to plt.savefig().\n        \"\"\"\n        if self.figure is None:\n            raise ValueError('No plot exists. Call plot() first.')\n\n        self.figure.savefig(filename, dpi=dpi, bbox_inches=bbox_inches, **kwargs)\n\n    def _compute_layout(\n        self, graph: nx.Graph, algorithm: str\n    ) -&gt; Dict[str, Tuple[float, float]]:\n        \"\"\"\n            Compute node layout using specified algorithm.\n\n        Parameters\n        ----------\n            graph :\n                NetworkX graph.\n            algorithm :\n                Layout algorithm name.\n\n        Returns\n        -------\n            Dictionary mapping node IDs to (x, y) positions.\n        \"\"\"\n        if algorithm == 'spring':\n            return nx.spring_layout(graph, k=1, iterations=50)\n        elif algorithm == 'circular':\n            return nx.circular_layout(graph)\n        elif algorithm == 'kamada_kawai':\n            return nx.kamada_kawai_layout(graph)\n        elif algorithm == 'spectral':\n            return nx.spectral_layout(graph)\n        elif algorithm == 'shell':\n            return nx.shell_layout(graph)\n        else:\n            raise ValueError(f'Unknown layout algorithm: {algorithm}')\n\n    def _compute_node_sizes(self, scale: float) -&gt; Dict[str, float]:\n        \"\"\"\n            Compute node sizes based on haplotype frequencies.\n\n        Parameters\n        ----------\n            scale :\n                Scaling factor for node sizes.\n\n        Returns\n        -------\n            Dictionary mapping node IDs to sizes.\n        \"\"\"\n        sizes = {}\n        for node in self.network._graph.nodes():\n            if self.network.is_median_vector(node):\n                # Median vectors get a fixed small size\n                sizes[node] = scale * 0.3\n            else:\n                hap = self.network.get_haplotype(node)\n                if hap:\n                    # Size proportional to square root of frequency for better visual scaling\n                    sizes[node] = scale * np.sqrt(hap.frequency)\n                else:\n                    sizes[node] = scale * 0.5\n\n        return sizes\n\n    def _compute_node_colors(\n        self,\n        node_color_map: Optional[Dict[str, str]],\n        population_colors: Optional[Dict[str, str]],\n        median_vector_color: str,\n    ) -&gt; Dict[str, str]:\n        \"\"\"\n            Compute node colors based on population or custom mapping.\n\n        Parameters\n        ----------\n            node_color_map :\n                Custom node color mapping.\n            population_colors :\n                Population color mapping.\n            median_vector_color :\n                Color for median vectors.\n\n        Returns\n        -------\n            Dictionary mapping node IDs to colors.\n        \"\"\"\n        colors = {}\n\n        for node in self.network._graph.nodes():\n            if self.network.is_median_vector(node):\n                colors[node] = median_vector_color\n            elif node_color_map and node in node_color_map:\n                colors[node] = node_color_map[node]\n            elif population_colors:\n                # Color by dominant population\n                hap = self.network.get_haplotype(node)\n                if hap:\n                    pop_counts = hap.get_frequency_by_population()\n                    if pop_counts:\n                        # Find population with highest count\n                        dominant_pop = max(pop_counts.items(), key=lambda x: x[1])[0]\n                        colors[node] = population_colors.get(dominant_pop, 'lightblue')\n                    else:\n                        colors[node] = 'lightblue'\n                else:\n                    colors[node] = 'lightblue'\n            else:\n                colors[node] = 'lightblue'\n\n        return colors\n\n    def _compute_edge_widths(self, scale: float) -&gt; List[float]:\n        \"\"\"\n            Compute edge widths based on mutation distances.\n\n        Parameters\n        ----------\n            scale :\n                Scaling factor for edge widths.\n\n        Returns\n        -------\n            List of edge widths.\n        \"\"\"\n        widths = []\n        graph = self.network._graph\n\n        for u, v in graph.edges():\n            # Get edge weight (distance/mutations)\n            weight = graph[u][v].get('weight', 1)\n            # Inverse relationship: fewer mutations = thicker line\n            width = scale * max(0.5, 3.0 / max(weight, 1))\n            widths.append(width)\n\n        return widths\n\n    def _draw_edge_labels(\n        self, graph: nx.Graph, layout: Dict[str, Tuple[float, float]]\n    ) -&gt; None:\n        \"\"\"\n        Draw mutation counts on edges.\n\n        Parameters\n        ----------\n        graph :\n            NetworkX graph.\n        layout :\n            Node positions.\n        \"\"\"\n        edge_labels = {}\n        for u, v in graph.edges():\n            weight = graph[u][v].get('weight', 1)\n            if weight &gt; 0:\n                edge_labels[(u, v)] = int(weight)\n\n        if edge_labels:\n            nx.draw_networkx_edge_labels(\n                graph,\n                layout,\n                edge_labels=edge_labels,\n                font_size=7,\n                bbox={\n                    'boxstyle': 'round',\n                    'facecolor': 'white',\n                    'alpha': 0.7,\n                    'edgecolor': 'none',\n                },\n                ax=self.ax,\n            )\n</code></pre>"},{"location":"api/visualization/static/#pypopart.visualization.static_plot.StaticNetworkPlotter.__init__","title":"__init__","text":"<pre><code>__init__(network: HaplotypeNetwork)\n</code></pre> <p>Initialize plotter with a haplotype network.</p> <p>Parameters:</p> Name Type Description Default <code>network</code> <code>HaplotypeNetwork</code> <p>HaplotypeNetwork object to visualize.</p> required Source code in <code>src/pypopart/visualization/static_plot.py</code> <pre><code>def __init__(self, network: HaplotypeNetwork):\n    \"\"\"\n    Initialize plotter with a haplotype network.\n\n    Parameters\n    ----------\n    network :\n        HaplotypeNetwork object to visualize.\n    \"\"\"\n    self.network = network\n    self.figure = None\n    self.ax = None\n</code></pre>"},{"location":"api/visualization/static/#pypopart.visualization.static_plot.StaticNetworkPlotter.plot","title":"plot","text":"<pre><code>plot(\n    layout: Optional[Dict[str, Tuple[float, float]]] = None,\n    layout_algorithm: str = \"spring\",\n    node_size_scale: float = 300.0,\n    node_color_map: Optional[Dict[str, str]] = None,\n    population_colors: Optional[Dict[str, str]] = None,\n    edge_width_scale: float = 1.0,\n    show_labels: bool = True,\n    show_mutations: bool = True,\n    median_vector_color: str = \"lightgray\",\n    median_vector_marker: str = \"s\",\n    figsize: Tuple[float, float] = (12, 10),\n    title: Optional[str] = None,\n    **kwargs\n) -&gt; Tuple[plt.Figure, plt.Axes]\n</code></pre> <pre><code>Create a static network plot.\n</code></pre> <p>Returns:</p> Type Description <code>    Figure and axes objects.</code> Source code in <code>src/pypopart/visualization/static_plot.py</code> <pre><code>def plot(\n    self,\n    layout: Optional[Dict[str, Tuple[float, float]]] = None,\n    layout_algorithm: str = 'spring',\n    node_size_scale: float = 300.0,\n    node_color_map: Optional[Dict[str, str]] = None,\n    population_colors: Optional[Dict[str, str]] = None,\n    edge_width_scale: float = 1.0,\n    show_labels: bool = True,\n    show_mutations: bool = True,\n    median_vector_color: str = 'lightgray',\n    median_vector_marker: str = 's',\n    figsize: Tuple[float, float] = (12, 10),\n    title: Optional[str] = None,\n    **kwargs,\n) -&gt; Tuple[plt.Figure, plt.Axes]:\n    \"\"\"\n        Create a static network plot.\n\n    Parameters\n    ----------\n        layout :\n            Pre-computed node positions {node_id: (x, y)}.\n        layout_algorithm :\n            NetworkX layout algorithm ('spring', 'circular', 'kamada_kawai').\n        node_size_scale :\n            Scaling factor for node sizes.\n        node_color_map :\n            Custom color mapping {node_id: color}.\n        population_colors :\n            Color mapping for populations {pop_name: color}.\n        edge_width_scale :\n            Scaling factor for edge widths.\n        show_labels :\n            Whether to show node labels.\n        show_mutations :\n            Whether to show mutation counts on edges.\n        median_vector_color :\n            Color for median vector nodes.\n        median_vector_marker :\n            Marker shape for median vectors ('s'=square, 'o'=circle).\n        figsize :\n            Figure size (width, height) in inches.\n        title :\n            Plot title.\n        **kwargs :\n            Additional arguments passed to networkx drawing functions.\n\n    Returns\n    -------\n        Figure and axes objects.\n    \"\"\"\n    # Create figure and axes\n    self.figure, self.ax = plt.subplots(figsize=figsize)\n\n    # Get graph and compute layout if not provided\n    graph = self.network._graph\n    if layout is None:\n        layout = self._compute_layout(graph, layout_algorithm)\n\n    # Prepare node attributes\n    node_sizes = self._compute_node_sizes(node_size_scale)\n    node_colors = self._compute_node_colors(\n        node_color_map, population_colors, median_vector_color\n    )\n\n    # Prepare edge attributes\n    edge_widths = self._compute_edge_widths(edge_width_scale)\n\n    # Separate haplotypes and median vectors\n    haplotype_nodes = [\n        n for n in graph.nodes() if not self.network.is_median_vector(n)\n    ]\n    median_nodes = self.network.median_vector_ids\n\n    # Draw haplotype nodes\n    if haplotype_nodes:\n        hap_sizes = [node_sizes[n] for n in haplotype_nodes]\n        hap_colors = [node_colors[n] for n in haplotype_nodes]\n        nx.draw_networkx_nodes(\n            graph,\n            layout,\n            nodelist=haplotype_nodes,\n            node_size=hap_sizes,\n            node_color=hap_colors,\n            node_shape='o',\n            edgecolors='black',\n            linewidths=1.5,\n            ax=self.ax,\n            **{k: v for k, v in kwargs.items() if k.startswith('node_')},\n        )\n\n    # Draw median vector nodes\n    if median_nodes:\n        med_sizes = [node_sizes[n] for n in median_nodes]\n        med_colors = [node_colors[n] for n in median_nodes]\n        nx.draw_networkx_nodes(\n            graph,\n            layout,\n            nodelist=median_nodes,\n            node_size=med_sizes,\n            node_color=med_colors,\n            node_shape=median_vector_marker,\n            edgecolors='black',\n            linewidths=1.5,\n            ax=self.ax,\n            **{k: v for k, v in kwargs.items() if k.startswith('node_')},\n        )\n\n    # Draw edges\n    nx.draw_networkx_edges(\n        graph,\n        layout,\n        width=edge_widths,\n        edge_color='gray',\n        alpha=0.6,\n        ax=self.ax,\n        **{k: v for k, v in kwargs.items() if k.startswith('edge_')},\n    )\n\n    # Draw labels if requested\n    if show_labels:\n        labels = {n: n for n in graph.nodes()}\n        nx.draw_networkx_labels(\n            graph,\n            layout,\n            labels=labels,\n            font_size=8,\n            font_weight='bold',\n            ax=self.ax,\n        )\n\n    # Draw mutation counts on edges if requested\n    if show_mutations:\n        self._draw_edge_labels(graph, layout)\n\n    # Add title\n    if title:\n        self.ax.set_title(title, fontsize=14, fontweight='bold', pad=20)\n    elif self.network.name:\n        self.ax.set_title(self.network.name, fontsize=14, fontweight='bold', pad=20)\n\n    # Remove axes\n    self.ax.axis('off')\n\n    # Tight layout\n    plt.tight_layout()\n\n    return self.figure, self.ax\n</code></pre>"},{"location":"api/visualization/static/#pypopart.visualization.static_plot.StaticNetworkPlotter.add_legend","title":"add_legend","text":"<pre><code>add_legend(\n    population_colors: Optional[Dict[str, str]] = None,\n    show_median_vectors: bool = True,\n    show_size_scale: bool = True,\n    loc: str = \"best\",\n    **kwargs\n) -&gt; None\n</code></pre> <p>Add a legend to the plot.</p> <p>Parameters:</p> Name Type Description Default <code>population_colors</code> <code>Optional[Dict[str, str]]</code> <p>Population color mapping {pop_name: color}.</p> <code>None</code> <code>show_median_vectors</code> <code>bool</code> <p>Whether to include median vectors in legend.</p> <code>True</code> <code>show_size_scale</code> <code>bool</code> <p>Whether to show node size scale.</p> <code>True</code> <code>loc</code> <code>str</code> <p>Legend location.</p> <code>'best'</code> <code>**kwargs</code> <p>Additional arguments passed to plt.legend().</p> <code>{}</code> Source code in <code>src/pypopart/visualization/static_plot.py</code> <pre><code>def add_legend(\n    self,\n    population_colors: Optional[Dict[str, str]] = None,\n    show_median_vectors: bool = True,\n    show_size_scale: bool = True,\n    loc: str = 'best',\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Add a legend to the plot.\n\n    Parameters\n    ----------\n    population_colors :\n        Population color mapping {pop_name: color}.\n    show_median_vectors :\n        Whether to include median vectors in legend.\n    show_size_scale :\n        Whether to show node size scale.\n    loc :\n        Legend location.\n    **kwargs :\n        Additional arguments passed to plt.legend().\n    \"\"\"\n    if self.ax is None:\n        raise ValueError('No plot exists. Call plot() first.')\n\n    legend_elements = []\n\n    # Add population colors\n    if population_colors:\n        for pop_name, color in sorted(population_colors.items()):\n            legend_elements.append(mpatches.Patch(color=color, label=pop_name))\n\n    # Add median vectors\n    if show_median_vectors and len(self.network.median_vector_ids) &gt; 0:\n        legend_elements.append(\n            Line2D(\n                [0],\n                [0],\n                marker='s',\n                color='w',\n                markerfacecolor='lightgray',\n                markersize=10,\n                markeredgecolor='black',\n                markeredgewidth=1.5,\n                label='Median Vector',\n                linestyle='None',\n            )\n        )\n\n    # Add size scale examples if requested\n    if show_size_scale:\n        # Find range of frequencies\n        frequencies = []\n        for node in self.network._graph.nodes():\n            if not self.network.is_median_vector(node):\n                hap = self.network.get_haplotype(node)\n                if hap:\n                    frequencies.append(hap.frequency)\n\n        if frequencies:\n            min_freq = min(frequencies)\n            max_freq = max(frequencies)\n\n            # Add size legend for min and max\n            if min_freq != max_freq:\n                legend_elements.append(\n                    Line2D(\n                        [0],\n                        [0],\n                        marker='o',\n                        color='w',\n                        markerfacecolor='gray',\n                        markersize=5,\n                        markeredgecolor='black',\n                        markeredgewidth=1,\n                        label=f'n={min_freq}',\n                        linestyle='None',\n                    )\n                )\n                legend_elements.append(\n                    Line2D(\n                        [0],\n                        [0],\n                        marker='o',\n                        color='w',\n                        markerfacecolor='gray',\n                        markersize=12,\n                        markeredgecolor='black',\n                        markeredgewidth=1,\n                        label=f'n={max_freq}',\n                        linestyle='None',\n                    )\n                )\n\n    if legend_elements:\n        self.ax.legend(\n            handles=legend_elements,\n            loc=loc,\n            frameon=True,\n            fancybox=True,\n            shadow=True,\n            **kwargs,\n        )\n</code></pre>"},{"location":"api/visualization/static/#pypopart.visualization.static_plot.StaticNetworkPlotter.add_scale_bar","title":"add_scale_bar","text":"<pre><code>add_scale_bar(\n    num_mutations: int = 1,\n    position: Tuple[float, float] = (0.05, 0.05),\n    length: float = 0.1,\n    **kwargs\n) -&gt; None\n</code></pre> <p>Add a scale bar showing mutation distance.</p> <p>Parameters:</p> Name Type Description Default <code>num_mutations</code> <code>int</code> <p>Number of mutations represented by scale bar.</p> <code>1</code> <code>position</code> <code>Tuple[float, float]</code> <p>Position as fraction of axes (x, y).</p> <code>(0.05, 0.05)</code> <code>length</code> <code>float</code> <p>Length of scale bar as fraction of axes width.</p> <code>0.1</code> <code>**kwargs</code> <p>Additional arguments for the line and text.</p> <code>{}</code> Source code in <code>src/pypopart/visualization/static_plot.py</code> <pre><code>def add_scale_bar(\n    self,\n    num_mutations: int = 1,\n    position: Tuple[float, float] = (0.05, 0.05),\n    length: float = 0.1,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Add a scale bar showing mutation distance.\n\n    Parameters\n    ----------\n    num_mutations :\n        Number of mutations represented by scale bar.\n    position :\n        Position as fraction of axes (x, y).\n    length :\n        Length of scale bar as fraction of axes width.\n    **kwargs :\n        Additional arguments for the line and text.\n    \"\"\"\n    if self.ax is None:\n        raise ValueError('No plot exists. Call plot() first.')\n\n    # Get axes limits\n    xlim = self.ax.get_xlim()\n    ylim = self.ax.get_ylim()\n\n    # Calculate absolute position and length\n    x_start = xlim[0] + (xlim[1] - xlim[0]) * position[0]\n    y_pos = ylim[0] + (ylim[1] - ylim[0]) * position[1]\n    bar_length = (xlim[1] - xlim[0]) * length\n\n    # Draw scale bar\n    self.ax.plot(\n        [x_start, x_start + bar_length],\n        [y_pos, y_pos],\n        'k-',\n        linewidth=2,\n        solid_capstyle='butt',\n    )\n\n    # Add text label\n    label = f'{num_mutations} mutation{\"s\" if num_mutations != 1 else \"\"}'\n    self.ax.text(\n        x_start + bar_length / 2,\n        y_pos - (ylim[1] - ylim[0]) * 0.02,\n        label,\n        ha='center',\n        va='top',\n        fontsize=10,\n        fontweight='bold',\n    )\n</code></pre>"},{"location":"api/visualization/static/#pypopart.visualization.static_plot.StaticNetworkPlotter.add_statistics_annotation","title":"add_statistics_annotation","text":"<pre><code>add_statistics_annotation(\n    stats: Optional[Dict[str, Any]] = None,\n    position: Tuple[float, float] = (0.02, 0.98),\n    **kwargs\n) -&gt; None\n</code></pre> <p>Add network statistics as text annotation.</p> <p>Parameters:</p> Name Type Description Default <code>stats</code> <code>Optional[Dict[str, Any]]</code> <p>Dictionary of statistics to display.</p> <code>None</code> <code>position</code> <code>Tuple[float, float]</code> <p>Position as fraction of axes (x, y).</p> <code>(0.02, 0.98)</code> <code>**kwargs</code> <p>Additional arguments for the text box.</p> <code>{}</code> Source code in <code>src/pypopart/visualization/static_plot.py</code> <pre><code>def add_statistics_annotation(\n    self,\n    stats: Optional[Dict[str, Any]] = None,\n    position: Tuple[float, float] = (0.02, 0.98),\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Add network statistics as text annotation.\n\n    Parameters\n    ----------\n    stats :\n        Dictionary of statistics to display.\n    position :\n        Position as fraction of axes (x, y).\n    **kwargs :\n        Additional arguments for the text box.\n    \"\"\"\n    if self.ax is None:\n        raise ValueError('No plot exists. Call plot() first.')\n\n    if stats is None:\n        # Get basic network stats\n        net_stats = self.network.calculate_stats()\n        stats = {\n            'Haplotypes': net_stats.num_haplotypes,\n            'Samples': net_stats.total_samples,\n            'Median Vectors': net_stats.num_median_vectors,\n            'Edges': net_stats.num_edges,\n        }\n\n    # Format statistics text\n    text_lines = []\n    for key, value in stats.items():\n        if isinstance(value, float):\n            text_lines.append(f'{key}: {value:.2f}')\n        else:\n            text_lines.append(f'{key}: {value}')\n    text = '\\n'.join(text_lines)\n\n    # Add text box\n    props = {\n        'boxstyle': 'round',\n        'facecolor': 'white',\n        'alpha': 0.8,\n        'edgecolor': 'black',\n    }\n    props.update(kwargs.get('bbox', {}))\n\n    self.ax.text(\n        position[0],\n        position[1],\n        text,\n        transform=self.ax.transAxes,\n        fontsize=10,\n        verticalalignment='top',\n        bbox=props,\n    )\n</code></pre>"},{"location":"api/visualization/static/#pypopart.visualization.static_plot.StaticNetworkPlotter.save","title":"save","text":"<pre><code>save(\n    filename: str,\n    dpi: int = 300,\n    bbox_inches: str = \"tight\",\n    **kwargs\n) -&gt; None\n</code></pre> <p>Save the plot to a file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Output filename (extension determines format: .png, .pdf, .svg).</p> required <code>dpi</code> <code>int</code> <p>Resolution in dots per inch.</p> <code>300</code> <code>bbox_inches</code> <code>str</code> <p>Bounding box setting.</p> <code>'tight'</code> <code>**kwargs</code> <p>Additional arguments passed to plt.savefig().</p> <code>{}</code> Source code in <code>src/pypopart/visualization/static_plot.py</code> <pre><code>def save(\n    self, filename: str, dpi: int = 300, bbox_inches: str = 'tight', **kwargs\n) -&gt; None:\n    \"\"\"\n    Save the plot to a file.\n\n    Parameters\n    ----------\n    filename :\n        Output filename (extension determines format: .png, .pdf, .svg).\n    dpi :\n        Resolution in dots per inch.\n    bbox_inches :\n        Bounding box setting.\n    **kwargs :\n        Additional arguments passed to plt.savefig().\n    \"\"\"\n    if self.figure is None:\n        raise ValueError('No plot exists. Call plot() first.')\n\n    self.figure.savefig(filename, dpi=dpi, bbox_inches=bbox_inches, **kwargs)\n</code></pre>"},{"location":"api/visualization/static/#pypopart.visualization.static_plot.plot_network","title":"plot_network","text":"<pre><code>plot_network(\n    network: HaplotypeNetwork, **kwargs\n) -&gt; Tuple[plt.Figure, plt.Axes]\n</code></pre> <p>Plot a haplotype network.</p> <p>Args:     network: HaplotypeNetwork object to visualize     **kwargs: Arguments passed to StaticNetworkPlotter.plot()</p> <p>Returns:</p> Name Type Description <code>    Figure and axes objects.</code> <code>Example</code> <code>Axes</code> <p>from pypopart.core.graph import HaplotypeNetwork from pypopart.visualization.static_plot import plot_network network = HaplotypeNetwork()</p> Source code in <code>src/pypopart/visualization/static_plot.py</code> <pre><code>def plot_network(network: HaplotypeNetwork, **kwargs) -&gt; Tuple[plt.Figure, plt.Axes]:\n    \"\"\"\n    Plot a haplotype network.\n\n    Args:\n        network: HaplotypeNetwork object to visualize\n        **kwargs: Arguments passed to StaticNetworkPlotter.plot()\n\n    Returns\n    -------\n        Figure and axes objects.\n\n    Example:\n        &gt;&gt;&gt; from pypopart.core.graph import HaplotypeNetwork\n        &gt;&gt;&gt; from pypopart.visualization.static_plot import plot_network\n        &gt;&gt;&gt; network = HaplotypeNetwork()\n        &gt;&gt;&gt; # ... build network ...\n        &gt;&gt;&gt; fig, ax = plot_network(network, layout_algorithm='spring')\n        &gt;&gt;&gt; plt.show()\n    \"\"\"\n    plotter = StaticNetworkPlotter(network)\n    return plotter.plot(**kwargs)\n</code></pre>"},{"location":"api/visualization/static/#pypopart.visualization.static_plot.plot_network--build-network","title":"... build network ...","text":"<p>fig, ax = plot_network(network, layout_algorithm='spring') plt.show()</p>"},{"location":"api/visualization/static/#pypopart.visualization.static_plot.create_publication_figure","title":"create_publication_figure","text":"<pre><code>create_publication_figure(\n    network: HaplotypeNetwork,\n    population_colors: Optional[Dict[str, str]] = None,\n    filename: Optional[str] = None,\n    **kwargs\n) -&gt; Tuple[plt.Figure, plt.Axes]\n</code></pre> <p>Create a publication-ready figure with legend and scale bar.</p> <p>Args:     network: HaplotypeNetwork object to visualize     population_colors: Color mapping for populations     filename: Optional filename to save figure     **kwargs: Additional arguments passed to plot()</p> <p>Returns:</p> Name Type Description <code>    Figure and axes objects.</code> <code>Example</code> <code>Axes</code> <p>fig, ax = create_publication_figure( ...     network, ...     population_colors={'PopA': 'red', 'PopB': 'blue'}, ...     filename='network.pdf' ... )</p> Source code in <code>src/pypopart/visualization/static_plot.py</code> <pre><code>def create_publication_figure(\n    network: HaplotypeNetwork,\n    population_colors: Optional[Dict[str, str]] = None,\n    filename: Optional[str] = None,\n    **kwargs,\n) -&gt; Tuple[plt.Figure, plt.Axes]:\n    \"\"\"\n    Create a publication-ready figure with legend and scale bar.\n\n    Args:\n        network: HaplotypeNetwork object to visualize\n        population_colors: Color mapping for populations\n        filename: Optional filename to save figure\n        **kwargs: Additional arguments passed to plot()\n\n    Returns\n    -------\n        Figure and axes objects.\n\n    Example:\n        &gt;&gt;&gt; fig, ax = create_publication_figure(\n        ...     network,\n        ...     population_colors={'PopA': 'red', 'PopB': 'blue'},\n        ...     filename='network.pdf'\n        ... )\n    \"\"\"\n    plotter = StaticNetworkPlotter(network)\n\n    # Create plot with defaults optimized for publication\n    fig, ax = plotter.plot(\n        population_colors=population_colors,\n        show_labels=True,\n        show_mutations=True,\n        figsize=(10, 8),\n        **kwargs,\n    )\n\n    # Add legend if population colors provided\n    if population_colors:\n        plotter.add_legend(\n            population_colors=population_colors,\n            show_median_vectors=True,\n            show_size_scale=True,\n            loc='upper right',\n        )\n\n    # Add scale bar\n    plotter.add_scale_bar(num_mutations=1)\n\n    # Add statistics\n    plotter.add_statistics_annotation()\n\n    # Save if filename provided\n    if filename:\n        plotter.save(filename)\n\n    return fig, ax\n</code></pre>"},{"location":"guide/algorithms/","title":"Network Algorithms","text":"<p>PyPopART implements six algorithms for constructing haplotype networks. Each has different characteristics and is suited for different types of data.</p>"},{"location":"guide/algorithms/#algorithm-overview","title":"Algorithm Overview","text":"Algorithm Complexity Reticulation Median Vectors Best For MST Low No No Initial exploration MSN Low-Medium Yes No Alternative paths TCS Medium Yes No Within-species MJN High Yes Yes Comprehensive analysis PN Medium Yes No General purpose TSW Medium Yes No Distance preservation"},{"location":"guide/algorithms/#minimum-spanning-tree-mst","title":"Minimum Spanning Tree (MST)","text":"<p>Creates the simplest tree connecting all haplotypes with minimum total distance.</p>"},{"location":"guide/algorithms/#characteristics","title":"Characteristics","text":"<ul> <li>Always produces a tree (no cycles)</li> <li>Deterministic (same result each time)</li> <li>Fast computation</li> <li>No reticulation (alternative paths)</li> </ul>"},{"location":"guide/algorithms/#algorithm","title":"Algorithm","text":"<ol> <li>Start with all haplotypes as separate components</li> <li>Repeatedly add shortest edge that connects components</li> <li>Stop when all haplotypes are connected</li> </ol>"},{"location":"guide/algorithms/#when-to-use","title":"When to Use","text":"<ul> <li>Initial data exploration</li> <li>Small datasets (&lt; 50 haplotypes)</li> <li>When tree structure is appropriate</li> <li>Quick preliminary analysis</li> </ul>"},{"location":"guide/algorithms/#python","title":"Python","text":"<pre><code>from pypopart.algorithms import MSTAlgorithm\n\nalgorithm = MSTAlgorithm()\nnetwork = algorithm.build_network(alignment)\n</code></pre>"},{"location":"guide/algorithms/#cli","title":"CLI","text":"<pre><code>pypopart network sequences.fasta -a MST -o mst_network\n</code></pre>"},{"location":"guide/algorithms/#limitations","title":"Limitations","text":"<ul> <li>Ignores alternative equally parsimonious connections</li> <li>May oversimplify complex relationships</li> <li>Single path between haplotypes</li> </ul>"},{"location":"guide/algorithms/#minimum-spanning-network-msn","title":"Minimum Spanning Network (MSN)","text":"<p>Extends MST by adding alternative connections of equal parsimony.</p>"},{"location":"guide/algorithms/#characteristics_1","title":"Characteristics","text":"<ul> <li>Shows alternative paths</li> <li>Reticulation present</li> <li>Still relatively simple</li> <li>Fast computation</li> </ul>"},{"location":"guide/algorithms/#algorithm_1","title":"Algorithm","text":"<ol> <li>Build MST as foundation</li> <li>Add edges creating cycles if distance equals shortest path</li> <li>Remove redundant edges</li> </ol>"},{"location":"guide/algorithms/#when-to-use_1","title":"When to Use","text":"<ul> <li>Want to see alternative evolutionary paths</li> <li>Data has ambiguous relationships</li> <li>Balance between simplicity and completeness</li> <li>Following MST analysis</li> </ul>"},{"location":"guide/algorithms/#python_1","title":"Python","text":"<pre><code>from pypopart.algorithms import MSNAlgorithm\n\nalgorithm = MSNAlgorithm()\nnetwork = algorithm.build_network(alignment)\n</code></pre>"},{"location":"guide/algorithms/#cli_1","title":"CLI","text":"<pre><code>pypopart network sequences.fasta -a MSN -o msn_network\n</code></pre>"},{"location":"guide/algorithms/#advantages-over-mst","title":"Advantages over MST","text":"<ul> <li>Shows multiple equally parsimonious paths</li> <li>More informative about uncertainty</li> <li>Still computationally efficient</li> </ul>"},{"location":"guide/algorithms/#statistical-parsimony-tcs","title":"Statistical Parsimony (TCS)","text":"<p>Connects haplotypes within statistical parsimony limit (95% confidence by default).</p>"},{"location":"guide/algorithms/#characteristics_2","title":"Characteristics","text":"<ul> <li>Statistically justified connections</li> <li>May produce disconnected networks</li> <li>No median vectors</li> <li>Confidence-based</li> </ul>"},{"location":"guide/algorithms/#algorithm_2","title":"Algorithm","text":"<ol> <li>Calculate maximum number of differences for connection (epsilon)</li> <li>Connect haplotypes differing by \u2264 epsilon mutations</li> <li>Nested clade structure</li> </ol>"},{"location":"guide/algorithms/#parameters","title":"Parameters","text":"<ul> <li><code>epsilon</code>: Connection limit (default: 0.95 confidence)</li> <li>Calculated from alignment or specified</li> </ul>"},{"location":"guide/algorithms/#when-to-use_2","title":"When to Use","text":"<ul> <li>Within-species variation</li> <li>Recent divergence</li> <li>Need statistical justification</li> <li>Population-level studies</li> </ul>"},{"location":"guide/algorithms/#python_2","title":"Python","text":"<pre><code>from pypopart.algorithms import TCSAlgorithm\n\n# Default epsilon (95% confidence)\nalgorithm = TCSAlgorithm()\nnetwork = algorithm.build_network(alignment)\n\n# Custom epsilon\nalgorithm = TCSAlgorithm(epsilon=0.99)\nnetwork = algorithm.build_network(alignment)\n</code></pre>"},{"location":"guide/algorithms/#cli_2","title":"CLI","text":"<pre><code># Default\npypopart network sequences.fasta -a TCS -o tcs_network\n\n# Custom epsilon\npypopart network sequences.fasta -a TCS --epsilon 0.99 -o tcs_network\n</code></pre>"},{"location":"guide/algorithms/#considerations","title":"Considerations","text":"<ul> <li>May produce multiple disconnected components</li> <li>Sensitive to epsilon parameter</li> <li>Assumes neutrality and panmixia</li> </ul>"},{"location":"guide/algorithms/#median-joining-network-mjn","title":"Median-Joining Network (MJN)","text":"<p>Most comprehensive algorithm inferring ancestral haplotypes.</p>"},{"location":"guide/algorithms/#characteristics_3","title":"Characteristics","text":"<ul> <li>Infers median vectors (ancestral/unobserved haplotypes)</li> <li>Shows reticulation</li> <li>Most complete</li> <li>Computationally intensive</li> </ul>"},{"location":"guide/algorithms/#algorithm_3","title":"Algorithm","text":"<ol> <li>Build MSN as starting point</li> <li>Identify and add median vectors (consensus sequences)</li> <li>Remove unnecessary edges</li> <li>Iterate until stable</li> </ol>"},{"location":"guide/algorithms/#when-to-use_3","title":"When to Use","text":"<ul> <li>Complex evolutionary scenarios</li> <li>Large datasets with structure</li> <li>Need ancestral sequence inference</li> <li>Publication-quality analysis</li> </ul>"},{"location":"guide/algorithms/#python_3","title":"Python","text":"<pre><code>from pypopart.algorithms import MJNAlgorithm\n\nalgorithm = MJNAlgorithm()\nnetwork = algorithm.build_network(alignment)\n</code></pre>"},{"location":"guide/algorithms/#cli_3","title":"CLI","text":"<pre><code>pypopart network sequences.fasta -a MJN -o mjn_network\n</code></pre>"},{"location":"guide/algorithms/#advantages","title":"Advantages","text":"<ul> <li>Most informative</li> <li>Shows inferred ancestors</li> <li>Handles complex relationships</li> <li>Widely used in publications</li> </ul>"},{"location":"guide/algorithms/#limitations_1","title":"Limitations","text":"<ul> <li>Computationally expensive</li> <li>Can be complex to interpret</li> <li>May overfit small datasets</li> </ul>"},{"location":"guide/algorithms/#parsimony-network-pn","title":"Parsimony Network (PN)","text":"<p>Consensus approach using multiple MSTs with different starting points.</p>"},{"location":"guide/algorithms/#characteristics_4","title":"Characteristics","text":"<ul> <li>Consensus of multiple trees</li> <li>Shows reticulation</li> <li>Balanced complexity</li> <li>Robust to starting conditions</li> </ul>"},{"location":"guide/algorithms/#algorithm_4","title":"Algorithm","text":"<ol> <li>Build multiple MSTs with different starting haplotypes</li> <li>Combine into consensus network</li> <li>Keep connections appearing in multiple trees</li> </ol>"},{"location":"guide/algorithms/#when-to-use_4","title":"When to Use","text":"<ul> <li>General purpose analysis</li> <li>Want robustness</li> <li>Balance between MSN and MJN</li> <li>Uncertain about best algorithm</li> </ul>"},{"location":"guide/algorithms/#python_4","title":"Python","text":"<pre><code>from pypopart.algorithms import ParsimonyNetAlgorithm\n\nalgorithm = ParsimonyNetAlgorithm()\nnetwork = algorithm.build_network(alignment)\n</code></pre>"},{"location":"guide/algorithms/#cli_4","title":"CLI","text":"<pre><code>pypopart network sequences.fasta -a PN -o pn_network\n</code></pre>"},{"location":"guide/algorithms/#tight-span-walker-tsw","title":"Tight Span Walker (TSW)","text":"<p>Metric-preserving network construction.</p>"},{"location":"guide/algorithms/#characteristics_5","title":"Characteristics","text":"<ul> <li>Preserves distance relationships</li> <li>Metric space approach</li> <li>Mathematical rigor</li> <li>Moderate complexity</li> </ul>"},{"location":"guide/algorithms/#algorithm_5","title":"Algorithm","text":"<ol> <li>Compute tight span of distance matrix</li> <li>Walk through tight span structure</li> <li>Build network preserving distances</li> </ol>"},{"location":"guide/algorithms/#when-to-use_5","title":"When to Use","text":"<ul> <li>Distance accuracy critical</li> <li>Mathematical rigor needed</li> <li>Metric properties important</li> <li>Complex distance patterns</li> </ul>"},{"location":"guide/algorithms/#python_5","title":"Python","text":"<pre><code>from pypopart.algorithms import TSWAlgorithm\n\nalgorithm = TSWAlgorithm()\nnetwork = algorithm.build_network(alignment)\n</code></pre>"},{"location":"guide/algorithms/#cli_5","title":"CLI","text":"<pre><code>pypopart network sequences.fasta -a TSW -o tsw_network\n</code></pre>"},{"location":"guide/algorithms/#choosing-an-algorithm","title":"Choosing an Algorithm","text":""},{"location":"guide/algorithms/#by-data-type","title":"By Data Type","text":"<p>Intraspecific (within species) - TCS (recommended) - MSN - MJN</p> <p>Interspecific (between species) - MST - MSN - PN</p> <p>Population genetics - TCS - MJN</p> <p>Phylogeography - MJN - PN</p>"},{"location":"guide/algorithms/#by-dataset-size","title":"By Dataset Size","text":"<p>Small (&lt; 20 haplotypes) - Any algorithm - Start with MST/MSN</p> <p>Medium (20-100 haplotypes) - TCS - MSN - MJN</p> <p>Large (&gt; 100 haplotypes) - MST (fast exploration) - TCS - PN</p>"},{"location":"guide/algorithms/#by-question","title":"By Question","text":"<p>Exploratory analysis \u2192 MST, MSN</p> <p>Population structure \u2192 TCS, MJN</p> <p>Ancestral inference \u2192 MJN</p> <p>Publication figure \u2192 MJN, PN</p> <p>Quick overview \u2192 MST</p> <p>Statistical rigor \u2192 TCS</p>"},{"location":"guide/algorithms/#comparing-algorithms","title":"Comparing Algorithms","text":"<p>Run multiple algorithms on the same data:</p> <pre><code>from pypopart import Alignment\nfrom pypopart.algorithms import MSTAlgorithm, MSNAlgorithm, TCSAlgorithm, MJNAlgorithm\n\nalignment = Alignment.from_fasta(\"sequences.fasta\")\n\nalgorithms = {\n    \"MST\": MSTAlgorithm(),\n    \"MSN\": MSNAlgorithm(),\n    \"TCS\": TCSAlgorithm(),\n    \"MJN\": MJNAlgorithm(),\n}\n\nnetworks = {}\nfor name, algorithm in algorithms.items():\n    networks[name] = algorithm.build_network(alignment)\n    print(f\"{name}: {networks[name].number_of_nodes()} nodes, {networks[name].number_of_edges()} edges\")\n</code></pre> <p>CLI batch comparison: <pre><code>for alg in MST MSN TCS MJN; do\n    pypopart network sequences.fasta -a $alg -o comparison/${alg}_network\ndone\n</code></pre></p>"},{"location":"guide/algorithms/#performance-comparison","title":"Performance Comparison","text":"Algorithm Time (50 seqs) Time (200 seqs) Memory MST &lt; 1s &lt; 5s Low MSN &lt; 2s &lt; 10s Low TCS &lt; 5s &lt; 30s Medium MJN 10-30s 2-5 min High PN 5-10s 30-60s Medium TSW 5-15s 30-90s Medium <p>Times are approximate and depend on divergence level</p>"},{"location":"guide/algorithms/#best-practices","title":"Best Practices","text":"<ol> <li>Start simple: Begin with MST for exploration</li> <li>Compare algorithms: Run multiple to understand data</li> <li>Check assumptions: Ensure algorithm matches data type</li> <li>Consider computational cost: MJN great but slow</li> <li>Validate results: Check if network makes biological sense</li> <li>Report parameters: Document algorithm and settings used</li> </ol>"},{"location":"guide/algorithms/#common-issues","title":"Common Issues","text":""},{"location":"guide/algorithms/#network-is-disconnected","title":"\"Network is disconnected\"","text":"<ul> <li>Normal for TCS with high divergence</li> <li>Increase epsilon or use different algorithm</li> </ul>"},{"location":"guide/algorithms/#too-many-median-vectors","title":"\"Too many median vectors\"","text":"<ul> <li>MJN can generate many inferred nodes</li> <li>Normal for large, complex datasets</li> <li>Consider MSN or PN for simplicity</li> </ul>"},{"location":"guide/algorithms/#computation-too-slow","title":"\"Computation too slow\"","text":"<ul> <li>MJN slow on large datasets</li> <li>Try MST/MSN first</li> <li>Consider sampling or filtering data</li> </ul>"},{"location":"guide/algorithms/#references","title":"References","text":"<ul> <li>Kruskal (1956) - MST</li> <li>Excoffier &amp; Smouse (1994) - MSN</li> <li>Templeton et al. (1992) - TCS</li> <li>Bandelt et al. (1999) - Median-Joining</li> <li>Dress &amp; Huson (2004) - Tight Span</li> </ul>"},{"location":"guide/algorithms/#next-steps","title":"Next Steps","text":"<ul> <li>Visualization Guide: Plot your networks</li> <li>Analysis Guide: Analyze network properties</li> <li>Tutorials: Detailed comparison</li> </ul>"},{"location":"guide/analysis/","title":"Network Analysis","text":"<p>PyPopART provides comprehensive tools for analyzing haplotype network structure and population genetics.</p>"},{"location":"guide/analysis/#network-statistics","title":"Network Statistics","text":""},{"location":"guide/analysis/#basic-properties","title":"Basic Properties","text":"<pre><code>from pypopart.stats import NetworkStatistics\n\nstats = NetworkStatistics(network)\n\n# Size metrics\nprint(f\"Number of nodes: {stats.number_of_nodes()}\")\nprint(f\"Number of edges: {stats.number_of_edges()}\")\nprint(f\"Network density: {stats.density():.3f}\")\n\n# Connectivity\nprint(f\"Is connected: {stats.is_connected()}\")\nprint(f\"Number of components: {stats.number_of_components()}\")\n\n# Path metrics\nprint(f\"Diameter: {stats.diameter()}\")\nprint(f\"Average path length: {stats.average_path_length():.3f}\")\n</code></pre>"},{"location":"guide/analysis/#centrality-measures","title":"Centrality Measures","text":"<p>Identify important haplotypes:</p> <pre><code># Degree centrality (number of connections)\ndegree_centrality = stats.degree_centrality()\nprint(\"Most connected haplotypes:\")\nfor node, score in sorted(degree_centrality.items(), key=lambda x: x[1], reverse=True)[:5]:\n    print(f\"  {node}: {score:.3f}\")\n\n# Betweenness centrality (bridge nodes)\nbetweenness = stats.betweenness_centrality()\n\n# Closeness centrality (proximity to all nodes)\ncloseness = stats.closeness_centrality()\n\n# Eigenvector centrality (influence)\neigenvector = stats.eigenvector_centrality()\n</code></pre>"},{"location":"guide/analysis/#clustering","title":"Clustering","text":"<pre><code># Clustering coefficient (local interconnectedness)\nclustering = stats.clustering_coefficient()\nprint(f\"Average clustering: {clustering:.3f}\")\n\n# Per-node clustering\nnode_clustering = stats.node_clustering()\n</code></pre>"},{"location":"guide/analysis/#topology-analysis","title":"Topology Analysis","text":""},{"location":"guide/analysis/#hub-detection","title":"Hub Detection","text":"<p>Identify central haplotypes:</p> <pre><code>from pypopart.stats import TopologyAnalysis\n\ntopology = TopologyAnalysis(network)\n\n# Find hub haplotypes\nhubs = topology.identify_hubs(threshold=3)\nprint(f\"Hub haplotypes: {hubs}\")\n\n# Star topology detection\nstars = topology.detect_star_patterns()\nfor center, tips in stars:\n    print(f\"Star centered on {center} with {len(tips)} tips\")\n</code></pre>"},{"location":"guide/analysis/#bridge-analysis","title":"Bridge Analysis","text":"<p>Find edges connecting subpopulations:</p> <pre><code># Identify bridge edges\nbridges = topology.identify_bridges()\nprint(f\"Bridge connections: {bridges}\")\n\n# Articulation points (nodes that disconnect network if removed)\narticulation_points = topology.articulation_points()\nprint(f\"Critical nodes: {articulation_points}\")\n</code></pre>"},{"location":"guide/analysis/#community-detection","title":"Community Detection","text":"<pre><code># Detect communities/subgroups\ncommunities = topology.detect_communities(method=\"louvain\")\nprint(f\"Number of communities: {len(communities)}\")\n\nfor i, community in enumerate(communities):\n    print(f\"Community {i+1}: {len(community)} haplotypes\")\n</code></pre>"},{"location":"guide/analysis/#population-genetics-statistics","title":"Population Genetics Statistics","text":""},{"location":"guide/analysis/#diversity-measures","title":"Diversity Measures","text":"<pre><code>from pypopart.stats import PopulationGenetics\n\npopgen = PopulationGenetics(alignment)\n\n# Haplotype diversity (probability two random samples differ)\nh = popgen.haplotype_diversity()\nprint(f\"Haplotype diversity: {h:.4f}\")\n\n# Nucleotide diversity (average pairwise differences)\npi = popgen.nucleotide_diversity()\nprint(f\"Nucleotide diversity (\u03c0): {pi:.4f}\")\n\n# Shannon entropy\nshannon = popgen.shannon_entropy()\nprint(f\"Shannon index: {shannon:.4f}\")\n</code></pre>"},{"location":"guide/analysis/#neutrality-tests","title":"Neutrality Tests","text":"<p>Test for departure from neutral evolution:</p> <pre><code># Tajima's D\ntajimas_d = popgen.tajimas_d()\nprint(f\"Tajima's D: {tajimas_d:.4f}\")\nif tajimas_d &lt; -2:\n    print(\"  \u2192 Suggests population expansion or purifying selection\")\nelif tajimas_d &gt; 2:\n    print(\"  \u2192 Suggests balancing selection or population contraction\")\nelse:\n    print(\"  \u2192 Consistent with neutral evolution\")\n\n# Fu's Fs\nfus_fs = popgen.fus_fs()\nprint(f\"Fu's Fs: {fus_fs:.4f}\")\nif fus_fs &lt; -3:\n    print(\"  \u2192 Suggests recent population expansion\")\n</code></pre>"},{"location":"guide/analysis/#population-differentiation","title":"Population Differentiation","text":"<p>Analyze structure between populations:</p> <pre><code># FST between populations (requires metadata)\nfst = popgen.calculate_fst(population_column='Population')\nprint(f\"FST: {fst:.4f}\")\n\n# Pairwise FST\npairwise_fst = popgen.pairwise_fst(population_column='Population')\nprint(\"Pairwise FST:\")\nprint(pairwise_fst)\n\n# Gene flow (Nm)\nnm = popgen.gene_flow(population_column='Population')\nprint(f\"Gene flow (Nm): {nm:.2f}\")\n</code></pre>"},{"location":"guide/analysis/#allele-frequency-spectrum","title":"Allele Frequency Spectrum","text":"<pre><code># Site frequency spectrum\nsfs = popgen.site_frequency_spectrum()\nprint(\"Site frequency spectrum:\", sfs)\n\n# Segregating sites\ns = popgen.segregating_sites()\nprint(f\"Number of segregating sites: {s}\")\n</code></pre>"},{"location":"guide/analysis/#temporal-analysis","title":"Temporal Analysis","text":"<p>Analyze changes over time:</p> <pre><code># Requires temporal metadata\ntemporal = PopulationGenetics(alignment)\n\n# Diversity over time\ndiversity_by_year = temporal.diversity_through_time(time_column='Year')\n\n# Expansion/contraction\ngrowth_rate = temporal.estimate_growth_rate(time_column='Year')\nprint(f\"Growth rate: {growth_rate:.4f}\")\n</code></pre>"},{"location":"guide/analysis/#spatial-analysis","title":"Spatial Analysis","text":"<p>Analyze geographic structure:</p> <pre><code>from pypopart.stats import SpatialAnalysis\n\n# Requires geographic metadata\nspatial = SpatialAnalysis(alignment, network)\n\n# Isolation by distance\nibd = spatial.isolation_by_distance(\n    lat_column='Latitude',\n    lon_column='Longitude'\n)\nprint(f\"Isolation by distance (R\u00b2): {ibd['r_squared']:.3f}\")\nprint(f\"P-value: {ibd['p_value']:.4f}\")\n\n# Geographic structure\namova = spatial.amova(region_column='Region')\nprint(f\"Among-region variance: {amova['among']:.1f}%\")\nprint(f\"Within-region variance: {amova['within']:.1f}%\")\n</code></pre>"},{"location":"guide/analysis/#haplotype-frequency-analysis","title":"Haplotype Frequency Analysis","text":"<pre><code># Most common haplotypes\nfreq = network.haplotype_frequencies()\ntop_10 = sorted(freq.items(), key=lambda x: x[1], reverse=True)[:10]\nprint(\"Top 10 haplotypes by frequency:\")\nfor hap, count in top_10:\n    print(f\"  {hap}: {count} ({count/sum(freq.values())*100:.1f}%)\")\n\n# Singleton haplotypes\nsingletons = [h for h, f in freq.items() if f == 1]\nprint(f\"Number of singleton haplotypes: {len(singletons)}\")\n\n# Cumulative frequency\ncumulative = popgen.cumulative_frequency_distribution()\n</code></pre>"},{"location":"guide/analysis/#network-comparison","title":"Network Comparison","text":"<p>Compare different networks:</p> <pre><code>from pypopart.stats import NetworkComparison\n\n# Compare two networks\ncomparison = NetworkComparison(network1, network2)\n\n# Structural similarity\nsimilarity = comparison.structural_similarity()\nprint(f\"Jaccard similarity: {similarity['jaccard']:.3f}\")\nprint(f\"Correlation: {similarity['correlation']:.3f}\")\n\n# Node overlap\nnode_overlap = comparison.node_overlap()\nprint(f\"Shared nodes: {node_overlap['shared']}\")\nprint(f\"Unique to network1: {node_overlap['unique1']}\")\nprint(f\"Unique to network2: {node_overlap['unique2']}\")\n\n# Topology differences\ndiff = comparison.topology_differences()\n</code></pre>"},{"location":"guide/analysis/#statistical-testing","title":"Statistical Testing","text":""},{"location":"guide/analysis/#permutation-tests","title":"Permutation Tests","text":"<pre><code>from pypopart.stats import PermutationTest\n\n# Test if observed statistic is significant\ntest = PermutationTest(alignment, n_permutations=1000)\n\n# Test for population differentiation\nresult = test.test_fst(population_column='Population')\nprint(f\"Observed FST: {result['observed']:.4f}\")\nprint(f\"P-value: {result['p_value']:.4f}\")\n\n# Test for temporal structure\nresult = test.test_temporal_structure(time_column='Year')\n</code></pre>"},{"location":"guide/analysis/#bootstrap-confidence-intervals","title":"Bootstrap Confidence Intervals","text":"<pre><code>from pypopart.stats import Bootstrap\n\nbootstrap = Bootstrap(alignment, n_replicates=1000)\n\n# Bootstrap diversity estimates\nci = bootstrap.diversity_ci(metric='nucleotide_diversity')\nprint(f\"Nucleotide diversity: {ci['estimate']:.4f}\")\nprint(f\"95% CI: [{ci['lower']:.4f}, {ci['upper']:.4f}]\")\n</code></pre>"},{"location":"guide/analysis/#export-results","title":"Export Results","text":""},{"location":"guide/analysis/#summary-report","title":"Summary Report","text":"<pre><code># Generate comprehensive report\nstats = NetworkStatistics(network)\npopgen = PopulationGenetics(alignment)\n\nreport = {\n    \"Network\": {\n        \"nodes\": stats.number_of_nodes(),\n        \"edges\": stats.number_of_edges(),\n        \"diameter\": stats.diameter(),\n        \"clustering\": stats.clustering_coefficient(),\n    },\n    \"Population\": {\n        \"haplotype_diversity\": popgen.haplotype_diversity(),\n        \"nucleotide_diversity\": popgen.nucleotide_diversity(),\n        \"tajimas_d\": popgen.tajimas_d(),\n    }\n}\n\n# Save as JSON\nimport json\nwith open(\"analysis_report.json\", \"w\") as f:\n    json.dump(report, f, indent=2)\n\n# Save as CSV\nimport pandas as pd\ndf = pd.DataFrame(report)\ndf.to_csv(\"analysis_report.csv\")\n</code></pre>"},{"location":"guide/analysis/#batch-analysis","title":"Batch Analysis","text":"<pre><code># Analyze multiple datasets\ndatasets = [\"pop1.fasta\", \"pop2.fasta\", \"pop3.fasta\"]\nresults = []\n\nfor dataset in datasets:\n    alignment = Alignment.from_fasta(dataset)\n    network = algorithm.build_network(alignment)\n\n    stats = NetworkStatistics(network)\n    popgen = PopulationGenetics(alignment)\n\n    results.append({\n        \"dataset\": dataset,\n        \"n_haplotypes\": stats.number_of_nodes(),\n        \"hap_diversity\": popgen.haplotype_diversity(),\n        \"nuc_diversity\": popgen.nucleotide_diversity(),\n    })\n\n# Save results\ndf = pd.DataFrame(results)\ndf.to_csv(\"batch_analysis.csv\", index=False)\n</code></pre>"},{"location":"guide/analysis/#best-practices","title":"Best Practices","text":"<ol> <li>Check assumptions: Ensure statistical tests are appropriate for your data</li> <li>Multiple testing correction: Apply when running many tests</li> <li>Report confidence intervals: Not just point estimates</li> <li>Visualize results: Plots often reveal patterns statistics miss</li> <li>Biological interpretation: Statistical significance \u2260 biological importance</li> </ol>"},{"location":"guide/analysis/#common-analyses","title":"Common Analyses","text":""},{"location":"guide/analysis/#publication-checklist","title":"Publication Checklist","text":"<p>For a typical population genetics paper:</p> <pre><code># 1. Basic network properties\nstats = NetworkStatistics(network)\nprint(f\"Haplotypes: {stats.number_of_nodes()}\")\nprint(f\"Connections: {stats.number_of_edges()}\")\n\n# 2. Diversity measures\npopgen = PopulationGenetics(alignment)\nprint(f\"Haplotype diversity: {popgen.haplotype_diversity():.4f}\")\nprint(f\"Nucleotide diversity: {popgen.nucleotide_diversity():.4f}\")\n\n# 3. Neutrality tests\nprint(f\"Tajima's D: {popgen.tajimas_d():.4f}\")\n\n# 4. Population structure\nprint(f\"FST: {popgen.calculate_fst(population_column='Population'):.4f}\")\n\n# 5. Network topology\ntopology = TopologyAnalysis(network)\nprint(f\"Hub haplotypes: {topology.identify_hubs()}\")\n</code></pre>"},{"location":"guide/analysis/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guide/analysis/#insufficient-data-for-test","title":"\"Insufficient data for test\"","text":"<p>\u2192 Ensure adequate sample size (usually n &gt; 20)</p>"},{"location":"guide/analysis/#test-not-significant","title":"\"Test not significant\"","text":"<p>\u2192 May indicate true lack of signal or insufficient power</p>"},{"location":"guide/analysis/#negative-diversity","title":"\"Negative diversity\"","text":"<p>\u2192 Check for sequencing errors or incorrect alignment</p>"},{"location":"guide/analysis/#fst-1-or-0","title":"\"FST &gt; 1 or &lt; 0\"","text":"<p>\u2192 Calculation error; check population assignments</p>"},{"location":"guide/analysis/#next-steps","title":"Next Steps","text":"<ul> <li>Visualization Guide: Plot analysis results</li> <li>Tutorials: Population genetics examples</li> <li>API Reference: Complete statistics API</li> </ul>"},{"location":"guide/api/","title":"Python API Guide","text":"<p>Use PyPopART programmatically in your Python scripts and notebooks.</p>"},{"location":"guide/api/#basic-workflow","title":"Basic Workflow","text":"<pre><code>from pypopart import Alignment, Network\nfrom pypopart.algorithms import MSTAlgorithm, MJNAlgorithm\nfrom pypopart.visualization import StaticPlot, InteractivePlot\n\n# 1. Load sequence data\nalignment = Alignment.from_fasta(\"sequences.fasta\")\n\n# 2. Build network\nalgorithm = MSTAlgorithm()\nnetwork = algorithm.build_network(alignment)\n\n# 3. Visualize\nplot = StaticPlot(network)\nplot.save(\"network.png\")\n</code></pre>"},{"location":"guide/api/#loading-data","title":"Loading Data","text":""},{"location":"guide/api/#from-files","title":"From Files","text":"<pre><code>from pypopart import Alignment\n\n# FASTA format\nalignment = Alignment.from_fasta(\"sequences.fasta\")\n\n# NEXUS format (with metadata)\nalignment = Alignment.from_nexus(\"sequences.nex\")\n\n# PHYLIP format\nalignment = Alignment.from_phylip(\"sequences.phy\")\n\n# GenBank format\nalignment = Alignment.from_genbank(\"sequences.gb\")\n</code></pre>"},{"location":"guide/api/#from-strings","title":"From Strings","text":"<pre><code>from pypopart import Alignment\n\nfasta_string = \"\"\"\n&gt;Seq1\nATCGATCGATCG\n&gt;Seq2\nATCGATCGATCG\n&gt;Seq3\nATCGATTGATCG\n\"\"\"\n\nalignment = Alignment.from_string(fasta_string, format=\"fasta\")\n</code></pre>"},{"location":"guide/api/#from-biopython","title":"From BioPython","text":"<pre><code>from Bio import AlignIO\nfrom pypopart import Alignment\n\n# Load with BioPython\nbio_alignment = AlignIO.read(\"sequences.fasta\", \"fasta\")\n\n# Convert to PyPopART\nalignment = Alignment.from_biopython(bio_alignment)\n</code></pre>"},{"location":"guide/api/#building-networks","title":"Building Networks","text":""},{"location":"guide/api/#algorithm-selection","title":"Algorithm Selection","text":"<pre><code>from pypopart.algorithms import (\n    MSTAlgorithm,\n    MSNAlgorithm,\n    TCSAlgorithm,\n    MJNAlgorithm,\n    ParsimonyNetAlgorithm,\n    TSWAlgorithm,\n)\n\n# Minimum Spanning Tree\nmst = MSTAlgorithm()\nnetwork = mst.build_network(alignment)\n\n# Median-Joining Network\nmjn = MJNAlgorithm()\nnetwork = mjn.build_network(alignment)\n\n# TCS with custom epsilon\ntcs = TCSAlgorithm(epsilon=0.99)\nnetwork = tcs.build_network(alignment)\n</code></pre>"},{"location":"guide/api/#distance-metrics","title":"Distance Metrics","text":"<pre><code>from pypopart.core.distance import DistanceCalculator\n\n# Create calculator with specific metric\ncalc = DistanceCalculator(metric=\"k2p\")  # Kimura 2-parameter\ndistances = calc.calculate(alignment)\n\n# Available metrics: 'hamming', 'jukes-cantor', 'k2p', 'tamura-nei'\n\n# Use custom distance matrix\nalgorithm = MSTAlgorithm(distance_matrix=distances)\nnetwork = algorithm.build_network(alignment)\n</code></pre>"},{"location":"guide/api/#working-with-networks","title":"Working with Networks","text":""},{"location":"guide/api/#network-properties","title":"Network Properties","text":"<pre><code># Basic properties\nprint(f\"Number of nodes: {network.number_of_nodes()}\")\nprint(f\"Number of edges: {network.number_of_edges()}\")\nprint(f\"Network density: {network.density()}\")\n\n# Get nodes and edges\nnodes = list(network.nodes())\nedges = list(network.edges())\n\n# Node attributes\nfor node in network.nodes():\n    haplotype = network.nodes[node]['haplotype']\n    frequency = network.nodes[node]['frequency']\n    print(f\"{node}: frequency={frequency}\")\n\n# Edge attributes\nfor u, v in network.edges():\n    weight = network[u][v]['weight']\n    print(f\"{u} -&gt; {v}: distance={weight}\")\n</code></pre>"},{"location":"guide/api/#network-statistics","title":"Network Statistics","text":"<pre><code>from pypopart.stats import NetworkStatistics, TopologyAnalysis\n\n# Calculate basic statistics\nstats = NetworkStatistics(network)\nprint(f\"Diameter: {stats.diameter()}\")\nprint(f\"Average path length: {stats.average_path_length()}\")\nprint(f\"Clustering coefficient: {stats.clustering_coefficient()}\")\n\n# Topology analysis\ntopology = TopologyAnalysis(network)\nhubs = topology.identify_hubs()\nbridges = topology.identify_bridges()\nstar_patterns = topology.detect_star_patterns()\n</code></pre>"},{"location":"guide/api/#population-genetics","title":"Population Genetics","text":"<pre><code>from pypopart.stats import PopulationGenetics\n\npopgen = PopulationGenetics(alignment)\n\n# Diversity measures\nprint(f\"Nucleotide diversity: {popgen.nucleotide_diversity()}\")\nprint(f\"Haplotype diversity: {popgen.haplotype_diversity()}\")\n\n# Neutrality tests\nprint(f\"Tajima's D: {popgen.tajimas_d()}\")\nprint(f\"Fu's Fs: {popgen.fus_fs()}\")\n\n# Population differentiation (requires population metadata)\nfst = popgen.calculate_fst(population_column='Population')\nprint(f\"FST: {fst}\")\n</code></pre>"},{"location":"guide/api/#visualization","title":"Visualization","text":""},{"location":"guide/api/#static-plots","title":"Static Plots","text":"<pre><code>from pypopart.visualization import StaticPlot\n\n# Basic plot\nplot = StaticPlot(network)\nplot.save(\"network.png\")\n\n# Customized plot\nplot = StaticPlot(\n    network,\n    layout=\"spring\",        # or 'circular', 'kamada-kawai'\n    node_size=500,\n    edge_width=2.0,\n    figsize=(12, 10),\n    dpi=300\n)\n\n# Color by metadata\nplot.color_by_attribute(\"Population\")\nplot.save(\"colored_network.png\", format=\"pdf\")\n</code></pre>"},{"location":"guide/api/#interactive-plots","title":"Interactive Plots","text":"<pre><code>from pypopart.visualization import InteractivePlot\n\n# Create interactive HTML plot\nplot = InteractivePlot(network)\nplot.save(\"network.html\")\n\n# With custom styling\nplot = InteractivePlot(\n    network,\n    layout=\"spring\",\n    node_size_by=\"frequency\",\n    color_by=\"Population\",\n    show_labels=True\n)\nplot.save(\"interactive_network.html\")\n</code></pre>"},{"location":"guide/api/#layout-algorithms","title":"Layout Algorithms","text":"<pre><code>from pypopart.layout import LayoutAlgorithm\n\n# Use specific layout\nlayout = LayoutAlgorithm.spring(network, k=1.0, iterations=50)\nplot = StaticPlot(network, positions=layout)\n\n# Available layouts\nlayouts = [\n    \"spring\",           # Force-directed (default)\n    \"circular\",         # Circular arrangement\n    \"kamada-kawai\",     # Energy minimization\n    \"spectral\",         # Eigenvalue-based\n    \"random\"            # Random positions\n]\n</code></pre>"},{"location":"guide/api/#exporting-results","title":"Exporting Results","text":""},{"location":"guide/api/#save-networks","title":"Save Networks","text":"<pre><code># Export in various formats\nnetwork.save(\"network.gml\")          # GML format\nnetwork.save(\"network.graphml\")      # GraphML format\nnetwork.save(\"network.json\")         # JSON format\nnetwork.save(\"network.nexus\")        # NEXUS format\n\n# With metadata\nnetwork.save(\"network.nexus\", include_traits=True)\n</code></pre>"},{"location":"guide/api/#export-distance-matrix","title":"Export Distance Matrix","text":"<pre><code>from pypopart.core.distance import DistanceCalculator\n\ncalc = DistanceCalculator(metric=\"k2p\")\ndistances = calc.calculate(alignment)\n\n# Save as CSV\ndistances.to_csv(\"distances.csv\")\n\n# Save as NumPy array\nimport numpy as np\nnp.save(\"distances.npy\", distances.matrix)\n</code></pre>"},{"location":"guide/api/#export-statistics","title":"Export Statistics","text":"<pre><code>from pypopart.stats import NetworkStatistics\nimport pandas as pd\n\nstats = NetworkStatistics(network)\nresults = {\n    \"diameter\": stats.diameter(),\n    \"avg_path_length\": stats.average_path_length(),\n    \"clustering\": stats.clustering_coefficient(),\n    \"num_nodes\": network.number_of_nodes(),\n    \"num_edges\": network.number_of_edges(),\n}\n\n# Save as DataFrame\ndf = pd.DataFrame([results])\ndf.to_csv(\"statistics.csv\", index=False)\n</code></pre>"},{"location":"guide/api/#advanced-usage","title":"Advanced Usage","text":""},{"location":"guide/api/#custom-algorithms","title":"Custom Algorithms","text":"<pre><code>from pypopart.algorithms.base import BaseAlgorithm\n\nclass CustomAlgorithm(BaseAlgorithm):\n    def build_network(self, alignment):\n        # Your implementation\n        network = self.create_empty_network()\n        # ... add nodes and edges\n        return network\n\n# Use your algorithm\nalgorithm = CustomAlgorithm()\nnetwork = algorithm.build_network(alignment)\n</code></pre>"},{"location":"guide/api/#batch-processing","title":"Batch Processing","text":"<pre><code>from pathlib import Path\nfrom pypopart import Alignment\nfrom pypopart.algorithms import MSTAlgorithm\n\n# Process multiple files\nalgorithm = MSTAlgorithm()\n\nfor fasta_file in Path(\"data\").glob(\"*.fasta\"):\n    alignment = Alignment.from_fasta(fasta_file)\n    network = algorithm.build_network(alignment)\n    network.save(f\"networks/{fasta_file.stem}.gml\")\n</code></pre>"},{"location":"guide/api/#integration-with-networkx","title":"Integration with NetworkX","text":"<pre><code>import networkx as nx\n\n# PyPopART networks are NetworkX graphs\n# Use any NetworkX function\n\n# Graph algorithms\nshortest_paths = nx.shortest_path(network)\nbetweenness = nx.betweenness_centrality(network)\ncommunities = nx.community.louvain_communities(network)\n\n# Export to other NetworkX formats\nnx.write_gexf(network, \"network.gexf\")\n</code></pre>"},{"location":"guide/api/#error-handling","title":"Error Handling","text":"<pre><code>from pypopart.exceptions import (\n    AlignmentError,\n    NetworkError,\n    DistanceError,\n)\n\ntry:\n    alignment = Alignment.from_fasta(\"sequences.fasta\")\n    network = algorithm.build_network(alignment)\nexcept AlignmentError as e:\n    print(f\"Alignment error: {e}\")\nexcept NetworkError as e:\n    print(f\"Network construction error: {e}\")\nexcept FileNotFoundError:\n    print(\"Input file not found\")\n</code></pre>"},{"location":"guide/api/#next-steps","title":"Next Steps","text":"<ul> <li>Loading Data Guide: Detailed data loading instructions</li> <li>Algorithm Guide: Choose the right algorithm</li> <li>Visualization Guide: Create publication-quality figures</li> <li>API Reference: Complete API documentation</li> </ul>"},{"location":"guide/cli/","title":"Command-Line Interface","text":"<p>PyPopART provides a comprehensive command-line interface for scripting and automation.</p>"},{"location":"guide/cli/#basic-usage","title":"Basic Usage","text":"<pre><code>pypopart [OPTIONS] COMMAND [ARGS]...\n</code></pre>"},{"location":"guide/cli/#main-commands","title":"Main Commands","text":""},{"location":"guide/cli/#network-build-haplotype-networks","title":"<code>network</code> - Build Haplotype Networks","text":"<p>Create a haplotype network from sequence data:</p> <pre><code>pypopart network input.fasta -a MST -o output\n</code></pre> <p>Options:</p> <ul> <li><code>-i, --input PATH</code>: Input sequence file (required)</li> <li><code>-a, --algorithm ALGORITHM</code>: Network algorithm (MST, MSN, TCS, MJN, PN, TSW)</li> <li><code>-d, --distance METRIC</code>: Distance metric (hamming, jukes-cantor, k2p, tamura-nei)</li> <li><code>-o, --output PATH</code>: Output prefix for files</li> <li><code>-f, --format FORMAT</code>: Output format (nexus, gml, graphml, json)</li> <li><code>--epsilon FLOAT</code>: TCS connection limit (default: 0.95)</li> <li><code>--plot</code>: Generate visualization plot</li> <li><code>--interactive</code>: Create interactive HTML plot</li> </ul> <p>Examples:</p> <pre><code># Basic MST network\npypopart network sequences.fasta -a MST -o my_network\n\n# TCS network with custom epsilon\npypopart network sequences.fasta -a TCS --epsilon 0.99 -o tcs_network\n\n# MJN network with interactive plot\npypopart network sequences.fasta -a MJN --plot --interactive -o mjn_network\n</code></pre>"},{"location":"guide/cli/#distance-calculate-distance-matrix","title":"<code>distance</code> - Calculate Distance Matrix","text":"<p>Compute pairwise genetic distances:</p> <pre><code>pypopart distance input.fasta -m k2p -o distances.csv\n</code></pre> <p>Options:</p> <ul> <li><code>-i, --input PATH</code>: Input sequence file (required)</li> <li><code>-m, --metric METRIC</code>: Distance metric (hamming, jukes-cantor, k2p, tamura-nei)</li> <li><code>-o, --output PATH</code>: Output file path</li> <li><code>-f, --format FORMAT</code>: Output format (csv, tsv, json)</li> </ul>"},{"location":"guide/cli/#stats-network-statistics","title":"<code>stats</code> - Network Statistics","text":"<p>Calculate network statistics:</p> <pre><code>pypopart stats network.gml -o statistics.txt\n</code></pre> <p>Options:</p> <ul> <li><code>-i, --input PATH</code>: Input network file (required)</li> <li><code>-o, --output PATH</code>: Output file path</li> <li><code>--topology</code>: Include topology metrics</li> <li><code>--diversity</code>: Include diversity indices</li> <li><code>--popgen</code>: Include population genetics statistics</li> </ul>"},{"location":"guide/cli/#plot-visualize-networks","title":"<code>plot</code> - Visualize Networks","text":"<p>Create network visualizations:</p> <pre><code>pypopart plot network.gml -o figure.png\n</code></pre> <p>Options:</p> <ul> <li><code>-i, --input PATH</code>: Input network file (required)</li> <li><code>-o, --output PATH</code>: Output figure path</li> <li><code>-l, --layout LAYOUT</code>: Layout algorithm (spring, circular, kamada-kawai)</li> <li><code>--width INTEGER</code>: Figure width in pixels</li> <li><code>--height INTEGER</code>: Figure height in pixels</li> <li><code>--node-size FLOAT</code>: Node size multiplier</li> <li><code>--edge-width FLOAT</code>: Edge width</li> <li><code>--color-by ATTRIBUTE</code>: Color nodes by metadata attribute</li> <li><code>--interactive</code>: Create interactive HTML plot</li> </ul>"},{"location":"guide/cli/#global-options","title":"Global Options","text":"<ul> <li><code>--version</code>: Show version and exit</li> <li><code>--help</code>: Show help message</li> <li><code>-v, --verbose</code>: Enable verbose output</li> <li><code>--quiet</code>: Suppress non-error output</li> </ul>"},{"location":"guide/cli/#input-formats","title":"Input Formats","text":"<p>PyPopART supports multiple sequence formats:</p> <ul> <li>FASTA (<code>.fasta</code>, <code>.fa</code>, <code>.fna</code>)</li> <li>NEXUS (<code>.nex</code>, <code>.nexus</code>)</li> <li>PHYLIP (<code>.phy</code>, <code>.phylip</code>)</li> <li>GenBank (<code>.gb</code>, <code>.genbank</code>)</li> </ul>"},{"location":"guide/cli/#output-formats","title":"Output Formats","text":"<p>Networks can be exported in various formats:</p> <ul> <li>NEXUS - Compatible with PopART and other tools</li> <li>GML - Graph Modeling Language</li> <li>GraphML - XML-based graph format</li> <li>JSON - JavaScript Object Notation</li> </ul>"},{"location":"guide/cli/#working-with-metadata","title":"Working with Metadata","text":"<p>Include metadata in NEXUS format:</p> <pre><code>#NEXUS\nBEGIN TAXA;\n    DIMENSIONS NTAX=4;\n    TAXLABELS Seq1 Seq2 Seq3 Seq4;\nEND;\n\nBEGIN CHARACTERS;\n    DIMENSIONS NCHAR=20;\n    FORMAT DATATYPE=DNA;\n    MATRIX\n        Seq1 ATCGATCGATCGATCGATCG\n        Seq2 ATCGATCGATCGATCGATCG\n        Seq3 ATCGATCGATCGATTGATCG\n        Seq4 ATCGATCGATCGATTGATCG\n    ;\nEND;\n\nBEGIN TRAITS;\n    DIMENSIONS NTRAITS=2;\n    FORMAT LABELS=YES SEPARATOR=,;\n    TRAITLABELS Population Location;\n    MATRIX\n        Seq1 PopA Site1\n        Seq2 PopA Site1\n        Seq3 PopB Site2\n        Seq4 PopB Site2\n    ;\nEND;\n</code></pre> <p>Use metadata for coloring:</p> <pre><code>pypopart plot network.gml --color-by Population -o colored_network.png\n</code></pre>"},{"location":"guide/cli/#scripting-examples","title":"Scripting Examples","text":""},{"location":"guide/cli/#batch-processing","title":"Batch Processing","text":"<p>Process multiple files:</p> <pre><code>for file in *.fasta; do\n    base=$(basename \"$file\" .fasta)\n    pypopart network \"$file\" -a MST -o \"networks/${base}\"\ndone\n</code></pre>"},{"location":"guide/cli/#pipeline-example","title":"Pipeline Example","text":"<p>Complete analysis pipeline:</p> <pre><code># 1. Build network\npypopart network input.fasta -a MJN -o mjn_network -f gml\n\n# 2. Calculate statistics\npypopart stats mjn_network.gml --topology --popgen -o statistics.txt\n\n# 3. Create visualizations\npypopart plot mjn_network.gml -o static_plot.png\npypopart plot mjn_network.gml --interactive -o interactive_plot.html\n</code></pre>"},{"location":"guide/cli/#comparing-algorithms","title":"Comparing Algorithms","text":"<p>Compare different algorithms on the same data:</p> <pre><code>algorithms=(MST MSN TCS MJN)\nfor alg in \"${algorithms[@]}\"; do\n    pypopart network sequences.fasta -a \"$alg\" -o \"comparison/${alg}\"\ndone\n</code></pre>"},{"location":"guide/cli/#tips-and-best-practices","title":"Tips and Best Practices","text":"<ol> <li> <p>Choose the right algorithm: Start with MST for exploration, use TCS for within-species data, MJN for complex scenarios</p> </li> <li> <p>Distance metrics: Use Hamming for very similar sequences, K2P or Tamura-Nei for more divergent data</p> </li> <li> <p>Visualization: Generate both static (for publications) and interactive (for exploration) plots</p> </li> <li> <p>Large datasets: Consider using MST or MSN first before trying computationally intensive algorithms like MJN</p> </li> <li> <p>Metadata: Include population/trait information for richer analyses and visualizations</p> </li> </ol>"},{"location":"guide/cli/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guide/cli/#common-issues","title":"Common Issues","text":"<p>\"No such file or directory\" - Check file paths are correct - Use absolute paths if needed</p> <p>\"Invalid sequence format\" - Verify file format is supported - Check for file corruption - Ensure sequences are aligned</p> <p>\"Algorithm failed to converge\" - Try different algorithm - Check data quality - Adjust algorithm parameters</p>"},{"location":"guide/cli/#next-steps","title":"Next Steps","text":"<ul> <li>Python API Guide: Use PyPopART programmatically</li> <li>Tutorials: Detailed walkthroughs</li> <li>Algorithm Guide: Choose the right algorithm</li> </ul>"},{"location":"guide/distances/","title":"Distance Metrics","text":"<p>Genetic distance measures quantify differences between DNA sequences. Choosing the right metric is crucial for accurate network construction.</p>"},{"location":"guide/distances/#available-metrics","title":"Available Metrics","text":""},{"location":"guide/distances/#hamming-distance","title":"Hamming Distance","text":"<p>Simple count of differing positions between sequences.</p> <p>Formula: Number of sites where sequences differ</p> <p>Example: <pre><code>Seq1: ATCGATCG\nSeq2: ATCGTTCG\n         ^\nDistance: 1\n</code></pre></p> <p>When to use: - Very similar sequences (&lt; 5% divergence) - Initial exploration - No model assumptions needed</p> <p>Python: <pre><code>from pypopart.core.distance import DistanceCalculator\n\ncalc = DistanceCalculator(metric=\"hamming\")\ndistances = calc.calculate(alignment)\n</code></pre></p> <p>CLI: <pre><code>pypopart distance sequences.fasta -m hamming -o distances.csv\n</code></pre></p>"},{"location":"guide/distances/#jukes-cantor-jc69","title":"Jukes-Cantor (JC69)","text":"<p>Corrects for multiple mutations at the same site.</p> <p>Formula: <pre><code>d = -3/4 * ln(1 - 4p/3)\n</code></pre> where p is the proportion of different sites</p> <p>Assumptions: - Equal base frequencies (25% each) - Equal substitution rates - No rate variation</p> <p>When to use: - Moderate divergence (5-20%) - Need model-based correction - Simple correction sufficient</p> <p>Python: <pre><code>calc = DistanceCalculator(metric=\"jukes-cantor\")\ndistances = calc.calculate(alignment)\n</code></pre></p> <p>CLI: <pre><code>pypopart distance sequences.fasta -m jukes-cantor -o distances.csv\n</code></pre></p>"},{"location":"guide/distances/#kimura-2-parameter-k2p","title":"Kimura 2-Parameter (K2P)","text":"<p>Distinguishes between transitions and transversions.</p> <p>Formula: <pre><code>d = -1/2 * ln((1-2P-Q) * sqrt(1-2Q))\n</code></pre> where: - P = transition frequency - Q = transversion frequency</p> <p>Assumptions: - Equal base frequencies - Different rates for transitions vs transversions - No rate variation</p> <p>When to use: - Moderate to high divergence (up to 50%) - Transitions more common than transversions (typical for DNA) - More realistic than Jukes-Cantor</p> <p>Python: <pre><code>calc = DistanceCalculator(metric=\"k2p\")\ndistances = calc.calculate(alignment)\n</code></pre></p> <p>CLI: <pre><code>pypopart distance sequences.fasta -m k2p -o distances.csv\n</code></pre></p>"},{"location":"guide/distances/#tamura-nei","title":"Tamura-Nei","text":"<p>Most sophisticated model with unequal base frequencies.</p> <p>Formula: Accounts for: - Unequal base frequencies - Different transition rates - Transition/transversion ratio - GC content bias</p> <p>Assumptions: - Variable base frequencies - Different rates for transitions vs transversions - Rate variation across sites</p> <p>When to use: - High divergence (&gt; 20%) - Biased base composition - Most accurate correction needed - Sufficient data for parameter estimation</p> <p>Python: <pre><code>calc = DistanceCalculator(metric=\"tamura-nei\")\ndistances = calc.calculate(alignment)\n</code></pre></p> <p>CLI: <pre><code>pypopart distance sequences.fasta -m tamura-nei -o distances.csv\n</code></pre></p>"},{"location":"guide/distances/#choosing-a-metric","title":"Choosing a Metric","text":""},{"location":"guide/distances/#decision-guide","title":"Decision Guide","text":"<pre><code>Start here\n    \u2193\nIs divergence &lt; 5%?\n    YES \u2192 Use Hamming\n    NO \u2192 Continue\n         \u2193\nIs divergence &lt; 20%?\n    YES \u2192 Use Jukes-Cantor or K2P\n    NO \u2192 Continue\n         \u2193\nIs there GC bias?\n    YES \u2192 Use Tamura-Nei\n    NO \u2192 Use K2P\n</code></pre>"},{"location":"guide/distances/#by-divergence-level","title":"By Divergence Level","text":"Divergence Recommended Metric Reason 0-5% Hamming Simple, no saturation 5-20% Jukes-Cantor / K2P Model-based correction 20-50% K2P / Tamura-Nei Accounts for saturation &gt; 50% Tamura-Nei Most sophisticated"},{"location":"guide/distances/#by-data-type","title":"By Data Type","text":"Data Type Recommended Notes Mitochondrial DNA K2P High transition bias Nuclear DNA K2P or Tamura-Nei Variable composition Coding regions K2P Consider codon position Non-coding Tamura-Nei Often GC-biased Microsatellites Hamming Step-wise mutation"},{"location":"guide/distances/#working-with-distance-matrices","title":"Working with Distance Matrices","text":""},{"location":"guide/distances/#calculate-and-save","title":"Calculate and Save","text":"<pre><code>from pypopart.core.distance import DistanceCalculator\n\ncalc = DistanceCalculator(metric=\"k2p\")\ndistances = calc.calculate(alignment)\n\n# Save matrix\ndistances.to_csv(\"distances.csv\")\ndistances.to_numpy(\"distances.npy\")\n</code></pre>"},{"location":"guide/distances/#load-pre-computed-distances","title":"Load Pre-computed Distances","text":"<pre><code>import numpy as np\nfrom pypopart import DistanceMatrix\n\n# Load from file\ndistances = DistanceMatrix.from_csv(\"distances.csv\")\n\n# Use with algorithm\nfrom pypopart.algorithms import MSTAlgorithm\n\nalgorithm = MSTAlgorithm(distance_matrix=distances)\nnetwork = algorithm.build_network(alignment)\n</code></pre>"},{"location":"guide/distances/#inspect-distance-distribution","title":"Inspect Distance Distribution","text":"<pre><code>import matplotlib.pyplot as plt\n\n# Get distance values\nvalues = distances.values()\n\n# Plot histogram\nplt.hist(values, bins=30)\nplt.xlabel(\"Genetic Distance\")\nplt.ylabel(\"Frequency\")\nplt.title(\"Distance Distribution\")\nplt.show()\n\n# Summary statistics\nprint(f\"Min distance: {min(values):.4f}\")\nprint(f\"Max distance: {max(values):.4f}\")\nprint(f\"Mean distance: {np.mean(values):.4f}\")\nprint(f\"Median distance: {np.median(values):.4f}\")\n</code></pre>"},{"location":"guide/distances/#advanced-options","title":"Advanced Options","text":""},{"location":"guide/distances/#custom-distance-functions","title":"Custom Distance Functions","text":"<p>Define your own distance metric:</p> <pre><code>from pypopart.core.distance import BaseDistance\n\nclass CustomDistance(BaseDistance):\n    def calculate_pairwise(self, seq1, seq2):\n        # Your calculation here\n        diff = sum(a != b for a, b in zip(seq1, seq2))\n        # Apply custom correction\n        return diff * custom_factor\n\n# Use custom metric\ncalc = DistanceCalculator(metric=CustomDistance())\ndistances = calc.calculate(alignment)\n</code></pre>"},{"location":"guide/distances/#gap-handling","title":"Gap Handling","text":"<p>Control how gaps are treated:</p> <pre><code>calc = DistanceCalculator(\n    metric=\"k2p\",\n    gap_mode=\"pairwise\"  # 'pairwise', 'complete', 'ignore'\n)\n</code></pre> <p>Options: - <code>pairwise</code>: Remove gap positions for each pair - <code>complete</code>: Remove all sites with any gaps - <code>ignore</code>: Treat gaps as fifth character</p>"},{"location":"guide/distances/#rate-variation","title":"Rate Variation","text":"<p>Account for among-site rate variation:</p> <pre><code>calc = DistanceCalculator(\n    metric=\"k2p\",\n    gamma=True,       # Use gamma distribution\n    alpha=0.5         # Shape parameter\n)\n</code></pre>"},{"location":"guide/distances/#validation-and-diagnostics","title":"Validation and Diagnostics","text":""},{"location":"guide/distances/#check-for-saturation","title":"Check for Saturation","text":"<pre><code># Plot uncorrected vs corrected distances\nhamming_calc = DistanceCalculator(metric=\"hamming\")\nk2p_calc = DistanceCalculator(metric=\"k2p\")\n\nhamming_dist = hamming_calc.calculate(alignment)\nk2p_dist = k2p_calc.calculate(alignment)\n\n# If K2P &gt;&gt; Hamming, saturation is present\nratio = k2p_dist.mean() / hamming_dist.mean()\nif ratio &gt; 1.5:\n    print(\"Warning: Significant saturation detected\")\n</code></pre>"},{"location":"guide/distances/#compare-metrics","title":"Compare Metrics","text":"<pre><code>metrics = [\"hamming\", \"jukes-cantor\", \"k2p\", \"tamura-nei\"]\nresults = {}\n\nfor metric in metrics:\n    calc = DistanceCalculator(metric=metric)\n    dist = calc.calculate(alignment)\n    results[metric] = dist.mean()\n\nprint(\"Mean distances by metric:\")\nfor metric, mean_dist in results.items():\n    print(f\"  {metric}: {mean_dist:.4f}\")\n</code></pre>"},{"location":"guide/distances/#performance-considerations","title":"Performance Considerations","text":""},{"location":"guide/distances/#speed-vs-accuracy","title":"Speed vs Accuracy","text":"Metric Speed Accuracy Use Case Hamming Fastest Basic Exploration, low divergence Jukes-Cantor Fast Good Moderate divergence K2P Moderate Better General purpose Tamura-Nei Slower Best High divergence, final analysis"},{"location":"guide/distances/#optimization-tips","title":"Optimization Tips","text":"<pre><code># For large datasets\ncalc = DistanceCalculator(\n    metric=\"k2p\",\n    parallel=True,      # Use multiprocessing\n    n_jobs=4            # Number of cores\n)\n\n# Cache results\ncalc.calculate(alignment, cache=True)\n</code></pre>"},{"location":"guide/distances/#common-issues","title":"Common Issues","text":""},{"location":"guide/distances/#distance-10","title":"\"Distance &gt; 1.0\"","text":"<p>Some corrected distances can exceed 1.0 for highly divergent sequences: - Expected for K2P and Tamura-Nei - Indicates high divergence - Consider if sequences are too divergent for network analysis</p>"},{"location":"guide/distances/#negative-distance","title":"\"Negative distance\"","text":"<p>Rare numerical issue with some corrections: - Check for data quality issues - Try simpler metric - May indicate sequences are too divergent</p>"},{"location":"guide/distances/#nan-values","title":"\"NaN values\"","text":"<p>Usually caused by: - All gaps in pairwise comparison - Identical sequences (distance = 0) - Numerical underflow in calculations</p>"},{"location":"guide/distances/#best-practices","title":"Best Practices","text":"<ol> <li>Start simple: Use Hamming for exploration</li> <li>Match divergence: Choose metric appropriate for your data</li> <li>Check assumptions: Verify metric assumptions match your data</li> <li>Validate results: Compare with multiple metrics</li> <li>Document choice: Report which metric and why in publications</li> </ol>"},{"location":"guide/distances/#references","title":"References","text":"<ul> <li>Jukes TH, Cantor CR (1969). Evolution of protein molecules</li> <li>Kimura M (1980). A simple method for estimating evolutionary rates</li> <li>Tamura K, Nei M (1993). Estimation of the number of nucleotide substitutions</li> </ul>"},{"location":"guide/distances/#next-steps","title":"Next Steps","text":"<ul> <li>Algorithm Guide: Choose network algorithm</li> <li>Visualization Guide: Plot results</li> <li>API Reference: Distance API documentation</li> </ul>"},{"location":"guide/loading_data/","title":"Loading Data","text":"<p>PyPopART supports multiple sequence file formats and provides flexible data loading options.</p>"},{"location":"guide/loading_data/#supported-formats","title":"Supported Formats","text":""},{"location":"guide/loading_data/#fasta-format","title":"FASTA Format","text":"<p>The most common sequence format:</p> <pre><code>&gt;Sequence1_PopA\nATCGATCGATCGATCGATCG\n&gt;Sequence2_PopA\nATCGATCGATCGATCGATCG\n&gt;Sequence3_PopB\nATCGATCGATCGATTGATCG\n</code></pre> <p>Load in Python: <pre><code>from pypopart import Alignment\nalignment = Alignment.from_fasta(\"sequences.fasta\")\n</code></pre></p> <p>CLI: <pre><code>pypopart network sequences.fasta -a MST -o output\n</code></pre></p>"},{"location":"guide/loading_data/#nexus-format","title":"NEXUS Format","text":"<p>Supports metadata and traits:</p> <pre><code>#NEXUS\nBEGIN TAXA;\n    DIMENSIONS NTAX=3;\n    TAXLABELS Seq1 Seq2 Seq3;\nEND;\n\nBEGIN CHARACTERS;\n    DIMENSIONS NCHAR=20;\n    FORMAT DATATYPE=DNA MISSING=? GAP=-;\n    MATRIX\n        Seq1 ATCGATCGATCGATCGATCG\n        Seq2 ATCGATCGATCGATCGATCG\n        Seq3 ATCGATCGATCGATTGATCG\n    ;\nEND;\n\nBEGIN TRAITS;\n    DIMENSIONS NTRAITS=2;\n    FORMAT LABELS=YES SEPARATOR=,;\n    TRAITLABELS Population Location;\n    MATRIX\n        Seq1 PopA Site1\n        Seq2 PopA Site1\n        Seq3 PopB Site2\n    ;\nEND;\n</code></pre> <p>Load in Python: <pre><code>alignment = Alignment.from_nexus(\"sequences.nex\")\nmetadata = alignment.get_metadata()\n</code></pre></p>"},{"location":"guide/loading_data/#phylip-format","title":"PHYLIP Format","text":"<p>Sequential or interleaved:</p> <pre><code>3 20\nSeq1      ATCGATCGATCGATCGATCG\nSeq2      ATCGATCGATCGATCGATCG\nSeq3      ATCGATCGATCGATTGATCG\n</code></pre> <p>Load in Python: <pre><code>alignment = Alignment.from_phylip(\"sequences.phy\")\n</code></pre></p>"},{"location":"guide/loading_data/#genbank-format","title":"GenBank Format","text":"<p>Full GenBank entries:</p> <pre><code>alignment = Alignment.from_genbank(\"sequences.gb\")\n</code></pre>"},{"location":"guide/loading_data/#working-with-metadata","title":"Working with Metadata","text":""},{"location":"guide/loading_data/#including-metadata","title":"Including Metadata","text":"<p>Metadata can encode population, location, time, or custom traits:</p> <p>Method 1: NEXUS Traits Block <pre><code># Automatically loaded from NEXUS file\nalignment = Alignment.from_nexus(\"sequences_with_traits.nex\")\nprint(alignment.metadata)\n</code></pre></p> <p>Method 2: Add Programmatically <pre><code>import pandas as pd\n\n# Load sequences\nalignment = Alignment.from_fasta(\"sequences.fasta\")\n\n# Add metadata\nmetadata = pd.DataFrame({\n    'sequence_id': ['Seq1', 'Seq2', 'Seq3'],\n    'Population': ['PopA', 'PopA', 'PopB'],\n    'Location': ['Site1', 'Site1', 'Site2'],\n    'Year': [2020, 2020, 2021]\n})\n\nalignment.set_metadata(metadata)\n</code></pre></p> <p>Method 3: Parse from Sequence Names <pre><code># If names are like: \"Sample1_PopA_Site1\"\nalignment = Alignment.from_fasta(\"sequences.fasta\")\nalignment.parse_names(\n    pattern=r\"(?P&lt;sample&gt;\\w+)_(?P&lt;population&gt;\\w+)_(?P&lt;location&gt;\\w+)\"\n)\n</code></pre></p>"},{"location":"guide/loading_data/#using-metadata-for-analysis","title":"Using Metadata for Analysis","text":"<pre><code># Color networks by metadata\nfrom pypopart.visualization import StaticPlot\n\nplot = StaticPlot(network)\nplot.color_by_attribute(\"Population\")\nplot.save(\"colored_network.png\")\n\n# Calculate population statistics\nfrom pypopart.stats import PopulationGenetics\n\npopgen = PopulationGenetics(alignment)\nfst = popgen.calculate_fst(population_column='Population')\n</code></pre>"},{"location":"guide/loading_data/#data-validation","title":"Data Validation","text":""},{"location":"guide/loading_data/#check-alignment-quality","title":"Check Alignment Quality","text":"<pre><code># Verify alignment\nprint(f\"Number of sequences: {len(alignment)}\")\nprint(f\"Alignment length: {alignment.length}\")\nprint(f\"Valid alignment: {alignment.is_valid()}\")\n\n# Check for gaps\nif alignment.has_gaps():\n    print(\"Warning: Alignment contains gaps\")\n\n# Check for ambiguous bases\nif alignment.has_ambiguous():\n    print(\"Warning: Alignment contains ambiguous bases\")\n</code></pre>"},{"location":"guide/loading_data/#handle-missing-data","title":"Handle Missing Data","text":"<pre><code># Remove sequences with excessive gaps\nalignment = alignment.filter_by_gaps(max_gap_fraction=0.1)\n\n# Remove columns with excessive missing data\nalignment = alignment.filter_columns(max_missing=0.2)\n\n# Remove invariant sites\nalignment = alignment.remove_invariant_sites()\n</code></pre>"},{"location":"guide/loading_data/#file-format-detection","title":"File Format Detection","text":"<p>PyPopART can auto-detect formats:</p> <pre><code># Auto-detect format\nalignment = Alignment.from_file(\"sequences.unknown\")\n</code></pre> <p>Or explicitly specify:</p> <pre><code>alignment = Alignment.from_file(\"sequences.txt\", format=\"fasta\")\n</code></pre>"},{"location":"guide/loading_data/#large-files","title":"Large Files","text":""},{"location":"guide/loading_data/#streaming-data","title":"Streaming Data","text":"<p>For very large files:</p> <pre><code># Process in chunks\nfor chunk in Alignment.read_chunks(\"large_file.fasta\", chunk_size=1000):\n    # Process each chunk\n    network = algorithm.build_network(chunk)\n</code></pre>"},{"location":"guide/loading_data/#memory-optimization","title":"Memory Optimization","text":"<pre><code># Disable unnecessary features\nalignment = Alignment.from_fasta(\n    \"sequences.fasta\",\n    load_metadata=False,\n    compute_stats=False\n)\n</code></pre>"},{"location":"guide/loading_data/#biopython-integration","title":"BioPython Integration","text":"<p>Convert between PyPopART and BioPython:</p> <pre><code>from Bio import AlignIO\nfrom pypopart import Alignment\n\n# BioPython to PyPopART\nbio_aln = AlignIO.read(\"sequences.fasta\", \"fasta\")\npp_aln = Alignment.from_biopython(bio_aln)\n\n# PyPopART to BioPython\nbio_aln = pp_aln.to_biopython()\nAlignIO.write(bio_aln, \"output.fasta\", \"fasta\")\n</code></pre>"},{"location":"guide/loading_data/#data-requirements","title":"Data Requirements","text":""},{"location":"guide/loading_data/#sequence-data","title":"Sequence Data","text":"<ul> <li>Aligned sequences: All sequences must be the same length</li> <li>DNA/Protein: PyPopART handles both (specify datatype if needed)</li> <li>No special characters:\u9664 standard IUPAC codes</li> </ul>"},{"location":"guide/loading_data/#metadata-optional","title":"Metadata (Optional)","text":"<ul> <li>Categorical traits: Population, location, phenotype</li> <li>Numerical traits: Year, coordinates, measurements</li> <li>Missing values: Use 'NA', '?', or leave blank</li> </ul>"},{"location":"guide/loading_data/#example-datasets","title":"Example Datasets","text":"<p>PyPopART includes example datasets:</p> <pre><code>from pypopart.data import load_example\n\n# Load example data\nalignment = load_example(\"woodmouse\")\nalignment = load_example(\"influenza\")\nalignment = load_example(\"mtdna\")\n\n# Get example file path\npath = load_example(\"woodmouse\", return_path=True)\n</code></pre>"},{"location":"guide/loading_data/#tips-for-data-preparation","title":"Tips for Data Preparation","text":"<ol> <li>Use aligned sequences: Run alignment tools first (MUSCLE, MAFFT, Clustal)</li> <li>Include metadata: Enriches analysis and visualization</li> <li>Check quality: Remove poor quality sequences</li> <li>Remove duplicates: PyPopART will collapse identical sequences</li> <li>Consistent naming: Use systematic sequence names</li> <li>Check encoding: Ensure UTF-8 encoding for special characters</li> </ol>"},{"location":"guide/loading_data/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guide/loading_data/#common-errors","title":"Common Errors","text":"<p>\"Sequences not aligned\" - All sequences must be same length - Align sequences before loading</p> <p>\"Invalid NEXUS format\" - Check NEXUS syntax - Ensure all blocks are properly closed</p> <p>\"Cannot parse metadata\" - Check trait names match sequence IDs - Verify separator (comma, tab, space)</p> <p>\"Memory error\" - File too large - Use streaming or chunking - Filter data first</p>"},{"location":"guide/loading_data/#next-steps","title":"Next Steps","text":"<ul> <li>Distance Metrics Guide: Choose appropriate distance</li> <li>Algorithm Guide: Select network algorithm</li> <li>Visualization Guide: Plot your networks</li> </ul>"},{"location":"guide/visualization/","title":"Visualization Guide","text":"<p>PyPopART provides multiple visualization options for creating publication-quality figures and interactive explorations.</p>"},{"location":"guide/visualization/#visualization-types","title":"Visualization Types","text":""},{"location":"guide/visualization/#static-plots","title":"Static Plots","text":"<ul> <li>Format: PNG, PDF, SVG</li> <li>Use: Publications, presentations, reports</li> <li>Library: Matplotlib</li> <li>Customization: High</li> </ul>"},{"location":"guide/visualization/#interactive-plots","title":"Interactive Plots","text":"<ul> <li>Format: HTML</li> <li>Use: Exploration, web embedding</li> <li>Library: Plotly</li> <li>Features: Zoom, pan, hover, click</li> </ul>"},{"location":"guide/visualization/#gui-dashboard","title":"GUI Dashboard","text":"<ul> <li>Format: Web application</li> <li>Use: Interactive analysis</li> <li>Library: Dash + Cytoscape</li> <li>Features: Real-time updates, full control</li> </ul>"},{"location":"guide/visualization/#static-visualization","title":"Static Visualization","text":""},{"location":"guide/visualization/#basic-plot","title":"Basic Plot","text":"<pre><code>from pypopart.visualization import StaticPlot\n\nplot = StaticPlot(network)\nplot.save(\"network.png\")\n</code></pre> <p>CLI: <pre><code>pypopart plot network.gml -o figure.png\n</code></pre></p>"},{"location":"guide/visualization/#customization","title":"Customization","text":"<pre><code>plot = StaticPlot(\n    network,\n    figsize=(12, 10),      # Figure size in inches\n    dpi=300,               # Resolution\n    layout=\"spring\",       # Layout algorithm\n    node_size=500,         # Base node size\n    node_color=\"#1f78b4\", # Default node color\n    edge_width=2.0,        # Edge width\n    edge_color=\"#888888\",  # Edge color\n    font_size=10,          # Label font size\n    show_labels=True,      # Show node labels\n    title=\"Haplotype Network\"\n)\nplot.save(\"custom_network.png\")\n</code></pre>"},{"location":"guide/visualization/#output-formats","title":"Output Formats","text":"<pre><code># PNG (raster)\nplot.save(\"network.png\", format=\"png\", dpi=300)\n\n# PDF (vector, best for publications)\nplot.save(\"network.pdf\", format=\"pdf\")\n\n# SVG (vector, editable)\nplot.save(\"network.svg\", format=\"svg\")\n\n# EPS (vector, legacy journals)\nplot.save(\"network.eps\", format=\"eps\")\n</code></pre>"},{"location":"guide/visualization/#layout-algorithms","title":"Layout Algorithms","text":"<pre><code># Spring layout (force-directed)\nplot = StaticPlot(network, layout=\"spring\")\n\n# Circular layout\nplot = StaticPlot(network, layout=\"circular\")\n\n# Kamada-Kawai (energy minimization)\nplot = StaticPlot(network, layout=\"kamada-kawai\")\n\n# Spectral layout (eigenvalue-based)\nplot = StaticPlot(network, layout=\"spectral\")\n\n# Custom positions\npositions = {node: (x, y) for node, x, y in ...}\nplot = StaticPlot(network, positions=positions)\n</code></pre>"},{"location":"guide/visualization/#coloring-by-metadata","title":"Coloring by Metadata","text":"<pre><code># Color by population\nplot = StaticPlot(network)\nplot.color_by_attribute(\"Population\")\nplot.save(\"colored_network.png\")\n\n# Custom color map\ncolor_map = {\"PopA\": \"#ff0000\", \"PopB\": \"#0000ff\"}\nplot.color_by_attribute(\"Population\", color_map=color_map)\n\n# Continuous values\nplot.color_by_attribute(\"Year\", cmap=\"viridis\")\n</code></pre>"},{"location":"guide/visualization/#node-sizing","title":"Node Sizing","text":"<pre><code># Size by frequency\nplot = StaticPlot(network, size_by=\"frequency\", node_size=50)\n\n# Size by custom attribute\nplot.size_by_attribute(\"SampleSize\", min_size=100, max_size=1000)\n\n# Fixed sizes\nplot = StaticPlot(network, node_size=300)\n</code></pre>"},{"location":"guide/visualization/#edge-styling","title":"Edge Styling","text":"<pre><code># Edge width by distance\nplot = StaticPlot(network)\nplot.edge_width_by_distance(min_width=0.5, max_width=5.0)\n\n# Edge color by type\nplot.set_edge_colors({\"observed\": \"#000000\", \"inferred\": \"#888888\"})\n\n# Dashed edges for inferred connections\nplot.style_inferred_edges(style=\"dashed\", alpha=0.5)\n</code></pre>"},{"location":"guide/visualization/#interactive-visualization","title":"Interactive Visualization","text":""},{"location":"guide/visualization/#basic-interactive-plot","title":"Basic Interactive Plot","text":"<pre><code>from pypopart.visualization import InteractivePlot\n\nplot = InteractivePlot(network)\nplot.save(\"network.html\")\n</code></pre> <p>Open <code>network.html</code> in a browser for interactive exploration.</p>"},{"location":"guide/visualization/#features","title":"Features","text":"<ul> <li>Hover: View node/edge details</li> <li>Click: Select nodes</li> <li>Zoom: Scroll to zoom</li> <li>Pan: Drag to pan</li> <li>Export: Save as PNG from browser</li> </ul>"},{"location":"guide/visualization/#customization_1","title":"Customization","text":"<pre><code>plot = InteractivePlot(\n    network,\n    layout=\"spring\",\n    title=\"Interactive Haplotype Network\",\n    width=1200,\n    height=800,\n    node_size_by=\"frequency\",\n    color_by=\"Population\",\n    show_edge_labels=True,\n    hover_data=[\"Population\", \"Location\", \"Year\"]\n)\nplot.save(\"interactive_network.html\")\n</code></pre>"},{"location":"guide/visualization/#embedding-in-web-pages","title":"Embedding in Web Pages","text":"<pre><code>&lt;iframe src=\"network.html\" width=\"100%\" height=\"600px\"&gt;&lt;/iframe&gt;\n</code></pre> <p>Or use the HTML directly: <pre><code>html_string = plot.to_html()\n# Insert into your web application\n</code></pre></p>"},{"location":"guide/visualization/#gui-dashboard_1","title":"GUI Dashboard","text":""},{"location":"guide/visualization/#launch-gui","title":"Launch GUI","text":"<pre><code>pypopart-gui\n</code></pre> <p>Navigate to <code>http://localhost:8050</code></p>"},{"location":"guide/visualization/#features_1","title":"Features","text":"<ol> <li>File Upload: Drag-and-drop sequence files</li> <li>Algorithm Selection: Choose and configure algorithm</li> <li>Network Computation: Real-time building</li> <li>Layout Adjustment: Interactive layout control</li> <li>Visual Customization: Colors, sizes, labels</li> <li>Metadata Integration: Color by traits</li> <li>Export: Save networks and figures</li> <li>Statistics: View network properties</li> </ol>"},{"location":"guide/visualization/#programmatic-gui","title":"Programmatic GUI","text":"<pre><code>from pypopart.gui import NetworkDashboard\n\ndashboard = NetworkDashboard(\n    network=network,\n    alignment=alignment,\n    port=8050\n)\ndashboard.run()\n</code></pre>"},{"location":"guide/visualization/#advanced-visualization","title":"Advanced Visualization","text":""},{"location":"guide/visualization/#multiple-networks-side-by-side","title":"Multiple Networks Side-by-Side","text":"<pre><code>import matplotlib.pyplot as plt\nfrom pypopart.visualization import StaticPlot\n\nfig, axes = plt.subplots(1, 3, figsize=(18, 6))\n\nalgorithms = [\"MST\", \"MSN\", \"MJN\"]\nfor ax, name, net in zip(axes, algorithms, networks):\n    plot = StaticPlot(net, ax=ax)\n    ax.set_title(name)\n\nplt.tight_layout()\nplt.savefig(\"comparison.png\", dpi=300)\n</code></pre>"},{"location":"guide/visualization/#subnetwork-visualization","title":"Subnetwork Visualization","text":"<pre><code># Extract subnetwork (e.g., one population)\nsubnetwork = network.subgraph(\n    [n for n in network.nodes() if network.nodes[n].get(\"Population\") == \"PopA\"]\n)\n\nplot = StaticPlot(subnetwork)\nplot.save(\"subnetwork.png\")\n</code></pre>"},{"location":"guide/visualization/#time-series-animation","title":"Time Series Animation","text":"<pre><code>from pypopart.visualization import NetworkAnimation\n\n# Create animation showing network growth over time\nanim = NetworkAnimation(networks_by_year)\nanim.save(\"network_evolution.gif\")\n</code></pre>"},{"location":"guide/visualization/#geographic-overlay","title":"Geographic Overlay","text":"<pre><code>import geopandas as gpd\nfrom pypopart.visualization import GeographicPlot\n\n# Plot network on map (requires coordinates in metadata)\ngeoplot = GeographicPlot(network, basemap=\"world\")\ngeoplot.save(\"geographic_network.png\")\n</code></pre>"},{"location":"guide/visualization/#styling-tips","title":"Styling Tips","text":""},{"location":"guide/visualization/#publication-quality-figures","title":"Publication-Quality Figures","text":"<pre><code>import matplotlib.pyplot as plt\n\nplt.rcParams.update({\n    'font.size': 12,\n    'font.family': 'Arial',\n    'axes.linewidth': 1.5,\n    'xtick.major.width': 1.5,\n    'ytick.major.width': 1.5,\n})\n\nplot = StaticPlot(\n    network,\n    figsize=(8, 8),\n    dpi=300,\n    node_size=400,\n    edge_width=1.5,\n    font_size=11,\n)\nplot.save(\"publication_figure.pdf\")\n</code></pre>"},{"location":"guide/visualization/#color-schemes","title":"Color Schemes","text":"<pre><code># Colorblind-friendly palettes\nfrom pypopart.visualization.colors import colorblind_safe\n\nplot.color_by_attribute(\"Population\", colors=colorblind_safe)\n\n# Sequential for continuous data\nplot.color_by_attribute(\"Year\", cmap=\"Blues\")\n\n# Diverging for deviation from mean\nplot.color_by_attribute(\"Diversity\", cmap=\"RdBu\")\n</code></pre>"},{"location":"guide/visualization/#legends-and-annotations","title":"Legends and Annotations","text":"<pre><code># Add legend\nplot.add_legend(title=\"Population\", loc=\"upper right\")\n\n# Add scale bar\nplot.add_scale_bar(mutations_per_unit=1)\n\n# Annotate specific nodes\nplot.annotate_node(\"Haplotype_1\", \"Ancestral\", \n                   fontsize=12, color=\"red\")\n\n# Add text box\nplot.add_textbox(\"MST Algorithm\\nK2P Distance\", \n                 position=(0.05, 0.95))\n</code></pre>"},{"location":"guide/visualization/#export-for-external-tools","title":"Export for External Tools","text":""},{"location":"guide/visualization/#export-for-gephi","title":"Export for Gephi","text":"<pre><code># Save as GEXF\nnetwork.save(\"network.gexf\")\n# Open in Gephi for advanced visualization\n</code></pre>"},{"location":"guide/visualization/#export-for-cytoscape","title":"Export for Cytoscape","text":"<pre><code># Save as GraphML\nnetwork.save(\"network.graphml\")\n# Import into Cytoscape\n</code></pre>"},{"location":"guide/visualization/#export-for-rigraph","title":"Export for R/igraph","text":"<pre><code># Save as GML\nnetwork.save(\"network.gml\")\n</code></pre> <p>R code: <pre><code>library(igraph)\nnetwork &lt;- read_graph(\"network.gml\", format=\"gml\")\nplot(network)\n</code></pre></p>"},{"location":"guide/visualization/#performance-optimization","title":"Performance Optimization","text":""},{"location":"guide/visualization/#large-networks","title":"Large Networks","text":"<pre><code># Reduce complexity for large networks\nplot = StaticPlot(\n    network,\n    show_labels=False,      # Disable labels\n    edge_width=0.5,         # Thin edges\n    simplify_edges=True     # Merge parallel edges\n)\n</code></pre>"},{"location":"guide/visualization/#batch-export","title":"Batch Export","text":"<pre><code># Export multiple visualizations efficiently\nlayouts = [\"spring\", \"circular\", \"kamada-kawai\"]\n\nfor layout in layouts:\n    plot = StaticPlot(network, layout=layout)\n    plot.save(f\"network_{layout}.png\")\n</code></pre>"},{"location":"guide/visualization/#common-customizations","title":"Common Customizations","text":""},{"location":"guide/visualization/#highlight-specific-nodes","title":"Highlight Specific Nodes","text":"<pre><code>highlight_nodes = [\"H1\", \"H2\", \"H5\"]\nplot = StaticPlot(network)\nplot.highlight_nodes(\n    highlight_nodes,\n    color=\"#ff0000\",\n    size=800,\n    edge_color=\"#ff0000\",\n    edge_width=3\n)\n</code></pre>"},{"location":"guide/visualization/#two-color-network","title":"Two-Color Network","text":"<pre><code># Example: Mark ingroup vs outgroup\ningroup = [n for n in network.nodes() if network.nodes[n][\"group\"] == \"ingroup\"]\noutgroup = [n for n in network.nodes() if network.nodes[n][\"group\"] == \"outgroup\"]\n\nplot = StaticPlot(network)\nplot.color_nodes(ingroup, \"#1f78b4\")\nplot.color_nodes(outgroup, \"#ff7f00\")\n</code></pre>"},{"location":"guide/visualization/#median-vector-styling","title":"Median Vector Styling","text":"<pre><code># Different style for median vectors (MJN)\nobserved = [n for n in network.nodes() if network.nodes[n][\"type\"] == \"observed\"]\nmedian = [n for n in network.nodes() if network.nodes[n][\"type\"] == \"median\"]\n\nplot = StaticPlot(network)\nplot.style_nodes(observed, shape=\"o\", color=\"#1f78b4\")\nplot.style_nodes(median, shape=\"s\", color=\"#ff7f00\", size=200)\n</code></pre>"},{"location":"guide/visualization/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guide/visualization/#figure-too-small","title":"\"Figure too small\"","text":"<p>\u2192 Increase <code>figsize</code> and <code>dpi</code></p>"},{"location":"guide/visualization/#overlapping-nodes","title":"\"Overlapping nodes\"","text":"<p>\u2192 Try different layout algorithm or increase figure size</p>"},{"location":"guide/visualization/#labels-unreadable","title":"\"Labels unreadable\"","text":"<p>\u2192 Increase <code>font_size</code> or disable labels</p>"},{"location":"guide/visualization/#colors-not-distinct","title":"\"Colors not distinct\"","text":"<p>\u2192 Use fewer categories or colorblind-safe palette</p>"},{"location":"guide/visualization/#file-too-large","title":"\"File too large\"","text":"<p>\u2192 Use vector format (PDF/SVG) or reduce DPI</p>"},{"location":"guide/visualization/#next-steps","title":"Next Steps","text":"<ul> <li>Analysis Guide: Analyze network properties</li> <li>Tutorials: Detailed examples</li> <li>API Reference: Complete API</li> </ul>"},{"location":"tutorials/algorithm_comparison/","title":"Algorithm Comparison Tutorial","text":"<p>Learn how to compare different network algorithms and choose the best one for your data.</p>"},{"location":"tutorials/algorithm_comparison/#overview","title":"Overview","text":"<p>We'll compare MST, MSN, TCS, and MJN algorithms on the same dataset to understand their differences.</p>"},{"location":"tutorials/algorithm_comparison/#setup","title":"Setup","text":"<pre><code>from pypopart import Alignment\nfrom pypopart.algorithms import MSTAlgorithm, MSNAlgorithm, TCSAlgorithm, MJNAlgorithm\nfrom pypopart.visualization import StaticPlot\nfrom pypopart.stats import NetworkStatistics\nimport matplotlib.pyplot as plt\n\n# Load data\nalignment = Alignment.from_fasta(\"sequences.fasta\")\n</code></pre>"},{"location":"tutorials/algorithm_comparison/#build-networks-with-all-algorithms","title":"Build Networks with All Algorithms","text":"<pre><code>algorithms = {\n    \"MST\": MSTAlgorithm(),\n    \"MSN\": MSNAlgorithm(),\n    \"TCS\": TCSAlgorithm(epsilon=0.95),\n    \"MJN\": MJNAlgorithm(),\n}\n\nnetworks = {}\nfor name, algorithm in algorithms.items():\n    print(f\"Building {name} network...\")\n    networks[name] = algorithm.build_network(alignment)\n    n_nodes = networks[name].number_of_nodes()\n    n_edges = networks[name].number_of_edges()\n    print(f\"  {name}: {n_nodes} nodes, {n_edges} edges\")\n</code></pre>"},{"location":"tutorials/algorithm_comparison/#compare-network-properties","title":"Compare Network Properties","text":"<pre><code>import pandas as pd\n\n# Collect statistics\nresults = []\nfor name, network in networks.items():\n    stats = NetworkStatistics(network)\n    results.append({\n        \"Algorithm\": name,\n        \"Nodes\": stats.number_of_nodes(),\n        \"Edges\": stats.number_of_edges(),\n        \"Diameter\": stats.diameter(),\n        \"Avg Path Length\": stats.average_path_length(),\n        \"Clustering\": stats.clustering_coefficient(),\n    })\n\n# Create comparison table\ndf = pd.DataFrame(results)\nprint(\"\\nNetwork Comparison:\")\nprint(df.to_string(index=False))\n\n# Save table\ndf.to_csv(\"algorithm_comparison.csv\", index=False)\n</code></pre>"},{"location":"tutorials/algorithm_comparison/#visualize-side-by-side","title":"Visualize Side-by-Side","text":"<pre><code>fig, axes = plt.subplots(2, 2, figsize=(16, 16))\naxes = axes.flatten()\n\nfor idx, (name, network) in enumerate(networks.items()):\n    plot = StaticPlot(network, ax=axes[idx], layout=\"spring\")\n    axes[idx].set_title(f\"{name} Network\", fontsize=16, fontweight='bold')\n\nplt.tight_layout()\nplt.savefig(\"algorithm_comparison.png\", dpi=300)\nprint(\"\\nComparison figure saved!\")\n</code></pre>"},{"location":"tutorials/algorithm_comparison/#analyze-differences","title":"Analyze Differences","text":"<pre><code># Compare node sets\nmst_nodes = set(networks[\"MST\"].nodes())\nmjn_nodes = set(networks[\"MJN\"].nodes())\n\n# Median vectors (inferred nodes) in MJN\ninferred = mjn_nodes - mst_nodes\nprint(f\"\\nMJN inferred {len(inferred)} median vectors\")\n\n# Compare connectivity\nfor name, network in networks.items():\n    density = NetworkStatistics(network).density()\n    print(f\"{name} density: {density:.3f}\")\n</code></pre>"},{"location":"tutorials/algorithm_comparison/#decision-guide","title":"Decision Guide","text":"<pre><code>def recommend_algorithm(alignment):\n    \"\"\"Suggest best algorithm based on data characteristics.\"\"\"\n    n_seqs = len(alignment)\n    diversity = alignment.pairwise_diversity()\n\n    if n_seqs &lt; 20:\n        return \"MST - Small dataset, start simple\"\n    elif diversity &lt; 0.01:\n        return \"TCS - Low diversity, within-species\"\n    elif n_seqs &lt; 100:\n        return \"MJN - Medium dataset, comprehensive analysis\"\n    else:\n        return \"MSN - Large dataset, balance speed and information\"\n\nrecommendation = recommend_algorithm(alignment)\nprint(f\"\\nRecommendation: {recommendation}\")\n</code></pre>"},{"location":"tutorials/algorithm_comparison/#computational-performance","title":"Computational Performance","text":"<pre><code>import time\n\ntimes = {}\nfor name, algorithm in algorithms.items():\n    start = time.time()\n    algorithm.build_network(alignment)\n    elapsed = time.time() - start\n    times[name] = elapsed\n    print(f\"{name}: {elapsed:.3f} seconds\")\n\n# Plot timing\nplt.figure(figsize=(8, 6))\nplt.bar(times.keys(), times.values())\nplt.xlabel(\"Algorithm\")\nplt.ylabel(\"Time (seconds)\")\nplt.title(\"Computational Performance\")\nplt.savefig(\"algorithm_timing.png\", dpi=300)\n</code></pre>"},{"location":"tutorials/algorithm_comparison/#complete-comparison-script","title":"Complete Comparison Script","text":"<pre><code>from pypopart import Alignment\nfrom pypopart.algorithms import MSTAlgorithm, MSNAlgorithm, TCSAlgorithm, MJNAlgorithm\nfrom pypopart.visualization import StaticPlot\nfrom pypopart.stats import NetworkStatistics\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport time\n\n# Load data\nalignment = Alignment.from_fasta(\"sequences.fasta\")\n\n# Define algorithms\nalgorithms = {\n    \"MST\": MSTAlgorithm(),\n    \"MSN\": MSNAlgorithm(),\n    \"TCS\": TCSAlgorithm(),\n    \"MJN\": MJNAlgorithm(),\n}\n\n# Build and time networks\nnetworks = {}\ntimes = {}\nresults = []\n\nfor name, algorithm in algorithms.items():\n    start = time.time()\n    networks[name] = algorithm.build_network(alignment)\n    times[name] = time.time() - start\n\n    stats = NetworkStatistics(networks[name])\n    results.append({\n        \"Algorithm\": name,\n        \"Nodes\": stats.number_of_nodes(),\n        \"Edges\": stats.number_of_edges(),\n        \"Time (s)\": f\"{times[name]:.3f}\",\n    })\n\n# Print comparison\ndf = pd.DataFrame(results)\nprint(df.to_string(index=False))\n\n# Create visualizations\nfig, axes = plt.subplots(2, 2, figsize=(16, 16))\naxes = axes.flatten()\n\nfor idx, (name, network) in enumerate(networks.items()):\n    StaticPlot(network, ax=axes[idx], layout=\"spring\")\n    axes[idx].set_title(f\"{name} - {times[name]:.2f}s\")\n\nplt.tight_layout()\nplt.savefig(\"algorithm_comparison.png\", dpi=300)\nprint(\"Comparison complete!\")\n</code></pre>"},{"location":"tutorials/algorithm_comparison/#when-to-use-each-algorithm","title":"When to Use Each Algorithm","text":""},{"location":"tutorials/algorithm_comparison/#mst","title":"MST","text":"<ul> <li>\u2705 Quick exploration</li> <li>\u2705 Small datasets</li> <li>\u2705 Simple relationships</li> <li>\u274c Ignores alternative paths</li> </ul>"},{"location":"tutorials/algorithm_comparison/#msn","title":"MSN","text":"<ul> <li>\u2705 Alternative connections</li> <li>\u2705 Medium datasets</li> <li>\u2705 Ambiguous relationships</li> <li>\u274c Less complete than MJN</li> </ul>"},{"location":"tutorials/algorithm_comparison/#tcs","title":"TCS","text":"<ul> <li>\u2705 Within-species data</li> <li>\u2705 Statistical justification</li> <li>\u2705 Population studies</li> <li>\u274c May be disconnected</li> </ul>"},{"location":"tutorials/algorithm_comparison/#mjn","title":"MJN","text":"<ul> <li>\u2705 Comprehensive analysis</li> <li>\u2705 Ancestral inference</li> <li>\u2705 Publication figures</li> <li>\u274c Slower computation</li> <li>\u274c Complex interpretation</li> </ul>"},{"location":"tutorials/algorithm_comparison/#next-steps","title":"Next Steps","text":"<ul> <li>Basic Workflow: Complete analysis tutorial</li> <li>Visualization Tutorial: Advanced plotting</li> <li>Algorithm Guide: Detailed documentation</li> </ul>"},{"location":"tutorials/basic_workflow/","title":"Basic Workflow Tutorial","text":"<p>This tutorial walks through a complete PyPopART analysis from start to finish.</p>"},{"location":"tutorials/basic_workflow/#overview","title":"Overview","text":"<p>We'll analyze a sample dataset of mitochondrial DNA sequences to: 1. Load sequence data 2. Build a haplotype network 3. Calculate statistics 4. Create visualizations 5. Export results</p>"},{"location":"tutorials/basic_workflow/#prerequisites","title":"Prerequisites","text":"<pre><code>pip install pypopart\n</code></pre>"},{"location":"tutorials/basic_workflow/#step-1-prepare-your-data","title":"Step 1: Prepare Your Data","text":"<p>Create a FASTA file with aligned sequences:</p> <pre><code>&gt;Sample1_PopA\nATCGATCGATCGATCGATCGTACGATCG\n&gt;Sample2_PopA\nATCGATCGATCGATCGATCGTACGATCG\n&gt;Sample3_PopA\nATCGATCGATCGATCGATCGTACGATCG\n&gt;Sample4_PopB\nATCGATCGATCGATTGATCGTACGATCG\n&gt;Sample5_PopB\nATCGATCGATCGATTGATCGTACGATCG\n&gt;Sample6_PopC\nATCGATCGATCGATTGATCGTACGTTCG\n</code></pre> <p>Save as <code>sequences.fasta</code>.</p>"},{"location":"tutorials/basic_workflow/#step-2-load-data","title":"Step 2: Load Data","text":"<pre><code>from pypopart import Alignment\n\n# Load sequences\nalignment = Alignment.from_fasta(\"sequences.fasta\")\n\n# Check alignment\nprint(f\"Sequences: {len(alignment)}\")\nprint(f\"Length: {alignment.length}\")\nprint(f\"Unique haplotypes: {alignment.n_unique()}\")\n</code></pre>"},{"location":"tutorials/basic_workflow/#step-3-build-network","title":"Step 3: Build Network","text":"<pre><code>from pypopart.algorithms import MSTAlgorithm, MJNAlgorithm\n\n# Start with simple MST\nmst_algorithm = MSTAlgorithm()\nmst_network = mst_algorithm.build_network(alignment)\n\nprint(f\"MST - Nodes: {mst_network.number_of_nodes()}, Edges: {mst_network.number_of_edges()}\")\n\n# Try comprehensive MJN\nmjn_algorithm = MJNAlgorithm()\nmjn_network = mjn_algorithm.build_network(alignment)\n\nprint(f\"MJN - Nodes: {mjn_network.number_of_nodes()}, Edges: {mjn_network.number_of_edges()}\")\n</code></pre>"},{"location":"tutorials/basic_workflow/#step-4-calculate-statistics","title":"Step 4: Calculate Statistics","text":"<pre><code>from pypopart.stats import NetworkStatistics, PopulationGenetics\n\n# Network statistics\nstats = NetworkStatistics(mst_network)\nprint(f\"\\nNetwork Statistics:\")\nprint(f\"  Diameter: {stats.diameter()}\")\nprint(f\"  Avg path length: {stats.average_path_length():.3f}\")\nprint(f\"  Clustering: {stats.clustering_coefficient():.3f}\")\n\n# Population genetics\npopgen = PopulationGenetics(alignment)\nprint(f\"\\nPopulation Genetics:\")\nprint(f\"  Haplotype diversity: {popgen.haplotype_diversity():.4f}\")\nprint(f\"  Nucleotide diversity: {popgen.nucleotide_diversity():.4f}\")\nprint(f\"  Tajima's D: {popgen.tajimas_d():.4f}\")\n</code></pre>"},{"location":"tutorials/basic_workflow/#step-5-visualize","title":"Step 5: Visualize","text":"<pre><code>from pypopart.visualization import StaticPlot, InteractivePlot\n\n# Static plot\nstatic = StaticPlot(mst_network, figsize=(10, 10))\nstatic.save(\"mst_network.png\", dpi=300)\n\n# Interactive HTML plot\ninteractive = InteractivePlot(mjn_network)\ninteractive.save(\"mjn_network.html\")\n\nprint(\"\\nPlots saved!\")\n</code></pre>"},{"location":"tutorials/basic_workflow/#step-6-export-results","title":"Step 6: Export Results","text":"<pre><code># Save networks\nmst_network.save(\"mst_network.gml\")\nmjn_network.save(\"mjn_network.nexus\")\n\n# Save statistics report\nimport json\n\nreport = {\n    \"network\": {\n        \"nodes\": stats.number_of_nodes(),\n        \"edges\": stats.number_of_edges(),\n        \"diameter\": stats.diameter(),\n    },\n    \"diversity\": {\n        \"haplotype\": popgen.haplotype_diversity(),\n        \"nucleotide\": popgen.nucleotide_diversity(),\n    }\n}\n\nwith open(\"analysis_report.json\", \"w\") as f:\n    json.dump(report, f, indent=2)\n\nprint(\"Results exported!\")\n</code></pre>"},{"location":"tutorials/basic_workflow/#complete-script","title":"Complete Script","text":"<p>Here's the full workflow in one script:</p> <pre><code>from pypopart import Alignment\nfrom pypopart.algorithms import MSTAlgorithm, MJNAlgorithm\nfrom pypopart.stats import NetworkStatistics, PopulationGenetics\nfrom pypopart.visualization import StaticPlot, InteractivePlot\nimport json\n\n# Load data\nalignment = Alignment.from_fasta(\"sequences.fasta\")\nprint(f\"Loaded {len(alignment)} sequences\")\n\n# Build networks\nmst_network = MSTAlgorithm().build_network(alignment)\nmjn_network = MJNAlgorithm().build_network(alignment)\n\n# Calculate statistics\nstats = NetworkStatistics(mst_network)\npopgen = PopulationGenetics(alignment)\n\n# Create visualizations\nStaticPlot(mst_network).save(\"mst_network.png\")\nInteractivePlot(mjn_network).save(\"mjn_network.html\")\n\n# Export results\nmst_network.save(\"mst_network.gml\")\nreport = {\n    \"nodes\": stats.number_of_nodes(),\n    \"haplotype_diversity\": popgen.haplotype_diversity(),\n    \"nucleotide_diversity\": popgen.nucleotide_diversity(),\n}\nwith open(\"report.json\", \"w\") as f:\n    json.dump(report, f, indent=2)\n\nprint(\"Analysis complete!\")\n</code></pre>"},{"location":"tutorials/basic_workflow/#cli-equivalent","title":"CLI Equivalent","text":"<p>The same workflow using command-line tools:</p> <pre><code># Build network\npypopart network sequences.fasta -a MST -o mst_network --plot\n\n# Calculate statistics\npypopart stats mst_network.gml --topology --popgen -o stats.txt\n\n# Create visualization\npypopart plot mst_network.gml -o network.png --width 2000 --height 2000\n</code></pre>"},{"location":"tutorials/basic_workflow/#next-steps","title":"Next Steps","text":"<ul> <li>Algorithm Comparison: Compare different algorithms</li> <li>Visualization Tutorial: Advanced plotting</li> <li>Population Genetics: Detailed population analysis</li> <li>User Guide: Complete documentation</li> </ul>"},{"location":"tutorials/popgen/","title":"Population Genetics Tutorial","text":"<p>Comprehensive population genetics analysis with PyPopART.</p>"},{"location":"tutorials/popgen/#overview","title":"Overview","text":"<p>This tutorial demonstrates: - Diversity measures - Neutrality tests - Population structure analysis - FST calculation - Demographic inference</p>"},{"location":"tutorials/popgen/#setup","title":"Setup","text":"<pre><code>from pypopart import Alignment\nfrom pypopart.algorithms import TCSAlgorithm\nfrom pypopart.stats import PopulationGenetics, NetworkStatistics\nfrom pypopart.visualization import StaticPlot\nimport pandas as pd\nimport matplotlib.pyplot as plt\n</code></pre>"},{"location":"tutorials/popgen/#load-data-with-metadata","title":"Load Data with Metadata","text":"<pre><code># Load sequences\nalignment = Alignment.from_nexus(\"sequences_with_traits.nex\")\n\n# Or add metadata programmatically\nalignment = Alignment.from_fasta(\"sequences.fasta\")\n\nmetadata = pd.DataFrame({\n    'sequence_id': ['Seq1', 'Seq2', 'Seq3', 'Seq4', 'Seq5', 'Seq6'],\n    'Population': ['PopA', 'PopA', 'PopA', 'PopB', 'PopB', 'PopC'],\n    'Location': ['Site1', 'Site1', 'Site1', 'Site2', 'Site2', 'Site3'],\n    'Year': [2020, 2020, 2020, 2021, 2021, 2022]\n})\n\nalignment.set_metadata(metadata)\n</code></pre>"},{"location":"tutorials/popgen/#diversity-analysis","title":"Diversity Analysis","text":"<pre><code>popgen = PopulationGenetics(alignment)\n\n# Haplotype diversity (Nei's h)\nh = popgen.haplotype_diversity()\nprint(f\"Haplotype diversity: {h:.4f}\")\n\n# Nucleotide diversity (\u03c0)\npi = popgen.nucleotide_diversity()\nprint(f\"Nucleotide diversity: {pi:.6f}\")\n\n# Theta (Watterson's estimator)\ntheta = popgen.theta_watterson()\nprint(f\"Theta (\u03b8w): {theta:.6f}\")\n\n# Shannon entropy\nshannon = popgen.shannon_entropy()\nprint(f\"Shannon index: {shannon:.4f}\")\n</code></pre>"},{"location":"tutorials/popgen/#neutrality-tests","title":"Neutrality Tests","text":"<pre><code># Tajima's D\ntajimas_d = popgen.tajimas_d()\nprint(f\"\\nTajima's D: {tajimas_d:.4f}\")\n\nif tajimas_d &lt; -2:\n    print(\"  \u2192 Population expansion or purifying selection\")\nelif tajimas_d &gt; 2:\n    print(\"  \u2192 Balancing selection or population contraction\")\nelse:\n    print(\"  \u2192 Consistent with neutral evolution\")\n\n# Fu's Fs\nfus_fs = popgen.fus_fs()\nprint(f\"\\nFu's Fs: {fus_fs:.4f}\")\n\nif fus_fs &lt; -3:\n    print(\"  \u2192 Evidence for population expansion\")\nelse:\n    print(\"  \u2192 No strong evidence for expansion\")\n\n# Fu and Li's D* and F*\nfu_li_d = popgen.fu_li_d_star()\nfu_li_f = popgen.fu_li_f_star()\nprint(f\"\\nFu and Li's D*: {fu_li_d:.4f}\")\nprint(f\"Fu and Li's F*: {fu_li_f:.4f}\")\n</code></pre>"},{"location":"tutorials/popgen/#population-structure","title":"Population Structure","text":"<pre><code># FST between all populations\nfst_total = popgen.calculate_fst(population_column='Population')\nprint(f\"\\nOverall FST: {fst_total:.4f}\")\n\nif fst_total &lt; 0.05:\n    print(\"  \u2192 Little differentiation\")\nelif fst_total &lt; 0.15:\n    print(\"  \u2192 Moderate differentiation\")\nelif fst_total &lt; 0.25:\n    print(\"  \u2192 Great differentiation\")\nelse:\n    print(\"  \u2192 Very great differentiation\")\n\n# Pairwise FST\npairwise_fst = popgen.pairwise_fst(population_column='Population')\nprint(\"\\nPairwise FST:\")\nprint(pairwise_fst)\n\n# Gene flow (Nm)\nnm = popgen.gene_flow(population_column='Population')\nprint(f\"\\nGene flow (Nm): {nm:.2f}\")\nif nm &lt; 1:\n    print(\"  \u2192 Limited gene flow\")\nelse:\n    print(\"  \u2192 Substantial gene flow\")\n</code></pre>"},{"location":"tutorials/popgen/#site-frequency-spectrum","title":"Site Frequency Spectrum","text":"<pre><code># Calculate SFS\nsfs = popgen.site_frequency_spectrum()\nprint(f\"\\nSite Frequency Spectrum: {sfs}\")\n\n# Plot SFS\nplt.figure(figsize=(10, 6))\nplt.bar(range(1, len(sfs) + 1), sfs)\nplt.xlabel(\"Allele Count\")\nplt.ylabel(\"Number of Sites\")\nplt.title(\"Site Frequency Spectrum\")\nplt.savefig(\"sfs.png\", dpi=300)\n\n# Segregating sites\ns = popgen.segregating_sites()\nprint(f\"\\nSegregating sites: {s}\")\n</code></pre>"},{"location":"tutorials/popgen/#network-based-analysis","title":"Network-Based Analysis","text":"<pre><code># Build network\nnetwork = TCSAlgorithm().build_network(alignment)\n\n# Network statistics\nnet_stats = NetworkStatistics(network)\nprint(f\"\\nNetwork properties:\")\nprint(f\"  Haplotypes: {net_stats.number_of_nodes()}\")\nprint(f\"  Connections: {net_stats.number_of_edges()}\")\nprint(f\"  Diameter: {net_stats.diameter()}\")\n\n# Visualize with population colors\nplot = StaticPlot(network, figsize=(10, 10))\nplot.color_by_attribute(\"Population\")\nplot.size_by_frequency(min_size=200, max_size=1000)\nplot.add_legend(title=\"Population\")\nplot.save(\"population_network.png\", dpi=300)\n</code></pre>"},{"location":"tutorials/popgen/#per-population-analysis","title":"Per-Population Analysis","text":"<pre><code># Analyze each population separately\npopulations = metadata['Population'].unique()\n\npop_results = []\nfor pop in populations:\n    # Subset alignment\n    pop_seqs = metadata[metadata['Population'] == pop]['sequence_id'].tolist()\n    pop_aln = alignment.subset(pop_seqs)\n\n    # Calculate diversity\n    pop_gen = PopulationGenetics(pop_aln)\n    pop_results.append({\n        'Population': pop,\n        'N': len(pop_aln),\n        'Haplotypes': pop_aln.n_unique(),\n        'Hap_Diversity': pop_gen.haplotype_diversity(),\n        'Nuc_Diversity': pop_gen.nucleotide_diversity(),\n        'Tajimas_D': pop_gen.tajimas_d(),\n    })\n\n# Create summary table\ndf = pd.DataFrame(pop_results)\nprint(\"\\nPer-Population Statistics:\")\nprint(df.to_string(index=False))\ndf.to_csv(\"population_statistics.csv\", index=False)\n</code></pre>"},{"location":"tutorials/popgen/#amova-analysis-of-molecular-variance","title":"AMOVA (Analysis of Molecular Variance)","text":"<pre><code>from pypopart.stats import SpatialAnalysis\n\nspatial = SpatialAnalysis(alignment, network)\n\n# AMOVA by population\namova = spatial.amova(group_column='Population')\nprint(\"\\nAMOVA Results:\")\nprint(f\"  Among populations: {amova['among']:.2f}%\")\nprint(f\"  Within populations: {amova['within']:.2f}%\")\nprint(f\"  FST: {amova['fst']:.4f}\")\nprint(f\"  P-value: {amova['p_value']:.4f}\")\n</code></pre>"},{"location":"tutorials/popgen/#temporal-analysis","title":"Temporal Analysis","text":"<pre><code># Diversity through time\nyears = sorted(metadata['Year'].unique())\ntemporal_diversity = []\n\nfor year in years:\n    year_seqs = metadata[metadata['Year'] == year]['sequence_id'].tolist()\n    year_aln = alignment.subset(year_seqs)\n    year_gen = PopulationGenetics(year_aln)\n\n    temporal_diversity.append({\n        'Year': year,\n        'Haplotype_Diversity': year_gen.haplotype_diversity(),\n        'Nucleotide_Diversity': year_gen.nucleotide_diversity(),\n    })\n\n# Plot temporal trends\ndf_temporal = pd.DataFrame(temporal_diversity)\n\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 5))\n\nax1.plot(df_temporal['Year'], df_temporal['Haplotype_Diversity'], 'o-')\nax1.set_xlabel('Year')\nax1.set_ylabel('Haplotype Diversity')\nax1.set_title('Haplotype Diversity Over Time')\n\nax2.plot(df_temporal['Year'], df_temporal['Nucleotide_Diversity'], 'o-')\nax2.set_xlabel('Year')\nax2.set_ylabel('Nucleotide Diversity')\nax2.set_title('Nucleotide Diversity Over Time')\n\nplt.tight_layout()\nplt.savefig(\"temporal_diversity.png\", dpi=300)\n</code></pre>"},{"location":"tutorials/popgen/#complete-analysis-report","title":"Complete Analysis Report","text":"<pre><code># Generate comprehensive report\nreport = {\n    \"Dataset\": {\n        \"sequences\": len(alignment),\n        \"length\": alignment.length,\n        \"haplotypes\": alignment.n_unique(),\n    },\n    \"Diversity\": {\n        \"haplotype\": round(popgen.haplotype_diversity(), 4),\n        \"nucleotide\": round(popgen.nucleotide_diversity(), 6),\n        \"theta\": round(popgen.theta_watterson(), 6),\n    },\n    \"Neutrality\": {\n        \"tajimas_d\": round(popgen.tajimas_d(), 4),\n        \"fus_fs\": round(popgen.fus_fs(), 4),\n    },\n    \"Structure\": {\n        \"fst\": round(popgen.calculate_fst(population_column='Population'), 4),\n        \"nm\": round(popgen.gene_flow(population_column='Population'), 2),\n    },\n    \"Network\": {\n        \"nodes\": net_stats.number_of_nodes(),\n        \"edges\": net_stats.number_of_edges(),\n        \"diameter\": net_stats.diameter(),\n    }\n}\n\n# Save report\nimport json\nwith open(\"popgen_report.json\", \"w\") as f:\n    json.dump(report, f, indent=2)\n\n# Print summary\nprint(\"\\n\" + \"=\"*50)\nprint(\"POPULATION GENETICS SUMMARY\")\nprint(\"=\"*50)\nfor category, values in report.items():\n    print(f\"\\n{category}:\")\n    for key, value in values.items():\n        print(f\"  {key}: {value}\")\n</code></pre>"},{"location":"tutorials/popgen/#interpreting-results","title":"Interpreting Results","text":""},{"location":"tutorials/popgen/#tajimas-d","title":"Tajima's D","text":"<ul> <li>&lt; -2: Population expansion or purifying selection</li> <li>-2 to +2: Neutral evolution</li> <li>&gt; +2: Balancing selection or bottleneck</li> </ul>"},{"location":"tutorials/popgen/#fst","title":"FST","text":"<ul> <li>0.00-0.05: Little differentiation</li> <li>0.05-0.15: Moderate differentiation</li> <li>0.15-0.25: Great differentiation</li> <li>&gt; 0.25: Very great differentiation</li> </ul>"},{"location":"tutorials/popgen/#gene-flow-nm","title":"Gene Flow (Nm)","text":"<ul> <li>&lt; 1: Limited gene flow, drift dominates</li> <li>&gt; 1: Substantial gene flow</li> <li>&gt; 4: Panmixia</li> </ul>"},{"location":"tutorials/popgen/#next-steps","title":"Next Steps","text":"<ul> <li>Basic Workflow: General analysis</li> <li>Algorithm Comparison: Network algorithms</li> <li>Analysis Guide: Complete documentation</li> </ul>"},{"location":"tutorials/visualization/","title":"Visualization Tutorial","text":"<p>Learn advanced visualization techniques for creating publication-quality figures.</p>"},{"location":"tutorials/visualization/#overview","title":"Overview","text":"<p>This tutorial covers: - Static plots for publications - Interactive HTML plots - Color schemes and styling - Layouts and customization - Multi-panel figures</p>"},{"location":"tutorials/visualization/#basic-visualization","title":"Basic Visualization","text":"<pre><code>from pypopart import Alignment\nfrom pypopart.algorithms import MJNAlgorithm\nfrom pypopart.visualization import StaticPlot, InteractivePlot\n\n# Load and build network\nalignment = Alignment.from_fasta(\"sequences.fasta\")\nnetwork = MJNAlgorithm().build_network(alignment)\n\n# Simple static plot\nplot = StaticPlot(network)\nplot.save(\"network.png\")\n\n# Simple interactive plot\ninteractive = InteractivePlot(network)\ninteractive.save(\"network.html\")\n</code></pre>"},{"location":"tutorials/visualization/#publication-quality-figure","title":"Publication-Quality Figure","text":"<pre><code>import matplotlib.pyplot as plt\n\n# Set publication style\nplt.rcParams.update({\n    'font.size': 12,\n    'font.family': 'Arial',\n    'axes.linewidth': 1.5,\n    'figure.dpi': 300,\n})\n\n# Create plot\nplot = StaticPlot(\n    network,\n    figsize=(8, 8),\n    layout=\"spring\",\n    node_size=400,\n    edge_width=1.5,\n    show_labels=True,\n    font_size=10,\n)\n\n# Save in multiple formats\nplot.save(\"figure1.png\", dpi=300)    # For presentations\nplot.save(\"figure1.pdf\")              # For publication\nplot.save(\"figure1.svg\")              # For editing\n</code></pre>"},{"location":"tutorials/visualization/#coloring-by-metadata","title":"Coloring by Metadata","text":"<pre><code># Color nodes by population\nplot = StaticPlot(network)\nplot.color_by_attribute(\"Population\")\nplot.add_legend(title=\"Population\")\nplot.save(\"colored_by_population.png\")\n\n# Custom color scheme\ncolor_map = {\n    \"PopA\": \"#1f78b4\",\n    \"PopB\": \"#33a02c\",\n    \"PopC\": \"#e31a1c\",\n}\nplot.color_by_attribute(\"Population\", color_map=color_map)\nplot.save(\"custom_colors.png\")\n\n# Continuous values (e.g., year)\nplot.color_by_attribute(\"Year\", cmap=\"viridis\")\nplot.add_colorbar(label=\"Year\")\nplot.save(\"temporal.png\")\n</code></pre>"},{"location":"tutorials/visualization/#node-sizing","title":"Node Sizing","text":"<pre><code># Size by frequency\nplot = StaticPlot(network)\nplot.size_by_frequency(min_size=100, max_size=1000)\nplot.save(\"sized_by_frequency.png\")\n\n# Size by custom attribute\nplot.size_by_attribute(\"SampleSize\", min_size=50, max_size=800)\nplot.save(\"sized_by_samples.png\")\n</code></pre>"},{"location":"tutorials/visualization/#layout-algorithms","title":"Layout Algorithms","text":"<pre><code>layouts = [\"spring\", \"circular\", \"kamada-kawai\", \"spectral\"]\n\nfig, axes = plt.subplots(2, 2, figsize=(16, 16))\naxes = axes.flatten()\n\nfor ax, layout in zip(axes, layouts):\n    plot = StaticPlot(network, ax=ax, layout=layout)\n    ax.set_title(f\"{layout.title()} Layout\")\n\nplt.tight_layout()\nplt.savefig(\"layout_comparison.png\", dpi=300)\n</code></pre>"},{"location":"tutorials/visualization/#interactive-visualization","title":"Interactive Visualization","text":"<pre><code># Rich interactive plot\nplot = InteractivePlot(\n    network,\n    layout=\"spring\",\n    width=1200,\n    height=800,\n    title=\"Interactive Haplotype Network\",\n    node_size_by=\"frequency\",\n    color_by=\"Population\",\n    show_edge_labels=True,\n    hover_data=[\"Population\", \"Location\", \"Frequency\"],\n)\n\nplot.save(\"interactive_network.html\")\n</code></pre>"},{"location":"tutorials/visualization/#multi-panel-figures","title":"Multi-Panel Figures","text":"<pre><code>from pypopart.algorithms import MSTAlgorithm, MSNAlgorithm, MJNAlgorithm\n\n# Build multiple networks\nmst_net = MSTAlgorithm().build_network(alignment)\nmsn_net = MSNAlgorithm().build_network(alignment)\nmjn_net = MJNAlgorithm().build_network(alignment)\n\n# Create multi-panel figure\nfig, axes = plt.subplots(1, 3, figsize=(18, 6))\n\nnetworks = [mst_net, msn_net, mjn_net]\ntitles = [\"MST\", \"MSN\", \"MJN\"]\n\nfor ax, net, title in zip(axes, networks, titles):\n    plot = StaticPlot(net, ax=ax, layout=\"spring\")\n    plot.color_by_attribute(\"Population\")\n    ax.set_title(title, fontsize=16, fontweight='bold')\n\nplt.tight_layout()\nplt.savefig(\"multi_panel.png\", dpi=300)\n</code></pre>"},{"location":"tutorials/visualization/#highlighting-specific-nodes","title":"Highlighting Specific Nodes","text":"<pre><code># Highlight hub haplotypes\nfrom pypopart.stats import TopologyAnalysis\n\ntopology = TopologyAnalysis(network)\nhubs = topology.identify_hubs()\n\nplot = StaticPlot(network)\nplot.highlight_nodes(\n    hubs,\n    color=\"#ff0000\",\n    size=800,\n    edge_color=\"#ff0000\",\n    edge_width=3\n)\nplot.save(\"highlighted_hubs.png\")\n</code></pre>"},{"location":"tutorials/visualization/#styling-median-vectors-mjn","title":"Styling Median Vectors (MJN)","text":"<pre><code># Different style for observed vs inferred nodes\nobserved = [n for n in network.nodes() if network.nodes[n].get(\"type\") == \"observed\"]\nmedian = [n for n in network.nodes() if network.nodes[n].get(\"type\") == \"median\"]\n\nplot = StaticPlot(network)\nplot.style_nodes(observed, shape=\"o\", color=\"#1f78b4\", size=500)\nplot.style_nodes(median, shape=\"s\", color=\"#ff7f00\", size=200)\nplot.add_legend(handles={\n    \"Observed\": {\"color\": \"#1f78b4\", \"marker\": \"o\"},\n    \"Inferred\": {\"color\": \"#ff7f00\", \"marker\": \"s\"}\n})\nplot.save(\"styled_medians.png\")\n</code></pre>"},{"location":"tutorials/visualization/#adding-annotations","title":"Adding Annotations","text":"<pre><code>plot = StaticPlot(network, layout=\"spring\")\n\n# Annotate specific nodes\nplot.annotate_node(\"H1\", \"Most common\", fontsize=12, color=\"red\")\nplot.annotate_node(\"H5\", \"Ancestral?\", fontsize=12, color=\"blue\")\n\n# Add scale bar\nplot.add_scale_bar(mutations_per_unit=1, label=\"1 mutation\")\n\n# Add text box with information\nplot.add_textbox(\n    \"MJN Algorithm\\nK2P Distance\\nn=50\",\n    position=(0.05, 0.95),\n    fontsize=10\n)\n\nplot.save(\"annotated_network.png\")\n</code></pre>"},{"location":"tutorials/visualization/#colorblind-friendly-palettes","title":"Colorblind-Friendly Palettes","text":"<pre><code>from pypopart.visualization.colors import colorblind_safe\n\nplot = StaticPlot(network)\nplot.color_by_attribute(\"Population\", colors=colorblind_safe)\nplot.save(\"colorblind_safe.png\")\n</code></pre>"},{"location":"tutorials/visualization/#export-for-other-tools","title":"Export for Other Tools","text":"<pre><code># For Gephi\nnetwork.save(\"network.gexf\")\n\n# For Cytoscape\nnetwork.save(\"network.graphml\")\n\n# For R/igraph\nnetwork.save(\"network.gml\")\n\n# With metadata\nnetwork.save(\"network_with_traits.nexus\", include_traits=True)\n</code></pre>"},{"location":"tutorials/visualization/#complete-visualization-script","title":"Complete Visualization Script","text":"<pre><code>from pypopart import Alignment\nfrom pypopart.algorithms import MJNAlgorithm\nfrom pypopart.visualization import StaticPlot, InteractivePlot\nfrom pypopart.stats import TopologyAnalysis\nimport matplotlib.pyplot as plt\n\n# Load data and build network\nalignment = Alignment.from_fasta(\"sequences.fasta\")\nnetwork = MJNAlgorithm().build_network(alignment)\n\n# Identify hubs\nhubs = TopologyAnalysis(network).identify_hubs()\n\n# Create static plot\nplt.rcParams['font.size'] = 12\nplt.rcParams['font.family'] = 'Arial'\n\nplot = StaticPlot(\n    network,\n    figsize=(10, 10),\n    layout=\"spring\",\n    node_size=400,\n)\n\n# Style by metadata\nplot.color_by_attribute(\"Population\")\nplot.size_by_frequency(min_size=200, max_size=1000)\nplot.highlight_nodes(hubs, color=\"#ff0000\", size=900)\n\n# Add annotations\nplot.add_legend(title=\"Population\")\nplot.add_scale_bar(mutations_per_unit=1)\n\n# Save in multiple formats\nplot.save(\"network.png\", dpi=300)\nplot.save(\"network.pdf\")\n\n# Create interactive version\ninteractive = InteractivePlot(\n    network,\n    color_by=\"Population\",\n    node_size_by=\"frequency\",\n    hover_data=[\"Population\", \"Frequency\"],\n)\ninteractive.save(\"network.html\")\n\nprint(\"Visualization complete!\")\n</code></pre>"},{"location":"tutorials/visualization/#tips-for-great-figures","title":"Tips for Great Figures","text":"<ol> <li>Resolution: Use DPI \u2265 300 for publications</li> <li>Format: PDF/SVG for journals, PNG for presentations</li> <li>Colors: Use colorblind-safe palettes</li> <li>Size: Large enough to be readable when printed</li> <li>Labels: Clear and informative</li> <li>Legend: Always include for colored nodes</li> <li>Scale: Add scale bar for mutation context</li> </ol>"},{"location":"tutorials/visualization/#next-steps","title":"Next Steps","text":"<ul> <li>Basic Workflow: Complete analysis</li> <li>Population Genetics: Advanced analyses</li> <li>Visualization Guide: Full documentation</li> </ul>"}]}